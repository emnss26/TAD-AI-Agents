{"prompt":"Crea un muro de 5 metros de largo y 3 metros de alto.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nWallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\nif (level != null && wallType != null)\n{\n    Line line = Line.CreateBound(new XYZ(0,0,0), new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0, 0));\n    Wall.Create(doc, line, wallType.Id, level.Id, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0.0, false, false);\n}"}
{"prompt":"Create a wall 5 meters long and 3 meters high.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nWallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\nif (level != null && wallType != null)\n{\n    Line line = Line.CreateBound(new XYZ(0,0,0), new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0, 0));\n    Wall.Create(doc, line, wallType.Id, level.Id, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0.0, false, false);\n}"}
{"prompt":"Dibuja una pared de 5m de largo por 3m de altura.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nWallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\nif (level != null && wallType != null)\n{\n    Line line = Line.CreateBound(new XYZ(0,0,0), new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0, 0));\n    Wall.Create(doc, line, wallType.Id, level.Id, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0.0, false, false);\n}"}
{"prompt":"Inserta una ventana de 1 metro de ancho y 1.2 metros de alto en un muro.","completion":"FamilySymbol windowSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsElementType().Cast<FamilySymbol>().FirstOrDefault();\nWall hostWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault() as Wall;\nif (windowSymbol != null && hostWall != null)\n{\n    if (!windowSymbol.IsActive) windowSymbol.Activate();\n    Level level = doc.GetElement(hostWall.LevelId) as Level;\n    XYZ insertionPoint = (hostWall.Location as LocationCurve).Curve.Evaluate(0.5, true);\n    doc.Create.NewFamilyInstance(insertionPoint, windowSymbol, hostWall, level, StructuralType.NonStructural);\n}"}
{"prompt":"Insert a window 1m wide and 1.2m high into a wall.","completion":"FamilySymbol windowSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsElementType().Cast<FamilySymbol>().FirstOrDefault();\nWall hostWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault() as Wall;\nif (windowSymbol != null && hostWall != null)\n{\n    if (!windowSymbol.IsActive) windowSymbol.Activate();\n    Level level = doc.GetElement(hostWall.LevelId) as Level;\n    XYZ insertionPoint = (hostWall.Location as LocationCurve).Curve.Evaluate(0.5, true);\n    doc.Create.NewFamilyInstance(insertionPoint, windowSymbol, hostWall, level, StructuralType.NonStructural);\n}"}
{"prompt":"Coloca una ventana de 1x1.2 metros en la pared más cercana.","completion":"FamilySymbol windowSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsElementType().Cast<FamilySymbol>().FirstOrDefault();\nWall hostWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault() as Wall;\nif (windowSymbol != null && hostWall != null)\n{\n    if (!windowSymbol.IsActive) windowSymbol.Activate();\n    Level level = doc.GetElement(hostWall.LevelId) as Level;\n    XYZ insertionPoint = (hostWall.Location as LocationCurve).Curve.Evaluate(0.5, true);\n    doc.Create.NewFamilyInstance(insertionPoint, windowSymbol, hostWall, level, StructuralType.NonStructural);\n}"}
{"prompt":"Crea una columna estructural en la posición X=10, Y=5.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFamilySymbol columnSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nif (level != null && columnSymbol != null)\n{\n    if (!columnSymbol.IsActive) columnSymbol.Activate();\n    doc.Create.NewFamilyInstance(new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0), columnSymbol, level, StructuralType.Column);\n}"}
{"prompt":"Create a structural column at position X=10, Y=5.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFamilySymbol columnSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nif (level != null && columnSymbol != null)\n{\n    if (!columnSymbol.IsActive) columnSymbol.Activate();\n    doc.Create.NewFamilyInstance(new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0), columnSymbol, level, StructuralType.Column);\n}"}
{"prompt":"Pon un pilar estructural en las coordenadas 10,5.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFamilySymbol columnSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nif (level != null && columnSymbol != null)\n{\n    if (!columnSymbol.IsActive) columnSymbol.Activate();\n    doc.Create.NewFamilyInstance(new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0), columnSymbol, level, StructuralType.Column);\n}"}
{"prompt":"Genera un piso rectangular de 10×8 metros.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\nif (level != null && floorType != null)\n{\n    double width = UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters);\n    double length = UnitUtils.ConvertToInternalUnits(8, UnitTypeId.Meters);\n    CurveLoop loop = new CurveLoop();\n    loop.Append(Line.CreateBound(new XYZ(0,0,0), new XYZ(width,0,0)));\n    loop.Append(Line.CreateBound(new XYZ(width,0,0), new XYZ(width,length,0)));\n    loop.Append(Line.CreateBound(new XYZ(width,length,0), new XYZ(0,length,0)));\n    loop.Append(Line.CreateBound(new XYZ(0,length,0), new XYZ(0,0,0)));\n    Floor.Create(doc, new List<CurveLoop> { loop }, floorType.Id, level.Id);\n}"}
{"prompt":"Generate a rectangular floor of 10x8 meters.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\nif (level != null && floorType != null)\n{\n    double width = UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters);\n    double length = UnitUtils.ConvertToInternalUnits(8, UnitTypeId.Meters);\n    CurveLoop loop = new CurveLoop();\n    loop.Append(Line.CreateBound(new XYZ(0,0,0), new XYZ(width,0,0)));\n    loop.Append(Line.CreateBound(new XYZ(width,0,0), new XYZ(width,length,0)));\n    loop.Append(Line.CreateBound(new XYZ(width,length,0), new XYZ(0,length,0)));\n    loop.Append(Line.CreateBound(new XYZ(0,length,0), new XYZ(0,0,0)));\n    Floor.Create(doc, new List<CurveLoop> { loop }, floorType.Id, level.Id);\n}"}
{"prompt":"Crea un suelo con un contorno de 10 por 8 metros.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\nif (level != null && floorType != null)\n{\n    double width = UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters);\n    double length = UnitUtils.ConvertToInternalUnits(8, UnitTypeId.Meters);\n    CurveLoop loop = new CurveLoop();\n    loop.Append(Line.CreateBound(new XYZ(0,0,0), new XYZ(width,0,0)));\n    loop.Append(Line.CreateBound(new XYZ(width,0,0), new XYZ(width,length,0)));\n    loop.Append(Line.CreateBound(new XYZ(width,length,0), new XYZ(0,length,0)));\n    loop.Append(Line.CreateBound(new XYZ(0,length,0), new XYZ(0,0,0)));\n    Floor.Create(doc, new List<CurveLoop> { loop }, floorType.Id, level.Id);\n}"}
{"prompt":"Crea un muro cortina de 6 metros de ancho y 4 metros de alto.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nWallType cwType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).Cast<WallType>().FirstOrDefault(wt => wt.Kind == WallKind.Curtain);\nif (level != null && cwType != null)\n{\n    Line baseLine = Line.CreateBound(new XYZ(0,0,0), new XYZ(UnitUtils.ConvertToInternalUnits(6, UnitTypeId.Meters), 0, 0));\n    Wall.Create(doc, baseLine, cwType.Id, level.Id, UnitUtils.ConvertToInternalUnits(4.0, UnitTypeId.Meters), 0.0, false, false);\n}"}
{"prompt":"Create a curtain wall 6 meters wide and 4 meters high.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nWallType cwType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).Cast<WallType>().FirstOrDefault(wt => wt.Kind == WallKind.Curtain);\nif (level != null && cwType != null)\n{\n    Line baseLine = Line.CreateBound(new XYZ(0,0,0), new XYZ(UnitUtils.ConvertToInternalUnits(6, UnitTypeId.Meters), 0, 0));\n    Wall.Create(doc, baseLine, cwType.Id, level.Id, UnitUtils.ConvertToInternalUnits(4.0, UnitTypeId.Meters), 0.0, false, false);\n}"}
{"prompt":"Crea 8 ejes horizontales separados por 10 metros.","completion":"double separation = UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters);\nfor(int i = 0; i < 8; i++)\n{\n    Line line = Line.CreateBound(new XYZ(0, i * separation, 0), new XYZ(50, i * separation, 0));\n    Grid.Create(doc, line);\n}"}
{"prompt":"Create 8 horizontal grids spaced 10 meters apart.","completion":"double separation = UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters);\nfor(int i = 0; i < 8; i++)\n{\n    Line line = Line.CreateBound(new XYZ(0, i * separation, 0), new XYZ(50, i * separation, 0));\n    Grid.Create(doc, line);\n}"}
{"prompt":"Genera ocho rejillas horizontales con una separación de 10m.","completion":"double separation = UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters);\nfor(int i = 0; i < 8; i++)\n{\n    Line line = Line.CreateBound(new XYZ(0, i * separation, 0), new XYZ(50, i * separation, 0));\n    Grid.Create(doc, line);\n}"}
{"prompt":"Crea 4 ejes en sentido vertical separados 10 metros.","completion":"double separation = UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters);\nfor(int i=0; i<4; i++)\n{\n    Line line = Line.CreateBound(new XYZ(i * separation, 0, 0), new XYZ(i * separation, 40, 0));\n    Grid.Create(doc, line);\n}"}
{"prompt":"Create 4 vertical grids spaced 10 meters apart.","completion":"double separation = UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters);\nfor(int i=0; i<4; i++)\n{\n    Line line = Line.CreateBound(new XYZ(i * separation, 0, 0), new XYZ(i * separation, 40, 0));\n    Grid.Create(doc, line);\n}"}
{"prompt":"Crea columnas en cada intersección de ejes.","completion":"FamilySymbol colSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nList<Grid> grids = new FilteredElementCollector(doc).OfClass(typeof(Grid)).Cast<Grid>().ToList();\nif (colSymbol != null && level != null && grids.Count > 1)\n{\n    if (!colSymbol.IsActive) colSymbol.Activate();\n    for (int i = 0; i < grids.Count; i++)\n    {\n        for (int j = i + 1; j < grids.Count; j++)\n        {\n            var result = grids[i].Curve.Intersect(grids[j].Curve, out IntersectionResultArray results);\n            if (result == SetComparisonResult.Overlap && results != null)\n            {\n                foreach (IntersectionResult ir in results)\n                {\n                    doc.Create.NewFamilyInstance(ir.XYZPoint, colSymbol, level, StructuralType.Column);\n                }\n            }\n        }\n    }\n}"}
{"prompt":"Create columns at each grid intersection.","completion":"FamilySymbol colSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nList<Grid> grids = new FilteredElementCollector(doc).OfClass(typeof(Grid)).Cast<Grid>().ToList();\nif (colSymbol != null && level != null && grids.Count > 1)\n{\n    if (!colSymbol.IsActive) colSymbol.Activate();\n    for (int i = 0; i < grids.Count; i++)\n    {\n        for (int j = i + 1; j < grids.Count; j++)\n        {\n            var result = grids[i].Curve.Intersect(grids[j].Curve, out IntersectionResultArray results);\n            if (result == SetComparisonResult.Overlap && results != null)\n            {\n                foreach (IntersectionResult ir in results)\n                {\n                    doc.Create.NewFamilyInstance(ir.XYZPoint, colSymbol, level, StructuralType.Column);\n                }\n            }\n        }\n    }\n}"}
{"prompt":"Coloca pilares en todos los cruces de la rejilla.","completion":"FamilySymbol colSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nList<Grid> grids = new FilteredElementCollector(doc).OfClass(typeof(Grid)).Cast<Grid>().ToList();\nif (colSymbol != null && level != null && grids.Count > 1)\n{\n    if (!colSymbol.IsActive) colSymbol.Activate();\n    for (int i = 0; i < grids.Count; i++)\n    {\n        for (int j = i + 1; j < grids.Count; j++)\n        {\n            var result = grids[i].Curve.Intersect(grids[j].Curve, out IntersectionResultArray results);\n            if (result == SetComparisonResult.Overlap && results != null)\n            {\n                foreach (IntersectionResult ir in results)\n                {\n                    doc.Create.NewFamilyInstance(ir.XYZPoint, colSymbol, level, StructuralType.Column);\n                }\n            }\n        }\n    }\n}"}
{"prompt":"Crea vigas entre las columnas alineadas horizontalmente.","completion":"FamilySymbol beamSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nList<FamilyInstance> columns = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsNotElementType().Cast<FamilyInstance>().OrderBy(c => c.GetTransform().Origin.Y).ThenBy(c => c.GetTransform().Origin.X).ToList();\nif (beamSymbol != null && level != null && columns.Count > 1)\n{\n    if(!beamSymbol.IsActive) beamSymbol.Activate();\n    for(int i=0; i < columns.Count - 1; i++)\n    {\n        LocationPoint p1 = columns[i].Location as LocationPoint;\n        LocationPoint p2 = columns[i+1].Location as LocationPoint;\n        if (p1 != null && p2 != null && Math.Abs(p1.Point.Y - p2.Point.Y) < 0.01)\n        {\n            Line line = Line.CreateBound(p1.Point, p2.Point);\n            doc.Create.NewFamilyInstance(line, beamSymbol, level, StructuralType.Beam);\n        }\n    }\n}"}
{"prompt":"Create beams between horizontally aligned columns.","completion":"FamilySymbol beamSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nList<FamilyInstance> columns = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsNotElementType().Cast<FamilyInstance>().OrderBy(c => c.GetTransform().Origin.Y).ThenBy(c => c.GetTransform().Origin.X).ToList();\nif (beamSymbol != null && level != null && columns.Count > 1)\n{\n    if(!beamSymbol.IsActive) beamSymbol.Activate();\n    for(int i=0; i < columns.Count - 1; i++)\n    {\n        LocationPoint p1 = columns[i].Location as LocationPoint;\n        LocationPoint p2 = columns[i+1].Location as LocationPoint;\n        if (p1 != null && p2 != null && Math.Abs(p1.Point.Y - p2.Point.Y) < 0.01)\n        {\n            Line line = Line.CreateBound(p1.Point, p2.Point);\n            doc.Create.NewFamilyInstance(line, beamSymbol, level, StructuralType.Beam);\n        }\n    }\n}"}
{"prompt":"Acota la longitud de un muro seleccionado por el usuario.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference wallRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un muro para acotar\");\nif (wallRef != null)\n{\n    Wall wall = doc.GetElement(wallRef) as Wall;\n    if (wall != null)\n    {\n        LocationCurve locCurve = wall.Location as LocationCurve;\n        if(locCurve.Curve is Line wallLine)\n        {\n             ReferenceArray refs = new ReferenceArray();\n             refs.Append(wallLine.GetEndPointReference(0));\n             refs.Append(wallLine.GetEndPointReference(1));\n             XYZ pt1 = wallLine.GetEndPoint(0).Add(XYZ.BasisZ * 2);\n             XYZ pt2 = wallLine.GetEndPoint(1).Add(XYZ.BasisZ * 2);\n             Line dimLine = Line.CreateBound(pt1, pt2);\n             doc.Create.NewDimension(doc.ActiveView, dimLine, refs);\n        }\n    }\n}"}
{"prompt":"Dimension the length of a user-selected wall.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference wallRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a wall to dimension\");\nif (wallRef != null)\n{\n    Wall wall = doc.GetElement(wallRef) as Wall;\n    if (wall != null)\n    {\n        LocationCurve locCurve = wall.Location as LocationCurve;\n        if(locCurve.Curve is Line wallLine)\n        {\n             ReferenceArray refs = new ReferenceArray();\n             refs.Append(wallLine.GetEndPointReference(0));\n             refs.Append(wallLine.GetEndPointReference(1));\n             XYZ pt1 = wallLine.GetEndPoint(0).Add(XYZ.BasisZ * 2);\n             XYZ pt2 = wallLine.GetEndPoint(1).Add(XYZ.BasisZ * 2);\n             Line dimLine = Line.CreateBound(pt1, pt2);\n             doc.Create.NewDimension(doc.ActiveView, dimLine, refs);\n        }\n    }\n}"}
{"prompt":"Crea una puerta de 0.9m de ancho y 2.1m de alto en el muro.","completion":"Wall hostWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault() as Wall;\nFamilySymbol doorSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().Cast<FamilySymbol>().FirstOrDefault();\nif(hostWall != null && doorSymbol != null)\n{\n    if(!doorSymbol.IsActive) doorSymbol.Activate();\n    Level level = doc.GetElement(hostWall.LevelId) as Level;\n    XYZ insertionPoint = (hostWall.Location as LocationCurve).Curve.Evaluate(0.5, true);\n    doc.Create.NewFamilyInstance(insertionPoint, doorSymbol, hostWall, level, StructuralType.NonStructural);\n}"}
{"prompt":"Create a door 0.9m wide and 2.1m high in the wall.","completion":"Wall hostWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault() as Wall;\nFamilySymbol doorSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().Cast<FamilySymbol>().FirstOrDefault();\nif(hostWall != null && doorSymbol != null)\n{\n    if(!doorSymbol.IsActive) doorSymbol.Activate();\n    Level level = doc.GetElement(hostWall.LevelId) as Level;\n    XYZ insertionPoint = (hostWall.Location as LocationCurve).Curve.Evaluate(0.5, true);\n    doc.Create.NewFamilyInstance(insertionPoint, doorSymbol, hostWall, level, StructuralType.NonStructural);\n}"}
{"prompt":"Crea un nuevo Nivel llamado 'Nivel 4' a una elevación de 12 metros.","completion":"string levelName = \"Nivel 4\";\nif (!new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == levelName))\n{\n    double elevation = UnitUtils.ConvertToInternalUnits(12, UnitTypeId.Meters);\n    Level.Create(doc, elevation).Name = levelName;\n    TaskDialog.Show(\"Éxito\", $\"El nivel '{levelName}' fue creado.\");\n}\nelse\n{\n    TaskDialog.Show(\"Advertencia\", $\"El nivel '{levelName}' ya existe.\");\n}"}
{"prompt":"Create a new Level named 'Level 4' at an elevation of 12 meters.","completion":"string levelName = \"Level 4\";\nif (!new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == levelName))\n{\n    double elevation = UnitUtils.ConvertToInternalUnits(12, UnitTypeId.Meters);\n    Level.Create(doc, elevation).Name = levelName;\n    TaskDialog.Show(\"Success\", $\"Level '{levelName}' was created.\");\n}\nelse\n{\n    TaskDialog.Show(\"Warning\", $\"Level '{levelName}' already exists.\");\n}"}
{"prompt":"Inserta una armadura (truss) de 6 metros entre dos puntos.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFamilySymbol trussSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Trusses).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nif (level != null && trussSymbol != null)\n{\n    if(!trussSymbol.IsActive) trussSymbol.Activate();\n    Line trussLine = Line.CreateBound(new XYZ(0, 10, 0), new XYZ(UnitUtils.ConvertToInternalUnits(6, UnitTypeId.Meters), 10, 0));\n    doc.Create.NewFamilyInstance(trussLine, trussSymbol, level, StructuralType.NonStructural);\n}"}
{"prompt":"Insert a 6-meter truss between two points.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFamilySymbol trussSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Trusses).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nif (level != null && trussSymbol != null)\n{\n    if(!trussSymbol.IsActive) trussSymbol.Activate();\n    Line trussLine = Line.CreateBound(new XYZ(0, 10, 0), new XYZ(UnitUtils.ConvertToInternalUnits(6, UnitTypeId.Meters), 10, 0));\n    doc.Create.NewFamilyInstance(trussLine, trussSymbol, level, StructuralType.NonStructural);\n}"}
{"prompt":"Crea una tubería con un diámetro de 150mm.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nPipeType pipeType = new FilteredElementCollector(doc).OfClass(typeof(PipeType)).FirstOrDefault() as PipeType;\nPipingSystemType systemType = new FilteredElementCollector(doc).OfClass(typeof(PipingSystemType)).FirstOrDefault() as PipingSystemType;\nif (level != null && pipeType != null && systemType != null)\n{\n    XYZ p1 = new XYZ(0,0,0);\n    XYZ p2=new XYZ(5,0,0);\n    Pipe pipe = Pipe.Create(doc, systemType.Id, pipeType.Id, level.Id, p1, p2);\n    pipe.get_Parameter(BuiltInParameter.RBS_PIPE_DIAMETER_PARAM).Set(UnitUtils.ConvertToInternalUnits(150, UnitTypeId.Millimeters));\n}"}
{"prompt":"Create a pipe with a 150mm diameter.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nPipeType pipeType = new FilteredElementCollector(doc).OfClass(typeof(PipeType)).FirstOrDefault() as PipeType;\nPipingSystemType systemType = new FilteredElementCollector(doc).OfClass(typeof(PipingSystemType)).FirstOrDefault() as PipingSystemType;\nif (level != null && pipeType != null && systemType != null)\n{\n    XYZ p1 = new XYZ(0,0,0);\n    XYZ p2=new XYZ(5,0,0);\n    Pipe pipe = Pipe.Create(doc, systemType.Id, pipeType.Id, level.Id, p1, p2);\n    pipe.get_Parameter(BuiltInParameter.RBS_PIPE_DIAMETER_PARAM).Set(UnitUtils.ConvertToInternalUnits(150, UnitTypeId.Millimeters));\n}"}
{"prompt":"Añade una etiqueta a la columna más cercana al origen.","completion":"View activeView = doc.ActiveView;\nFamilyInstance column = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsNotElementType().Cast<FamilyInstance>().OrderBy(c => (c.Location as LocationPoint).Point.DistanceTo(XYZ.Zero)).FirstOrDefault();\nif (column != null && activeView != null)\n{\n    LocationPoint loc = column.Location as LocationPoint;\n    if(loc != null) \n    {\n        IndependentTag.Create(doc, activeView.Id, new Reference(column), true, TagMode.TM_ADDBY_CATEGORY, TagOrientation.Horizontal, loc.Point);\n    }\n}"}
{"prompt":"Add a tag to the column closest to the origin.","completion":"View activeView = doc.ActiveView;\nFamilyInstance column = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsNotElementType().Cast<FamilyInstance>().OrderBy(c => (c.Location as LocationPoint).Point.DistanceTo(XYZ.Zero)).FirstOrDefault();\nif (column != null && activeView != null)\n{\n    LocationPoint loc = column.Location as LocationPoint;\n    if(loc != null) \n    {\n        IndependentTag.Create(doc, activeView.Id, new Reference(column), true, TagMode.TM_ADDBY_CATEGORY, TagOrientation.Horizontal, loc.Point);\n    }\n}"}
{"prompt":"Crea una escalera entre Nivel 1 y Nivel 2.","completion":"Level bottomLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().FirstOrDefault(l => l.Name == \"Nivel 1\");\nLevel topLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().FirstOrDefault(l => l.Name == \"Nivel 2\");\nif (bottomLevel != null && topLevel != null)\n{\n    Stairs.Create(doc, bottomLevel.Id, topLevel.Id);\n}"}
{"prompt":"Create a stair between Level 1 and Level 2.","completion":"Level bottomLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().FirstOrDefault(l => l.Name == \"Level 1\");\nLevel topLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().FirstOrDefault(l => l.Name == \"Level 2\");\nif (bottomLevel != null && topLevel != null)\n{\n    Stairs.Create(doc, bottomLevel.Id, topLevel.Id);\n}"}
{"prompt":"Modela un barandal en una escalera existente.","completion":"RailingType railingType = new FilteredElementCollector(doc).OfClass(typeof(RailingType)).FirstOrDefault() as RailingType;\nStairs stairs = new FilteredElementCollector(doc).OfClass(typeof(Stairs)).FirstOrDefault() as Stairs;\nif (railingType != null && stairs != null)\n{\n    Railing.Create(doc, stairs.Id, railingType.Id, RailingPlacementPosition.Treads);\n}"}
{"prompt":"Model a railing on an existing staircase.","completion":"RailingType railingType = new FilteredElementCollector(doc).OfClass(typeof(RailingType)).FirstOrDefault() as RailingType;\nStairs stairs = new FilteredElementCollector(doc).OfClass(typeof(Stairs)).FirstOrDefault() as Stairs;\nif (railingType != null && stairs != null)\n{\n    Railing.Create(doc, stairs.Id, railingType.Id, RailingPlacementPosition.Treads);\n}"}
{"prompt":"Coloca un mueble en las coordenadas (2,3).","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFamilySymbol furnitureSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Furniture).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nif (level != null && furnitureSymbol != null)\n{\n    if (!furnitureSymbol.IsActive) furnitureSymbol.Activate();\n    doc.Create.NewFamilyInstance(new XYZ(UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0), furnitureSymbol, level, StructuralType.NonStructural);\n}"}
{"prompt":"Place a piece of furniture at coordinates (2,3).","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFamilySymbol furnitureSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Furniture).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nif (level != null && furnitureSymbol != null)\n{\n    if (!furnitureSymbol.IsActive) furnitureSymbol.Activate();\n    doc.Create.NewFamilyInstance(new XYZ(UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0), furnitureSymbol, level, StructuralType.NonStructural);\n}"}
{"prompt":"Crea una cimentación de viga de 8 metros de largo.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFamilySymbol foundationSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFoundation).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nif (level != null && foundationSymbol != null)\n{\n    if(!foundationSymbol.IsActive) foundationSymbol.Activate();\n    Line line = Line.CreateBound(new XYZ(0,0,0), new XYZ(UnitUtils.ConvertToInternalUnits(8, UnitTypeId.Meters), 0, 0));\n    doc.Create.NewFamilyInstance(line, foundationSymbol, level, StructuralType.Footing);\n}"}
{"prompt":"Create an 8-meter long foundation beam.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFamilySymbol foundationSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFoundation).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nif (level != null && foundationSymbol != null)\n{\n    if(!foundationSymbol.IsActive) foundationSymbol.Activate();\n    Line line = Line.CreateBound(new XYZ(0,0,0), new XYZ(UnitUtils.ConvertToInternalUnits(8, UnitTypeId.Meters), 0, 0));\n    doc.Create.NewFamilyInstance(line, foundationSymbol, level, StructuralType.Footing);\n}"}
{"prompt":"Añade refuerzo a una columna.","completion":"RebarBarType barType = new FilteredElementCollector(doc).OfClass(typeof(RebarBarType)).FirstOrDefault() as RebarBarType;\nRebarShape shape = new FilteredElementCollector(doc).OfClass(typeof(RebarShape)).FirstOrDefault() as RebarShape;\nFamilyInstance column = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsNotElementType().FirstOrDefault() as FamilyInstance;\nif(barType != null && shape != null && column != null)\n{\n    // Note: A specific stirrup/tie shape and hook types would be needed for a real-world scenario.\n    Rebar.CreateFromRebarShape(doc, shape, barType, column, column.GetTransform().Origin, XYZ.BasisX, XYZ.BasisY);\n}"}
{"prompt":"Add reinforcement to a column.","completion":"RebarBarType barType = new FilteredElementCollector(doc).OfClass(typeof(RebarBarType)).FirstOrDefault() as RebarBarType;\nRebarShape shape = new FilteredElementCollector(doc).OfClass(typeof(RebarShape)).FirstOrDefault() as RebarShape;\nFamilyInstance column = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsNotElementType().FirstOrDefault() as FamilyInstance;\nif(barType != null && shape != null && column != null)\n{\n    // Note: A specific stirrup/tie shape and hook types would be needed for a real-world scenario.\n    Rebar.CreateFromRebarShape(doc, shape, barType, column, column.GetTransform().Origin, XYZ.BasisX, XYZ.BasisY);\n}"}
{"prompt":"Fija el elemento seleccionado para que no se mueva.","completion":"UIDocument uidoc = new UIDocument(doc);\nIList<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif (selectedIds.Count > 0)\n{\n    ElementId selectedId = selectedIds.FirstOrDefault();\n    if (selectedId != null && selectedId != ElementId.InvalidElementId)\n    {\n        Element elementToPin = doc.GetElement(selectedId);\n        if (elementToPin != null && !elementToPin.Pinned) \n        {\n             elementToPin.Pinned = true;\n             TaskDialog.Show(\"Éxito\", \"Elemento fijado.\");\n        }\n    }\n}"}
{"prompt":"Pin the selected element so it cannot be moved.","completion":"UIDocument uidoc = new UIDocument(doc);\nIList<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif (selectedIds.Count > 0)\n{\n    ElementId selectedId = selectedIds.FirstOrDefault();\n    if (selectedId != null && selectedId != ElementId.InvalidElementId)\n    {\n        Element elementToPin = doc.GetElement(selectedId);\n        if (elementToPin != null && !elementToPin.Pinned) \n        {\n             elementToPin.Pinned = true;\n             TaskDialog.Show(\"Success\", \"Element pinned.\");\n        }\n    }\n}"}
{"prompt":"Crea un conducto eléctrico de 1 pulgada de diámetro.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nElementId conduitTypeId = Conduit.GetDefaultConduitTypeId(doc);\nif (level != null && conduitTypeId != ElementId.InvalidElementId)\n{\n    XYZ start = new XYZ(0,0,3);\n    XYZ end = new XYZ(5,0,3);\n    Conduit conduit = Conduit.Create(doc, conduitTypeId, start, end, level.Id);\n    conduit.get_Parameter(BuiltInParameter.RBS_CONDUIT_DIAMETER_PARAM).Set(UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Inches));\n}"}
{"prompt":"Create an electrical conduit with a 1-inch diameter.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nElementId conduitTypeId = Conduit.GetDefaultConduitTypeId(doc);\nif (level != null && conduitTypeId != ElementId.InvalidElementId)\n{\n    XYZ start = new XYZ(0,0,3);\n    XYZ end = new XYZ(5,0,3);\n    Conduit conduit = Conduit.Create(doc, conduitTypeId, start, end, level.Id);\n    conduit.get_Parameter(BuiltInParameter.RBS_CONDUIT_DIAMETER_PARAM).Set(UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Inches));\n}"}

{"prompt":"Genera un equipo eléctrico en X=1,Y=1.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFamilySymbol panelSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_ElectricalEquipment).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nif (level != null && panelSymbol != null)\n{\n    if(!panelSymbol.IsActive) panelSymbol.Activate();\n    XYZ point = new XYZ(UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters), 0);\n    doc.Create.NewFamilyInstance(point, panelSymbol, level, StructuralType.NonStructural);\n}"}
{"prompt":"Generate an electrical panel at X=1,Y=1.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFamilySymbol panelSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_ElectricalEquipment).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nif (level != null && panelSymbol != null)\n{\n    if(!panelSymbol.IsActive) panelSymbol.Activate();\n    XYZ point = new XYZ(UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters), 0);\n    doc.Create.NewFamilyInstance(point, panelSymbol, level, StructuralType.NonStructural);\n}"}
{"prompt":"Crea un nuevo nivel 'Nivel 3' a una elevación de 12 metros.","completion":"string levelName = \"Nivel 3\";\nif (!new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == levelName))\n{\n    double elevation = UnitUtils.ConvertToInternalUnits(12, UnitTypeId.Meters);\n    Level.Create(doc, elevation).Name = levelName;\n    TaskDialog.Show(\"Éxito\", $\"El nivel '{levelName}' fue creado.\");\n}\nelse\n{\n    TaskDialog.Show(\"Advertencia\", $\"El nivel '{levelName}' ya existe.\");\n}"}
{"prompt":"Create a new level 'Level 3' at an elevation of 12 meters.","completion":"string levelName = \"Level 3\";\nif (!new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == levelName))\n{\n    double elevation = UnitUtils.ConvertToInternalUnits(12, UnitTypeId.Meters);\n    Level.Create(doc, elevation).Name = levelName;\n    TaskDialog.Show(\"Success\", $\"Level '{levelName}' was created.\");\n}\nelse\n{\n    TaskDialog.Show(\"Warning\", $\"Level '{levelName}' already exists.\");\n}"}
{"prompt":"Añade un nivel llamado 'Nivel Azotea' a 15.5 metros.","completion":"string levelName = \"Nivel Azotea\";\nif (!new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == levelName))\n{\n    double elevation = UnitUtils.ConvertToInternalUnits(15.5, UnitTypeId.Meters);\n    Level.Create(doc, elevation).Name = levelName;\n    TaskDialog.Show(\"Éxito\", $\"El nivel '{levelName}' fue creado.\");\n}\nelse\n{\n    TaskDialog.Show(\"Advertencia\", $\"El nivel '{levelName}' ya existe.\");\n}"}
{"prompt":"Crea un muro en el Nivel 1 que vaya de (0,0,0) a (10,0,0) con una altura de 4 metros.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nWallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\nif (level1 != null && wallType != null)\n{\n    XYZ p1 = new XYZ(0, 0, 0);\n    XYZ p2 = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0, 0);\n    Line wallCurve = Line.CreateBound(p1, p2);\n    double height = UnitUtils.ConvertToInternalUnits(4, UnitTypeId.Meters);\n    Wall.Create(doc, wallCurve, wallType.Id, level1.Id, height, 0.0, false, false);\n}"}
{"prompt":"Create a wall on Level 1 from (0,0,0) to (10,0,0) with a height of 4 meters.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nWallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\nif (level1 != null && wallType != null)\n{\n    XYZ p1 = new XYZ(0, 0, 0);\n    XYZ p2 = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0, 0);\n    Line wallCurve = Line.CreateBound(p1, p2);\n    double height = UnitUtils.ConvertToInternalUnits(4, UnitTypeId.Meters);\n    Wall.Create(doc, wallCurve, wallType.Id, level1.Id, height, 0.0, false, false);\n}"}
{"prompt":"Dibuja un conducto de ventilación rectangular de 300x200 milímetros.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nDuctType ductType = new FilteredElementCollector(doc).OfClass(typeof(DuctType)).FirstOrDefault(d=>d.Shape==ConnectorProfileType.Rectangular) as DuctType;\nMEPSystemType systemType = new FilteredElementCollector(doc).OfClass(typeof(MEPSystemType)).Cast<MEPSystemType>().FirstOrDefault(s=>s.SystemClassification==MEPSystemClassification.SupplyAir);\nif (level != null && ductType != null && systemType != null)\n{\n    XYZ p1 = new XYZ(0,0,3); XYZ p2 = new XYZ(10,0,3);\n    Duct duct = Duct.Create(doc, systemType.Id, ductType.Id, level.Id, p1, p2);\n    duct.get_Parameter(BuiltInParameter.RBS_CURVE_WIDTH_PARAM).Set(UnitUtils.ConvertToInternalUnits(300, UnitTypeId.Millimeters));\n    duct.get_Parameter(BuiltInParameter.RBS_CURVE_HEIGHT_PARAM).Set(UnitUtils.ConvertToInternalUnits(200, UnitTypeId.Millimeters));\n}"}
{"prompt":"Draw a 300x200 millimeter rectangular ventilation duct.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nDuctType ductType = new FilteredElementCollector(doc).OfClass(typeof(DuctType)).FirstOrDefault(d=>d.Shape==ConnectorProfileType.Rectangular) as DuctType;\nMEPSystemType systemType = new FilteredElementCollector(doc).OfClass(typeof(MEPSystemType)).Cast<MEPSystemType>().FirstOrDefault(s=>s.SystemClassification==MEPSystemClassification.SupplyAir);\nif (level != null && ductType != null && systemType != null)\n{\n    XYZ p1 = new XYZ(0,0,3); XYZ p2 = new XYZ(10,0,3);\n    Duct duct = Duct.Create(doc, systemType.Id, ductType.Id, level.Id, p1, p2);\n    duct.get_Parameter(BuiltInParameter.RBS_CURVE_WIDTH_PARAM).Set(UnitUtils.ConvertToInternalUnits(300, UnitTypeId.Millimeters));\n    duct.get_Parameter(BuiltInParameter.RBS_CURVE_HEIGHT_PARAM).Set(UnitUtils.ConvertToInternalUnits(200, UnitTypeId.Millimeters));\n}"}
{"prompt":"Coloca un terminal de aire en el extremo de un conducto.","completion":"FamilySymbol terminalSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_DuctTerminal).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nDuct duct = new FilteredElementCollector(doc).OfClass(typeof(Duct)).FirstOrDefault() as Duct;\nif (terminalSymbol != null && duct != null)\n{\n    if(!terminalSymbol.IsActive) terminalSymbol.Activate();\n    Connector connector = duct.ConnectorManager.UnusedConnectors.Cast<Connector>().FirstOrDefault();\n    if (connector != null) \n    {\n        doc.Create.NewFamilyInstance(connector, terminalSymbol);\n        TaskDialog.Show(\"Éxito\", \"Terminal de aire colocado.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontraron conectores libres en el conducto.\");\n    }\n}"}
{"prompt":"Place an air terminal at the end of a duct.","completion":"FamilySymbol terminalSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_DuctTerminal).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nDuct duct = new FilteredElementCollector(doc).OfClass(typeof(Duct)).FirstOrDefault() as Duct;\nif (terminalSymbol != null && duct != null)\n{\n    if(!terminalSymbol.IsActive) terminalSymbol.Activate();\n    Connector connector = duct.ConnectorManager.UnusedConnectors.Cast<Connector>().FirstOrDefault();\n    if (connector != null) \n    {\n        doc.Create.NewFamilyInstance(connector, terminalSymbol);\n        TaskDialog.Show(\"Success\", \"Air terminal placed.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No unused connectors found on the duct.\");\n    }\n}"}
{"prompt":"Importa una topografía desde un archivo CSV.","completion":"string filePath = \"C:/Rutas/Comunes/terreno.csv\";\nif(System.IO.File.Exists(filePath))\n{\n    TopographySurface.Create(doc, filePath, new CSVImportOptions());\n    TaskDialog.Show(\"Éxito\", $\"Topografía importada desde {filePath}\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"El archivo no existe en la ruta: {filePath}\");\n}"}
{"prompt":"Import a topography from a CSV file.","completion":"string filePath = \"C:/Common/Paths/terrain.csv\";\nif(System.IO.File.Exists(filePath))\n{\n    TopographySurface.Create(doc, filePath, new CSVImportOptions());\n    TaskDialog.Show(\"Success\", $\"Topography imported from {filePath}\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"File not found at: {filePath}\");\n}"}
{"prompt":"Exporta el modelo actual a un archivo NWC.","completion":"string folderPath = \"C:/exports/\";\nstring fileName = doc.Title + \".nwc\";\nif(System.IO.Directory.Exists(folderPath))\n{\n    NavisworksExportOptions options = new NavisworksExportOptions();\n    options.ExportScope = NavisworksExportScope.Model;\n    doc.Export(folderPath, fileName, options);\n    TaskDialog.Show(\"Éxito\", $\"Modelo exportado a {folderPath}{fileName}\");\n}\nelse\n{\n     TaskDialog.Show(\"Error\", $\"La carpeta de destino no existe: {folderPath}\");\n}"}
{"prompt":"Export the current model to an NWC file.","completion":"string folderPath = \"C:/exports/\";\nstring fileName = doc.Title + \".nwc\";\nif(System.IO.Directory.Exists(folderPath))\n{\n    NavisworksExportOptions options = new NavisworksExportOptions();\n    options.ExportScope = NavisworksExportScope.Model;\n    doc.Export(folderPath, fileName, options);\n    TaskDialog.Show(\"Success\", $\"Model exported to {folderPath}{fileName}\");\n}\nelse\n{\n     TaskDialog.Show(\"Error\", $\"Destination folder not found: {folderPath}\");\n}"}
{"prompt":"Rellena el parámetro de material de todos los muros con 'Concreto'.","completion":"Material concreteMaterial = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name.Contains(\"Concreto\")) as Material;\nif (concreteMaterial != null)\n{\n    var walls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().Cast<Wall>().ToList();\n    int changedCount = 0;\n    foreach(Wall w in walls)\n    {\n        Parameter materialParam = w.get_Parameter(BuiltInParameter.STRUCTURAL_MATERIAL_PARAM);\n        if(materialParam != null && !materialParam.IsReadOnly) \n        {\n             materialParam.Set(concreteMaterial.Id);\n             changedCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{changedCount} muros actualizados al material '{concreteMaterial.Name}'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró un material que contenga 'Concreto'.\");\n}"}
{"prompt":"Fill the material parameter of all walls with 'Concrete'.","completion":"Material concreteMaterial = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name.Contains(\"Concrete\")) as Material;\nif (concreteMaterial != null)\n{\n    var walls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().Cast<Wall>().ToList();\n    int changedCount = 0;\n    foreach(Wall w in walls)\n    {\n        Parameter materialParam = w.get_Parameter(BuiltInParameter.STRUCTURAL_MATERIAL_PARAM);\n        if(materialParam != null && !materialParam.IsReadOnly) \n        {\n             materialParam.Set(concreteMaterial.Id);\n             changedCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{changedCount} walls updated to material '{concreteMaterial.Name}'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Material containing 'Concrete' not found.\");\n}"}
{"prompt":"Crea un nuevo tipo de muro de 25cm llamado 'Muro Estructural 25cm'.","completion":"string newTypeName = \"Muro Estructural 25cm\";\nif (new FilteredElementCollector(doc).OfClass(typeof(WallType)).Any(wt => wt.Name == newTypeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de muro '{newTypeName}' ya existe.\");\n}\nelse\n{\n    WallType wallTypeToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\n    if (wallTypeToDuplicate != null)\n    {\n        WallType newWallType = wallTypeToDuplicate.Duplicate(newTypeName) as WallType;\n        CompoundStructure cs = newWallType.GetCompoundStructure();\n        if(cs != null && cs.GetLayerCount() > 0)\n        {\n            int coreLayerIndex = cs.GetFirstCoreLayerIndex();\n            cs.SetLayerFunction(coreLayerIndex, MaterialFunctionAssignment.Structure);\n            cs.SetLayerWidth(coreLayerIndex, UnitUtils.ConvertToInternalUnits(0.25, UnitTypeId.Meters));\n            newWallType.SetCompoundStructure(cs);\n            TaskDialog.Show(\"Éxito\", $\"Tipo de muro '{newTypeName}' creado.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontraron tipos de muro para duplicar.\");\n    }\n}"}
{"prompt":"Create a new 25cm wall type named 'Structural Wall 25cm'.","completion":"string newTypeName = \"Structural Wall 25cm\";\nif (new FilteredElementCollector(doc).OfClass(typeof(WallType)).Any(wt => wt.Name == newTypeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Wall type '{newTypeName}' already exists.\");\n}\nelse\n{\n    WallType wallTypeToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\n    if (wallTypeToDuplicate != null)\n    {\n        WallType newWallType = wallTypeToDuplicate.Duplicate(newTypeName) as WallType;\n        CompoundStructure cs = newWallType.GetCompoundStructure();\n        if(cs != null && cs.GetLayerCount() > 0)\n        {\n            int coreLayerIndex = cs.GetFirstCoreLayerIndex();\n            cs.SetLayerFunction(coreLayerIndex, MaterialFunctionAssignment.Structure);\n            cs.SetLayerWidth(coreLayerIndex, UnitUtils.ConvertToInternalUnits(0.25, UnitTypeId.Meters));\n            newWallType.SetCompoundStructure(cs);\n            TaskDialog.Show(\"Success\", $\"Wall type '{newTypeName}' created.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No wall types found to duplicate.\");\n    }\n}"}
{"prompt":"Carga la familia 'Mesa.rfa' y colócala en (5,5,0) en el Nivel 1.","completion":"string familyPath = \"C:/Rutas/Comunes/Mesa.rfa\";\nif(!System.IO.File.Exists(familyPath))\n{\n    TaskDialog.Show(\"Error\", $\"No se encuentra el archivo de familia en: {familyPath}\");\n}\nelse\n{\n    Family deskFamily;\n    if(doc.LoadFamily(familyPath, out deskFamily))\n    {\n        FamilySymbol deskSymbol = doc.GetElement(deskFamily.GetFamilySymbolIds().First()) as FamilySymbol;\n        Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\n        if (deskSymbol != null && level1 != null)\n        {\n            if (!deskSymbol.IsActive) deskSymbol.Activate();\n            XYZ point = new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0);\n            doc.Create.NewFamilyInstance(point, deskSymbol, level1, StructuralType.NonStructural);\n            TaskDialog.Show(\"Éxito\", $\"Familia '{deskFamily.Name}' cargada y colocada.\");\n        }\n        else\n        {\n            TaskDialog.Show(\"Error\", \"No se encontró el Nivel 1 para colocar la familia.\");\n        }\n    }\n}"}
{"prompt":"Load the 'Table.rfa' family and place it at (5,5,0) on Level 1.","completion":"string familyPath = \"C:/Common/Paths/Table.rfa\";\nif(!System.IO.File.Exists(familyPath))\n{\n    TaskDialog.Show(\"Error\", $\"Family file not found at: {familyPath}\");\n}\nelse\n{\n    Family tableFamily;\n    if(doc.LoadFamily(familyPath, out tableFamily))\n    {\n        FamilySymbol tableSymbol = doc.GetElement(tableFamily.GetFamilySymbolIds().First()) as FamilySymbol;\n        Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\n        if (tableSymbol != null && level1 != null)\n        {\n            if (!tableSymbol.IsActive) tableSymbol.Activate();\n            XYZ point = new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0);\n            doc.Create.NewFamilyInstance(point, tableSymbol, level1, StructuralType.NonStructural);\n            TaskDialog.Show(\"Success\", $\"Family '{tableFamily.Name}' loaded and placed.\");\n        }\n        else\n        {\n            TaskDialog.Show(\"Error\", \"Level 1 not found to place the family.\");\n        }\n    }\n}"}
{"prompt":"Modela un plafón a 2.8 metros de altura en Nivel 1.","completion":"CeilingType ceilingType = new FilteredElementCollector(doc).OfClass(typeof(CeilingType)).FirstOrDefault() as CeilingType;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nif(ceilingType != null && level != null)\n{\n    CurveLoop profile = new CurveLoop();\n    profile.Append(Line.CreateBound(new XYZ(0,0,0), new XYZ(10,0,0)));\n    profile.Append(Line.CreateBound(new XYZ(10,0,0), new XYZ(10,10,0)));\n    profile.Append(Line.CreateBound(new XYZ(10,10,0), new XYZ(0,10,0)));\n    profile.Append(Line.CreateBound(new XYZ(0,10,0), new XYZ(0,0,0)));\n    Ceiling ceiling = Ceiling.Create(doc, new List<CurveLoop>{profile}, ceilingType.Id, level.Id);\n    Parameter heightParam = ceiling.get_Parameter(BuiltInParameter.CEILING_HEIGHTABOVELEVEL_PARAM);\n    if(heightParam != null && !heightParam.IsReadOnly) heightParam.Set(UnitUtils.ConvertToInternalUnits(2.8, UnitTypeId.Meters));\n}"}
{"prompt":"Model a ceiling at a height of 2.8 meters on Level 1.","completion":"CeilingType ceilingType = new FilteredElementCollector(doc).OfClass(typeof(CeilingType)).FirstOrDefault() as CeilingType;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nif(ceilingType != null && level != null)\n{\n    CurveLoop profile = new CurveLoop();\n    profile.Append(Line.CreateBound(new XYZ(0,0,0), new XYZ(10,0,0)));\n    profile.Append(Line.CreateBound(new XYZ(10,0,0), new XYZ(10,10,0)));\n    profile.Append(Line.CreateBound(new XYZ(10,10,0), new XYZ(0,10,0)));\n    profile.Append(Line.CreateBound(new XYZ(0,10,0), new XYZ(0,0,0)));\n    Ceiling ceiling = Ceiling.Create(doc, new List<CurveLoop>{profile}, ceilingType.Id, level.Id);\n    Parameter heightParam = ceiling.get_Parameter(BuiltInParameter.CEILING_HEIGHTABOVELEVEL_PARAM);\n    if(heightParam != null && !heightParam.IsReadOnly) heightParam.Set(UnitUtils.ConvertToInternalUnits(2.8, UnitTypeId.Meters));\n}"}
{"prompt":"Crea una nueva habitación en el Nivel 1 en el punto (10, 10).","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nif (level1 != null)\n{\n    UV point = new UV(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters));\n    Room room = doc.Create.NewRoom(level1, point);\n    if(room != null) TaskDialog.Show(\"Éxito\", $\"Habitación creada en {level1.Name}\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el 'Nivel 1'.\");\n}"}
{"prompt":"Create a new room on Level 1 at point (10, 10).","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nif (level1 != null)\n{\n    UV point = new UV(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters));\n    Room room = doc.Create.NewRoom(level1, point);\n    if(room != null) TaskDialog.Show(\"Success\", $\"Room created on {level1.Name}\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Level 1' not found.\");\n}"}
{"prompt":"Crea un techo por contorno en el 'Nivel de Cubierta'.","completion":"Level roofLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel de Cubierta\") as Level;\nRoofType roofType = new FilteredElementCollector(doc).OfClass(typeof(RoofType)).FirstOrDefault() as RoofType;\nif(roofLevel != null && roofType != null)\n{\n    CurveLoop roofProfile = new CurveLoop();\n    roofProfile.Append(Line.CreateBound(new XYZ(0,0,0), new XYZ(20,0,0)));\n    roofProfile.Append(Line.CreateBound(new XYZ(20,0,0), new XYZ(20,30,0)));\n    roofProfile.Append(Line.CreateBound(new XYZ(20,30,0), new XYZ(0,30,0)));\n    roofProfile.Append(Line.CreateBound(new XYZ(0,30,0), new XYZ(0,0,0)));\n    ModelCurveArray mapping = new ModelCurveArray();\n    doc.Create.NewFootPrintRoof(roofProfile, roofLevel, roofType, out mapping);\n}"}
{"prompt":"Create a roof by footprint on the 'Roof Level'.","completion":"Level roofLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Roof Level\") as Level;\nRoofType roofType = new FilteredElementCollector(doc).OfClass(typeof(RoofType)).FirstOrDefault() as RoofType;\nif(roofLevel != null && roofType != null)\n{\n    CurveLoop roofProfile = new CurveLoop();\n    roofProfile.Append(Line.CreateBound(new XYZ(0,0,0), new XYZ(20,0,0)));\n    roofProfile.Append(Line.CreateBound(new XYZ(20,0,0), new XYZ(20,30,0)));\n    roofProfile.Append(Line.CreateBound(new XYZ(20,30,0), new XYZ(0,30,0)));\n    roofProfile.Append(Line.CreateBound(new XYZ(0,30,0), new XYZ(0,0,0)));\n    ModelCurveArray mapping = new ModelCurveArray();\n    doc.Create.NewFootPrintRoof(roofProfile, roofLevel, roofType, out mapping);\n}"}
{"prompt":"Elimina todas las líneas de detalle en la vista activa.","completion":"ICollection<ElementId> detailLines = new FilteredElementCollector(doc, doc.ActiveView.Id).OfClass(typeof(DetailLine)).ToElementIds();\nif(detailLines.Count > 0)\n{\n    int count = detailLines.Count;\n    doc.Delete(detailLines);\n    TaskDialog.Show(\"Resultado\", $\"{count} líneas de detalle eliminadas.\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No se encontraron líneas de detalle para eliminar.\");\n}"}
{"prompt":"Delete all detail lines in the active view.","completion":"ICollection<ElementId> detailLines = new FilteredElementCollector(doc, doc.ActiveView.Id).OfClass(typeof(DetailLine)).ToElementIds();\nif(detailLines.Count > 0)\n{\n    int count = detailLines.Count;\n    doc.Delete(detailLines);\n    TaskDialog.Show(\"Result\", $\"{count} detail lines were deleted.\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No detail lines found to delete.\");\n}"}
{"prompt":"Une la geometría de una columna y un suelo que se cruzan.","completion":"Element column = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsNotElementType().FirstOrDefault();\nElement floor = new FilteredElementCollector(doc).OfClass(typeof(Floor)).FirstOrDefault();\nif(column != null && floor != null)\n{\n    if(!JoinGeometryUtils.AreElementsJoined(doc, column, floor))\n    {\n        JoinGeometryUtils.JoinGeometry(doc, column, floor);\n        TaskDialog.Show(\"Éxito\", \"Geometría unida.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", \"Los elementos ya estaban unidos.\");\n    }\n}"}
{"prompt":"Join the geometry of an intersecting column and floor.","completion":"Element column = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsNotElementType().FirstOrDefault();\nElement floor = new FilteredElementCollector(doc).OfClass(typeof(Floor)).FirstOrDefault();\nif(column != null && floor != null)\n{\n    if(!JoinGeometryUtils.AreElementsJoined(doc, column, floor))\n    {\n        JoinGeometryUtils.JoinGeometry(doc, column, floor);\n        TaskDialog.Show(\"Success\", \"Geometry joined.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", \"The elements were already joined.\");\n    }\n}"}
{"prompt":"Rota el norte del proyecto 30 grados en sentido horario.","completion":"BasePoint projectBasePoint = new FilteredElementCollector(doc).OfClass(typeof(BasePoint)).Cast<BasePoint>().FirstOrDefault(bp => !bp.IsSurveyPoint);\nif (projectBasePoint != null)\n{\n    double angleInDegrees = 30.0;\n    double angleInRadians = -(angleInDegrees * Math.PI / 180.0); // Negativo para sentido horario\n    Line axis = Line.CreateBound(projectBasePoint.Position, projectBasePoint.Position + XYZ.BasisZ);\n    ElementTransformUtils.RotateElement(doc, projectBasePoint.Id, axis, angleInRadians);\n    TaskDialog.Show(\"Éxito\", $\"Norte del proyecto rotado {angleInDegrees} grados en sentido horario.\");\n}"}
{"prompt":"Rotate project north 30 degrees clockwise.","completion":"BasePoint projectBasePoint = new FilteredElementCollector(doc).OfClass(typeof(BasePoint)).Cast<BasePoint>().FirstOrDefault(bp => !bp.IsSurveyPoint);\nif (projectBasePoint != null)\n{\n    double angleInDegrees = 30.0;\n    double angleInRadians = -(angleInDegrees * Math.PI / 180.0); // Negative for clockwise\n    Line axis = Line.CreateBound(projectBasePoint.Position, projectBasePoint.Position + XYZ.BasisZ);\n    ElementTransformUtils.RotateElement(doc, projectBasePoint.Id, axis, angleInRadians);\n    TaskDialog.Show(\"Success\", $\"Project North rotated {angleInDegrees} degrees clockwise.\");\n}"}
{"prompt":"Pinta la cara interior de los muros exteriores con 'Pintura Blanca'.","completion":"Material paintMaterial = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name == \"Pintura Blanca\") as Material;\nif (paintMaterial != null)\n{\n    var exteriorWalls = new FilteredElementCollector(doc).OfClass(typeof(Wall)).Cast<Wall>().Where(w => w.WallType.Function == WallFunction.Exterior).ToList();\n    int paintedCount = 0;\n    foreach (Wall w in exteriorWalls)\n    {\n        Face interiorFace = HostObjectUtils.GetSideFaces(w, ShellLayerType.Interior).FirstOrDefault();\n        if (interiorFace != null)\n        {\n            doc.Paint(w.Id, interiorFace, paintMaterial.Id);\n            paintedCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{paintedCount} caras interiores de muros exteriores pintadas.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el material 'Pintura Blanca'.\");\n}"}
{"prompt":"Paint the interior face of exterior walls with 'White Paint'.","completion":"Material paintMaterial = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name == \"White Paint\") as Material;\nif (paintMaterial != null)\n{\n    var exteriorWalls = new FilteredElementCollector(doc).OfClass(typeof(Wall)).Cast<Wall>().Where(w => w.WallType.Function == WallFunction.Exterior).ToList();\n    int paintedCount = 0;\n    foreach (Wall w in exteriorWalls)\n    {\n        Face interiorFace = HostObjectUtils.GetSideFaces(w, ShellLayerType.Interior).FirstOrDefault();\n        if (interiorFace != null)\n        {\n            doc.Paint(w.Id, interiorFace, paintMaterial.Id);\n            paintedCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{paintedCount} interior faces of exterior walls painted.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Material 'White Paint' not found.\");\n}"}
{"prompt":"Obtén el elemento anfitrión de la primera ventana que encuentres.","completion":"FamilyInstance windowInstance = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().FirstOrDefault() as FamilyInstance;\nif (windowInstance != null)\n{\n    Element hostElement = windowInstance.Host;\n    if(hostElement != null)\n    {\n        TaskDialog.Show(\"Anfitrión Encontrado\", $\"El anfitrión de la ventana (ID: {windowInstance.Id}) es: {hostElement.Name} (ID: {hostElement.Id})\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", \"La ventana encontrada no tiene un anfitrión (es posible si es un objeto de modelo in-place).\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No se encontraron ventanas en el proyecto.\");\n}"}
{"prompt":"Get the host element of the first window found.","completion":"FamilyInstance windowInstance = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().FirstOrDefault() as FamilyInstance;\nif (windowInstance != null)\n{\n    Element hostElement = windowInstance.Host;\n    if(hostElement != null)\n    {\n        TaskDialog.Show(\"Host Found\", $\"The host of the window (ID: {windowInstance.Id}) is: {hostElement.Name} (ID: {hostElement.Id})\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", \"The found window does not have a host (e.g., an in-place model object).\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No windows were found in the project.\");\n}"}
{"prompt":"Calcula la longitud total de todos los ductos de Suministro de Aire.","completion":"List<Duct> ducts = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_DuctCurves).WhereElementIsNotElementType().Cast<Duct>().Where(d => d.get_Parameter(BuiltInParameter.RBS_SYSTEM_CLASSIFICATION_PARAM).AsString() == \"SupplyAir\").ToList();\ndouble totalLength = 0.0;\nforeach (Duct d in ducts)\n{\n    totalLength += d.get_Parameter(BuiltInParameter.CURVE_ELEM_LENGTH).AsDouble();\n}\nTaskDialog.Show(\"Longitud Total\", \"La longitud total de ductos de suministro es: \" + UnitUtils.ConvertFromInternalUnits(totalLength, UnitTypeId.Meters).ToString(\"F2\") + \" m\");"}
{"prompt":"Calculate the total length of all Supply Air ducts.","completion":"List<Duct> ducts = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_DuctCurves).WhereElementIsNotElementType().Cast<Duct>().Where(d => d.get_Parameter(BuiltInParameter.RBS_SYSTEM_CLASSIFICATION_PARAM).AsString() == \"SupplyAir\").ToList();\ndouble totalLength = 0.0;\nforeach (Duct d in ducts)\n{\n    totalLength += d.get_Parameter(BuiltInParameter.CURVE_ELEM_LENGTH).AsDouble();\n}\nTaskDialog.Show(\"Total Length\", \"The total length of supply ducts is: \" + UnitUtils.ConvertFromInternalUnits(totalLength, UnitTypeId.Meters).ToString(\"F2\") + \" m\");"}
{"prompt":"Añade una línea de rejilla horizontal a un muro cortina a 1.5 metros de altura.","completion":"Wall cw = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.CurtainGrid != null) as Wall;\nif (cw != null)\n{\n    CurtainGrid cg = cw.CurtainGrid;\n    cg.AddGridLine(false, new XYZ(0,0, UnitUtils.ConvertToInternalUnits(1.5, UnitTypeId.Meters)), false);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró ningún muro cortina para añadir la rejilla.\");\n}"}
{"prompt":"Add a horizontal grid line to a curtain wall at a height of 1.5 meters.","completion":"Wall cw = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.CurtainGrid != null) as Wall;\nif (cw != null)\n{\n    CurtainGrid cg = cw.CurtainGrid;\n    cg.AddGridLine(false, new XYZ(0,0, UnitUtils.ConvertToInternalUnits(1.5, UnitTypeId.Meters)), false);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No curtain wall found to add the grid line.\");\n}"}
{"prompt":"Encuentra un muro buscando el valor 'W-01' en su parámetro de Marca.","completion":"string markValue = \"W-01\";\nElementId markParamId = new ElementId(BuiltInParameter.ALL_MODEL_MARK);\nParameterValueProvider pvp = new ParameterValueProvider(markParamId);\nFilterStringRuleEvaluator evaluator = new FilterStringEquals();\nFilterRule rule = new FilterStringRule(pvp, evaluator, markValue, false);\nElementFilter filter = new ElementParameterFilter(rule);\nWall wall = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().WherePasses(filter).FirstOrDefault() as Wall;\nif (wall != null)\n{\n    TaskDialog.Show(\"Muro Encontrado\", $\"Se encontró el muro con Marca '{markValue}'. Su ID es: {wall.Id}\");\n}\nelse\n{\n    TaskDialog.Show(\"No Encontrado\", $\"No se encontró ningún muro con la Marca '{markValue}'.\");\n}"}
{"prompt":"Find a wall by searching for the value 'W-01' in its Mark parameter.","completion":"string markValue = \"W-01\";\nElementId markParamId = new ElementId(BuiltInParameter.ALL_MODEL_MARK);\nParameterValueProvider pvp = new ParameterValueProvider(markParamId);\nFilterStringRuleEvaluator evaluator = new FilterStringEquals();\nFilterRule rule = new FilterStringRule(pvp, evaluator, markValue, false);\nElementFilter filter = new ElementParameterFilter(rule);\nWall wall = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().WherePasses(filter).FirstOrDefault() as Wall;\nif (wall != null)\n{\n    TaskDialog.Show(\"Wall Found\", $\"Found wall with Mark '{markValue}'. Its ID is: {wall.Id}\");\n}\nelse\n{\n    TaskDialog.Show(\"Not Found\", $\"No wall with Mark '{markValue}' was found.\");\n}"}
{"prompt":"Alinea las líneas de centro de dos muros seleccionados por el usuario.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference r1 = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona el primer muro (el que se moverá)\");\nif (r1 == null) return;\nReference r2 = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona el segundo muro (el de referencia)\");\nif (r2 == null) return;\nWall w1 = doc.GetElement(r1) as Wall;\nWall w2 = doc.GetElement(r2) as Wall;\nif (w1 != null && w2 != null)\n{\n    LocationCurve lc1 = w1.Location as LocationCurve;\n    LocationCurve lc2 = w2.Location as LocationCurve;\n    if(lc1 != null && lc2 != null)\n    {\n        doc.Create.NewAlignment(doc.ActiveView, lc1.Curve.Reference, lc2.Curve.Reference);\n    }\n}"}
{"prompt":"Align the centerlines of two user-selected walls.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference r1 = uidoc.Selection.PickObject(ObjectType.Element, \"Select the first wall (the one that will move)\");\nif (r1 == null) return;\nReference r2 = uidoc.Selection.PickObject(ObjectType.Element, \"Select the second wall (the reference)\");\nif (r2 == null) return;\nWall w1 = doc.GetElement(r1) as Wall;\nWall w2 = doc.GetElement(r2) as Wall;\nif (w1 != null && w2 != null)\n{\n    LocationCurve lc1 = w1.Location as LocationCurve;\n    LocationCurve lc2 = w2.Location as LocationCurve;\n    if(lc1 != null && lc2 != null)\n    {\n        doc.Create.NewAlignment(doc.ActiveView, lc1.Curve.Reference, lc2.Curve.Reference);\n    }\n}"}
{"prompt":"Crea una superficie topográfica a partir de una lista de 4 puntos.","completion":"IList<XYZ> points = new List<XYZ>\n{\n    new XYZ(0, 0, 0),\n    new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0, UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters)),\n    new XYZ(0, UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters)),\n    new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters))\n};\nif (points.Count > 2) \n{\n    TopographySurface.Create(doc, points);\n}"}
{"prompt":"Create a topography surface from a list of 4 points.","completion":"IList<XYZ> points = new List<XYZ>\n{\n    new XYZ(0, 0, 0),\n    new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0, UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters)),\n    new XYZ(0, UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters)),\n    new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters))\n};\nif (points.Count > 2) \n{\n    TopographySurface.Create(doc, points);\n}"}
{"prompt":"Calcula el volumen total de las barras de refuerzo de 12mm.","completion":"double totalVolume = 0;\nRebarBarType barType12mm = new FilteredElementCollector(doc).OfClass(typeof(RebarBarType)).Cast<RebarBarType>().FirstOrDefault(bt => bt.BarDiameter == UnitUtils.ConvertToInternalUnits(12, UnitTypeId.Millimeters));\nif (barType12mm != null)\n{\n    var rebars = new FilteredElementCollector(doc).OfClass(typeof(Rebar)).Where(r => (r as Rebar).GetTypeId() == barType12mm.Id).Cast<Rebar>();\n    foreach (Rebar r in rebars)\n    {\n        totalVolume += r.GetVolume();\n    }\n    TaskDialog.Show(\"Volumen Total\", $\"Volumen de barras '{barType12mm.Name}': \" + UnitUtils.ConvertFromInternalUnits(totalVolume, UnitTypeId.CubicMeters).ToString(\"F3\") + \" m³\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No se encontró el tipo de barra de refuerzo de 12mm.\");\n}"}
{"prompt":"Calculate the total volume of 12mm rebar.","completion":"double totalVolume = 0;\nRebarBarType barType12mm = new FilteredElementCollector(doc).OfClass(typeof(RebarBarType)).Cast<RebarBarType>().FirstOrDefault(bt => bt.BarDiameter == UnitUtils.ConvertToInternalUnits(12, UnitTypeId.Millimeters));\nif (barType12mm != null)\n{\n    var rebars = new FilteredElementCollector(doc).OfClass(typeof(Rebar)).Where(r => (r as Rebar).GetTypeId() == barType12mm.Id).Cast<Rebar>();\n    foreach (Rebar r in rebars)\n    {\n        totalVolume += r.GetVolume();\n    }\n    TaskDialog.Show(\"Total Volume\", $\"Volume of '{barType12mm.Name}' bars: \" + UnitUtils.ConvertFromInternalUnits(totalVolume, UnitTypeId.CubicMeters).ToString(\"F3\") + \" m³\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"12mm rebar bar type not found.\");\n}"}
{"prompt":"Cambia el nombre de todas las vistas de planta para que empiecen con 'ARQ_'.","completion":"string prefix = \"ARQ_\";\nList<ViewPlan> planViews = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).Cast<ViewPlan>().Where(v => !v.IsTemplate).ToList();\nint renamedCount = 0;\nforeach(ViewPlan view in planViews)\n{\n    if(!view.Name.StartsWith(prefix))\n    {\n        try\n        {\n            view.Name = prefix + view.Name;\n            renamedCount++;\n        }\n        catch {}\n    }\n}\nTaskDialog.Show(\"Resultado\", $\"{renamedCount} vistas de planta renombradas.\");"}

{"prompt":"Rename all plan views to start with 'ARCH_'.","completion":"string prefix = \"ARCH_\";\nList<ViewPlan> planViews = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).Cast<ViewPlan>().Where(v => !v.IsTemplate).ToList();\nint renamedCount = 0;\nforeach(ViewPlan view in planViews)\n{\n    if(!view.Name.StartsWith(prefix))\n    {\n        try\n        {\n            view.Name = prefix + view.Name;\n            renamedCount++;\n        }\n        catch {}\n    }\n}\nTaskDialog.Show(\"Resultado\", $\"{renamedCount} vistas de planta renombradas con el prefijo '{prefix}'.\");"}
{"prompt":"Añade el prefijo 'PLANTA-' a todas las vistas de plano.","completion":"string prefix = \"PLANTA-\";\nList<ViewPlan> planViews = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).Cast<ViewPlan>().Where(v => !v.IsTemplate).ToList();\nint renamedCount = 0;\nforeach(ViewPlan view in planViews)\n{\n    if(!view.Name.StartsWith(prefix))\n    {\n        try\n        {\n            view.Name = prefix + view.Name;\n            renamedCount++;\n        }\n        catch {}\n    }\n}\nTaskDialog.Show(\"Resultado\", $\"{renamedCount} vistas de planta renombradas con el prefijo '{prefix}'.\");"}
{"prompt":"Crea una copia de la vista activa y nómbrala 'Copia de Trabajo'.","completion":"View activeView = doc.ActiveView;\nstring desiredName = \"Copia de Trabajo\";\nif (new FilteredElementCollector(doc).OfClass(typeof(View)).Any(v => v.Name == desiredName))\n{\n    TaskDialog.Show(\"Error\", $\"Ya existe una vista con el nombre '{desiredName}'.\");\n}\nelse\n{\n    ElementId newViewId = activeView.Duplicate(ViewDuplicateOption.Duplicate);\n    View newView = doc.GetElement(newViewId) as View;\n    if (newView != null) \n    {\n        newView.Name = desiredName;\n        TaskDialog.Show(\"Éxito\", $\"Vista duplicada y renombrada como '{desiredName}'.\");\n    }\n}"}
{"prompt":"Duplicate the active view and name it 'Working Copy'.","completion":"View activeView = doc.ActiveView;\nstring desiredName = \"Working Copy\";\nif (new FilteredElementCollector(doc).OfClass(typeof(View)).Any(v => v.Name == desiredName))\n{\n    TaskDialog.Show(\"Error\", $\"A view named '{desiredName}' already exists.\");\n}\nelse\n{\n    ElementId newViewId = activeView.Duplicate(ViewDuplicateOption.Duplicate);\n    View newView = doc.GetElement(newViewId) as View;\n    if (newView != null) \n    {\n        newView.Name = desiredName;\n        TaskDialog.Show(\"Success\", $\"View duplicated and renamed to '{desiredName}'.\");\n    }\n}"}
{"prompt":"Crea una vista 3D por defecto.","completion":"ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.ThreeDimensional);\nif(vft != null)\n{\n    View3D view3d = View3D.CreateIsometric(doc, vft.Id);\n    TaskDialog.Show(\"Éxito\", $\"Se ha creado la vista 3D: {view3d.Name}\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el tipo de familia de vista 3D.\");\n}"}
{"prompt":"Create a default 3D view.","completion":"ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.ThreeDimensional);\nif(vft != null)\n{\n    View3D view3d = View3D.CreateIsometric(doc, vft.Id);\n    TaskDialog.Show(\"Success\", $\"3D View created: {view3d.Name}\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"3D View Family Type not found.\");\n}"}
{"prompt":"Crea una losa inclinada con una pendiente del 2% sobre un área de 8x6 metros.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\nif (level != null && floorType != null)\n{\n    XYZ p1 = new XYZ(0,0,0);\n    XYZ p2 = new XYZ(UnitUtils.ConvertToInternalUnits(8, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(6, UnitTypeId.Meters), 0);\n    CurveLoop profile = CurveLoop.CreateViaRectangle(p1, p2);\n    Floor slopedSlab = Floor.Create(doc, new List<CurveLoop>{profile}, floorType.Id, level.Id);\n    if (slopedSlab != null)\n    {\n        slopedSlab.get_Parameter(BuiltInParameter.ROOF_SLOPE).Set(0.02);\n    }\n}"}
{"prompt":"Create a sloped slab with a 2% slope over an 8x6 meter area.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\nif (level != null && floorType != null)\n{\n    XYZ p1 = new XYZ(0,0,0);\n    XYZ p2 = new XYZ(UnitUtils.ConvertToInternalUnits(8, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(6, UnitTypeId.Meters), 0);\n    CurveLoop profile = CurveLoop.CreateViaRectangle(p1, p2);\n    Floor slopedSlab = Floor.Create(doc, new List<CurveLoop>{profile}, floorType.Id, level.Id);\n    if (slopedSlab != null)\n    {\n        slopedSlab.get_Parameter(BuiltInParameter.ROOF_SLOPE).Set(0.02);\n    }\n}"}
{"prompt":"Añade un codo de 90 grados entre dos tuberías.","completion":"List<Pipe> pipes = new FilteredElementCollector(doc).OfClass(typeof(Pipe)).Take(2).ToList();\nif (pipes.Count == 2)\n{\n    Connector c1 = pipes[0].ConnectorManager.UnusedConnectors.Cast<Connector>().FirstOrDefault();\n    Connector c2 = pipes[1].ConnectorManager.UnusedConnectors.Cast<Connector>().FirstOrDefault();\n    if (c1 != null && c2 != null) \n    {\n        doc.Create.NewElbowFitting(c1, c2);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontraron conectores libres en una o ambas tuberías.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesitan al menos dos tuberías en el proyecto.\");\n}"}
{"prompt":"Add a 90-degree elbow between two pipes.","completion":"List<Pipe> pipes = new FilteredElementCollector(doc).OfClass(typeof(Pipe)).Take(2).ToList();\nif (pipes.Count == 2)\n{\n    Connector c1 = pipes[0].ConnectorManager.UnusedConnectors.Cast<Connector>().FirstOrDefault();\n    Connector c2 = pipes[1].ConnectorManager.UnusedConnectors.Cast<Connector>().FirstOrDefault();\n    if (c1 != null && c2 != null) \n    {\n        doc.Create.NewElbowFitting(c1, c2);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Could not find unused connectors on one or both pipes.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"At least two pipes are needed in the project.\");\n}"}
{"prompt":"Coloca una cota de elevación en el Nivel 1.","completion":"Level lvl1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nif (lvl1 != null)\n{\n    Reference levelRef = new Reference(lvl1);\n    XYZ origin = new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), lvl1.Elevation);\n    XYZ leaderEnd = origin + new XYZ(2,2,0);\n    doc.Create.NewSpotElevation(doc.ActiveView, levelRef, origin, origin, leaderEnd, true, true);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el 'Nivel 1'.\");\n}"}
{"prompt":"Place a spot elevation on Level 1.","completion":"Level lvl1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nif (lvl1 != null)\n{\n    Reference levelRef = new Reference(lvl1);\n    XYZ origin = new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), lvl1.Elevation);\n    XYZ leaderEnd = origin + new XYZ(2,2,0);\n    doc.Create.NewSpotElevation(doc.ActiveView, levelRef, origin, origin, leaderEnd, true, true);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Level 1' not found.\");\n}"}
{"prompt":"Exporta la vista 3D activa a NWC para Navisworks.","completion":"View3D view3d = doc.ActiveView as View3D;\nif (view3d != null)\n{\n    string folderPath = \"C:/RevitExports/\";\n    string fileName = view3d.Name + \".nwc\";\n    if(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\n    NavisworksExportOptions options = new NavisworksExportOptions();\n    options.ExportScope = NavisworksExportScope.View;\n    options.ViewId = view3d.Id;\n    doc.Export(folderPath, fileName, options);\n    TaskDialog.Show(\"Éxito\", $\"Vista exportada a {folderPath}{fileName}\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"La vista activa no es una vista 3D.\");\n}"}
{"prompt":"Export the current 3D view to NWC for Navisworks.","completion":"View3D view3d = doc.ActiveView as View3D;\nif (view3d != null)\n{\n    string folderPath = \"C:/RevitExports/\";\n    string fileName = view3d.Name + \".nwc\";\n    if(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\n    NavisworksExportOptions options = new NavisworksExportOptions();\n    options.ExportScope = NavisworksExportScope.View;\n    options.ViewId = view3d.Id;\n    doc.Export(folderPath, fileName, options);\n    TaskDialog.Show(\"Success\", $\"View exported to {folderPath}{fileName}\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"The active view is not a 3D view.\");\n}"}
{"prompt":"Aplica refuerzo a una viga con estribos espaciados cada 30 cm.","completion":"RebarBarType stirrupType = new FilteredElementCollector(doc).OfClass(typeof(RebarBarType)).FirstOrDefault() as RebarBarType;\nRebarShape shape = new FilteredElementCollector(doc).OfClass(typeof(RebarShape)).FirstOrDefault(s => s.RebarStyle == RebarStyle.StirrupTie) as RebarShape;\nFamilyInstance beam = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsNotElementType().FirstOrDefault() as FamilyInstance;\nif (stirrupType != null && shape != null && beam != null)\n{\n    IList<Curve> curves = new List<Curve>();\n    curves.Add(Line.CreateBound(new XYZ(0,0,0), new XYZ(1,0,0)));\n    Rebar rebar = Rebar.CreateFromCurves(doc, RebarStyle.StirrupTie, stirrupType, null, null, beam, XYZ.BasisZ, curves, RebarHookOrientation.Right, RebarHookOrientation.Right, true, true);\n    if (rebar != null)\n    {\n        rebar.GetRebarLayoutRule().SetLayoutAsMaximumSpacing(UnitUtils.ConvertToInternalUnits(300, UnitTypeId.Millimeters), rebar.get_Parameter(BuiltInParameter.CURVE_ELEM_LENGTH).AsDouble(), true, true, true);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Faltan elementos necesarios: Viga, tipo de barra o forma de estribo.\");\n}"}
{"prompt":"Apply beam reinforcement with stirrups spaced every 30 cm.","completion":"RebarBarType stirrupType = new FilteredElementCollector(doc).OfClass(typeof(RebarBarType)).FirstOrDefault() as RebarBarType;\nRebarShape shape = new FilteredElementCollector(doc).OfClass(typeof(RebarShape)).FirstOrDefault(s => s.RebarStyle == RebarStyle.StirrupTie) as RebarShape;\nFamilyInstance beam = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsNotElementType().FirstOrDefault() as FamilyInstance;\nif (stirrupType != null && shape != null && beam != null)\n{\n    IList<Curve> curves = new List<Curve>();\n    curves.Add(Line.CreateBound(new XYZ(0,0,0), new XYZ(1,0,0)));\n    Rebar rebar = Rebar.CreateFromCurves(doc, RebarStyle.StirrupTie, stirrupType, null, null, beam, XYZ.BasisZ, curves, RebarHookOrientation.Right, RebarHookOrientation.Right, true, true);\n    if (rebar != null)\n    {\n        rebar.GetRebarLayoutRule().SetLayoutAsMaximumSpacing(UnitUtils.ConvertToInternalUnits(300, UnitTypeId.Millimeters), rebar.get_Parameter(BuiltInParameter.CURVE_ELEM_LENGTH).AsDouble(), true, true, true);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Required elements are missing: Beam, bar type, or stirrup shape.\");\n}"}
{"prompt":"Obtén todas las habitaciones que están en el Nivel 3.","completion":"Level level3 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 3\") as Level;\nif (level3 != null)\n{\n    List<Element> roomsOnLevel3 = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).Where(r => r.LevelId == level3.Id).ToList();\n    TaskDialog.Show(\"Resultado\", $\"Se encontraron {roomsOnLevel3.Count} habitaciones en el Nivel 3.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el 'Nivel 3'.\");\n}"}
{"prompt":"Get all rooms on Level 3.","completion":"Level level3 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 3\") as Level;\nif (level3 != null)\n{\n    List<Element> roomsOnLevel3 = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).Where(r => r.LevelId == level3.Id).ToList();\n    TaskDialog.Show(\"Result\", $\"Found {roomsOnLevel3.Count} rooms on Level 3.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Level 3' not found.\");\n}"}
{"prompt":"Crea una vista de sección llamada 'Sección Longitudinal'.","completion":"ViewFamilyType sectionType = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.Section);\nif (sectionType != null)\n{\n    BoundingBoxXYZ sectionBox = new BoundingBoxXYZ();\n    sectionBox.Min = new XYZ(-10, -1, 0);\n    sectionBox.Max = new XYZ(10, 1, 10);\n    Transform transform = Transform.Identity;\n    sectionBox.Transform = transform;\n    ViewSection sectionView = ViewSection.CreateSection(doc, sectionType.Id, sectionBox);\n    if(sectionView != null) sectionView.Name = \"Sección Longitudinal\";\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el tipo de familia de vista de sección.\");\n}"}
{"prompt":"Create a section view named 'Longitudinal Section'.","completion":"ViewFamilyType sectionType = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.Section);\nif (sectionType != null)\n{\n    BoundingBoxXYZ sectionBox = new BoundingBoxXYZ();\n    sectionBox.Min = new XYZ(-10, -1, 0);\n    sectionBox.Max = new XYZ(10, 1, 10);\n    Transform transform = Transform.Identity;\n    sectionBox.Transform = transform;\n    ViewSection sectionView = ViewSection.CreateSection(doc, sectionType.Id, sectionBox);\n    if(sectionView != null) sectionView.Name = \"Longitudinal Section\";\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Section View Family Type not found.\");\n}"}
{"prompt":"Cambia el nivel de detalle de la vista activa a 'Medio'.","completion":"View activeView = doc.ActiveView;\nif(activeView != null)\n{\n    if(activeView.DetailLevel != ViewDetailLevel.Medium)\n    {\n        activeView.DetailLevel = ViewDetailLevel.Medium;\n        TaskDialog.Show(\"Éxito\", \"Nivel de detalle cambiado a 'Medio'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", \"El nivel de detalle ya era 'Medio'.\");\n    }\n}"}
{"prompt":"Change the detail level of the active view to 'Medium'.","completion":"View activeView = doc.ActiveView;\nif(activeView != null)\n{\n    if(activeView.DetailLevel != ViewDetailLevel.Medium)\n    {\n        activeView.DetailLevel = ViewDetailLevel.Medium;\n        TaskDialog.Show(\"Success\", \"Detail level changed to 'Medium'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", \"The detail level was already 'Medium'.\");\n    }\n}"}
{"prompt":"Genera un grupo a partir de la selección actual y muévelo 10 metros a la derecha.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif (selectedIds.Count > 0)\n{\n    Group group = doc.Create.NewGroup(selectedIds);\n    XYZ translation = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0, 0);\n    ElementTransformUtils.MoveElement(doc, group.Id, translation);\n    TaskDialog.Show(\"Éxito\", $\"Grupo '{group.Name}' creado y movido.\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No había elementos seleccionados para agrupar.\");\n}"}
{"prompt":"Create a group from the current selection and move it 10 meters to the right.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif (selectedIds.Count > 0)\n{\n    Group group = doc.Create.NewGroup(selectedIds);\n    XYZ translation = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0, 0);\n    ElementTransformUtils.MoveElement(doc, group.Id, translation);\n    TaskDialog.Show(\"Success\", $\"Group '{group.Name}' created and moved.\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No elements were selected to group.\");\n}"}
{"prompt":"Obtén todas las instancias de la categoría Mobiliario.","completion":"List<Element> furnitureInstances = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Furniture).WhereElementIsNotElementType().ToList();\nTaskDialog.Show(\"Resultado\", $\"Se encontraron {furnitureInstances.Count} instancias de mobiliario.\");"}
{"prompt":"Get all instances of the Furniture category.","completion":"List<Element> furnitureInstances = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Furniture).WhereElementIsNotElementType().ToList();\nTaskDialog.Show(\"Result\", $\"Found {furnitureInstances.Count} furniture instances.\");"}
{"prompt":"Ajusta la región de recorte de la vista a un rectángulo de (0,0) a (20,20).","completion":"View view = doc.ActiveView;\nif (view != null && view.CropBoxActive)\n{\n    BoundingBoxXYZ cropBox = view.CropBox;\n    XYZ minPoint = new XYZ(UnitUtils.ConvertToInternalUnits(0, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(0, UnitTypeId.Meters), cropBox.Min.Z);\n    XYZ maxPoint = new XYZ(UnitUtils.ConvertToInternalUnits(20, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(20, UnitTypeId.Meters), cropBox.Max.Z);\n    cropBox.Min = minPoint;\n    cropBox.Max = maxPoint;\n    view.CropBox = cropBox;\n}"}
{"prompt":"Adjust the view's crop region to a rectangle from (0,0) to (20,20).","completion":"View view = doc.ActiveView;\nif (view != null && view.CropBoxActive)\n{\n    BoundingBoxXYZ cropBox = view.CropBox;\n    XYZ minPoint = new XYZ(UnitUtils.ConvertToInternalUnits(0, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(0, UnitTypeId.Meters), cropBox.Min.Z);\n    XYZ maxPoint = new XYZ(UnitUtils.ConvertToInternalUnits(20, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(20, UnitTypeId.Meters), cropBox.Max.Z);\n    cropBox.Min = minPoint;\n    cropBox.Max = maxPoint;\n    view.CropBox = cropBox;\n}"}
{"prompt":"Dibuja una curva spline que pase por tres puntos.","completion":"IList<XYZ> points = new List<XYZ>\n{\n    new XYZ(0,0,0),\n    new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0),\n    new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0, 0)\n};\nNurbSpline spline = NurbSpline.Create(points);\nPlane plane = Plane.CreateByNormalAndOrigin(XYZ.BasisZ, XYZ.Zero);\nSketchPlane sp = SketchPlane.Create(doc, plane);\nif (sp != null)\n{\n    doc.Create.NewModelCurve(spline, sp);\n}"}
{"prompt":"Draw a spline curve passing through three points.","completion":"IList<XYZ> points = new List<XYZ>\n{\n    new XYZ(0,0,0),\n    new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0),\n    new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0, 0)\n};\nNurbSpline spline = NurbSpline.Create(points);\nPlane plane = Plane.CreateByNormalAndOrigin(XYZ.BasisZ, XYZ.Zero);\nSketchPlane sp = SketchPlane.Create(doc, plane);\nif (sp != null)\n{\n    doc.Create.NewModelCurve(spline, sp);\n}"}
{"prompt":"Activa todos los símbolos de familia cargados en el proyecto.","completion":"List<FamilySymbol> symbols = new FilteredElementCollector(doc).OfClass(typeof(FamilySymbol)).Cast<FamilySymbol>().ToList();\nint activatedCount = 0;\nforeach (var sym in symbols)\n{\n    if (!sym.IsActive) \n    {\n        sym.Activate();\n        activatedCount++;\n    }\n}\nTaskDialog.Show(\"Resultado\", $\"{activatedCount} símbolos de familia fueron activados. {symbols.Count} símbolos en total.\");"}
{"prompt":"Activate all family symbols loaded in the project.","completion":"List<FamilySymbol> symbols = new FilteredElementCollector(doc).OfClass(typeof(FamilySymbol)).Cast<FamilySymbol>().ToList();\nint activatedCount = 0;\nforeach (var sym in symbols)\n{\n    if (!sym.IsActive) \n    {\n        sym.Activate();\n        activatedCount++;\n    }\n}\nTaskDialog.Show(\"Result\", $\"{activatedCount} family symbols were activated. {symbols.Count} total symbols.\");"}
{"prompt":"Crea un filtro de vista para ocultar muros demolidos.","completion":"Phase demolishedPhase = new FilteredElementCollector(doc).OfClass(typeof(Phase)).FirstOrDefault(p => p.Name.Contains(\"Demolished\") || p.Name.Contains(\"Demolición\"));\nif(demolishedPhase != null)\n{\n    ElementId paramId = new ElementId(BuiltInParameter.PHASE_DEMOLISHED);\n    FilterRule rule = ParameterFilterRuleFactory.CreateEqualsRule(paramId, demolishedPhase.Id);\n    ElementFilter filter = new ElementParameterFilter(rule);\n    ParameterFilterElement pfe = ParameterFilterElement.Create(doc, \"Filtro Demolición\", new List<ElementId>{ new ElementId(BuiltInCategory.OST_Walls) }, filter);\n    doc.ActiveView.AddFilter(pfe.Id);\n    doc.ActiveView.SetFilterVisibility(pfe.Id, false);\n    TaskDialog.Show(\"Éxito\", \"Filtro de muros demolidos creado y aplicado a la vista.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró una fase de demolición en el proyecto.\");\n}"}
{"prompt":"Create a view filter to hide demolished walls.","completion":"Phase demolishedPhase = new FilteredElementCollector(doc).OfClass(typeof(Phase)).FirstOrDefault(p => p.Name.Contains(\"Demolished\") || p.Name.Contains(\"Demolición\"));\nif(demolishedPhase != null)\n{\n    ElementId paramId = new ElementId(BuiltInParameter.PHASE_DEMOLISHED);\n    FilterRule rule = ParameterFilterRuleFactory.CreateEqualsRule(paramId, demolishedPhase.Id);\n    ElementFilter filter = new ElementParameterFilter(rule);\n    ParameterFilterElement pfe = ParameterFilterElement.Create(doc, \"Demolition Filter\", new List<ElementId>{ new ElementId(BuiltInCategory.OST_Walls) }, filter);\n    doc.ActiveView.AddFilter(pfe.Id);\n    doc.ActiveView.SetFilterVisibility(pfe.Id, false);\n    TaskDialog.Show(\"Success\", \"Demolished walls filter created and applied to the view.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A demolition phase was not found in the project.\");\n}"}
{"prompt":"Aplica un color rojo a todas las ventanas en la vista activa.","completion":"View activeView = doc.ActiveView;\nOverrideGraphicSettings ogs = new OverrideGraphicSettings();\nogs.SetProjectionLineColor(new Color(255, 0, 0));\nICollection<ElementId> windows = new FilteredElementCollector(doc, activeView.Id).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().ToElementIds();\nif(windows.Any())\n{\n    foreach (ElementId windowId in windows)\n    {\n        activeView.SetElementOverrides(windowId, ogs);\n    }\n    TaskDialog.Show(\"Éxito\", $\"{windows.Count} ventanas ahora son rojas en esta vista.\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No se encontraron ventanas en la vista activa.\");\n}"}
{"prompt":"Apply a red color to all windows in the active view.","completion":"View activeView = doc.ActiveView;\nOverrideGraphicSettings ogs = new OverrideGraphicSettings();\nogs.SetProjectionLineColor(new Color(255, 0, 0));\nICollection<ElementId> windows = new FilteredElementCollector(doc, activeView.Id).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().ToElementIds();\nif(windows.Any())\n{\n    foreach (ElementId windowId in windows)\n    {\n        activeView.SetElementOverrides(windowId, ogs);\n    }\n    TaskDialog.Show(\"Success\", $\"{windows.Count} windows are now red in this view.\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No windows were found in the active view.\");\n}"}
{"prompt":"Crea un Path of Travel entre los puntos (1,1) y (10,10) en la vista de planta.","completion":"ViewPlan viewPlan = doc.ActiveView as ViewPlan;\nif(viewPlan != null)\n{\n    XYZ startPoint = new XYZ(UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters), viewPlan.GenLevel.Elevation);\n    XYZ endPoint = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), viewPlan.GenLevel.Elevation);\n    try\n    {\n        PathOfTravel.Create(viewPlan, startPoint, endPoint);\n    }\n    catch (Autodesk.Revit.Exceptions.ApplicationException ex)\n    {\n        TaskDialog.Show(\"Error de Path of Travel\", ex.Message);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"La vista activa debe ser una vista de planta.\");\n}"}
{"prompt":"Create a Path of Travel between points (1,1) and (10,10) in the plan view.","completion":"ViewPlan viewPlan = doc.ActiveView as ViewPlan;\nif(viewPlan != null)\n{\n    XYZ startPoint = new XYZ(UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters), viewPlan.GenLevel.Elevation);\n    XYZ endPoint = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), viewPlan.GenLevel.Elevation);\n    try\n    {\n        PathOfTravel.Create(viewPlan, startPoint, endPoint);\n    }\n    catch (Autodesk.Revit.Exceptions.ApplicationException ex)\n    {\n        TaskDialog.Show(\"Path of Travel Error\", ex.Message);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"The active view must be a plan view.\");\n}"}
{"prompt":"Inserta una nota de texto con 'Revisar' en la vista actual.","completion":"View activeView = doc.ActiveView;\nElementId defaultTypeId = doc.GetDefaultElementTypeId(ElementTypeGroup.TextNoteType);\nif (activeView != null && defaultTypeId != ElementId.InvalidElementId)\n{\n    XYZ position = new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0);\n    TextNote.Create(doc, activeView.Id, position, \"Revisar\", defaultTypeId);\n}"}
{"prompt":"Insert a text note with 'Review' in the current view.","completion":"View activeView = doc.ActiveView;\nElementId defaultTypeId = doc.GetDefaultElementTypeId(ElementTypeGroup.TextNoteType);\nif (activeView != null && defaultTypeId != ElementId.InvalidElementId)\n{\n    XYZ position = new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0);\n    TextNote.Create(doc, activeView.Id, position, \"Review\", defaultTypeId);\n}"}
{"prompt":"Mueve un elemento seleccionado a la posición (5,5).","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un elemento para mover\");\nif (pickedRef != null)\n{\n    Element elem = doc.GetElement(pickedRef);\n    if(elem != null)\n    {\n        LocationPoint lp = elem.Location as LocationPoint;\n        if (lp != null)\n        {\n            XYZ newPosition = new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), lp.Point.Z);\n            lp.Point = newPosition;\n        }\n        else\n        {\n            TaskDialog.Show(\"Error\", \"El elemento seleccionado no tiene una ubicación de punto (ej. un muro).\");\n        }\n    }\n}"}
{"prompt":"Move a selected element to position (5,5).","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select an element to move\");\nif (pickedRef != null)\n{\n    Element elem = doc.GetElement(pickedRef);\n    if(elem != null)\n    {\n        LocationPoint lp = elem.Location as LocationPoint;\n        if (lp != null)\n        {\n            XYZ newPosition = new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), lp.Point.Z);\n            lp.Point = newPosition;\n        }\n        else\n        {\n            TaskDialog.Show(\"Error\", \"The selected element does not have a point location (e.g. a wall).\");\n        }\n    }\n}"}
{"prompt":"Dibuja una región rellena con patrón diagonal.","completion":"View activeView = doc.ActiveView;\nFillPatternElement fillPattern = new FilteredElementCollector(doc).OfClass(typeof(FillPatternElement)).FirstOrDefault(p => p.GetFillPattern().IsSolidFill == false) as FillPatternElement;\nFilledRegionType filledRegionType = new FilteredElementCollector(doc, activeView.Id).OfClass(typeof(FilledRegionType)).FirstOrDefault() as FilledRegionType;\nif(fillPattern != null && filledRegionType != null)\n{\n    FilledRegionType newType = filledRegionType.Duplicate(\"Temp Diagonal Region\") as FilledRegionType;\n    newType.ForegroundPatternId = fillPattern.Id;\n    CurveLoop profile = CurveLoop.CreateViaRectangle(new XYZ(0,0,0), new XYZ(5,5,0));\n    FilledRegion.Create(doc, newType.Id, activeView.Id, new List<CurveLoop>{profile});\n}"}
{"prompt":"Draw a filled region with a diagonal pattern.","completion":"View activeView = doc.ActiveView;\nFillPatternElement fillPattern = new FilteredElementCollector(doc).OfClass(typeof(FillPatternElement)).FirstOrDefault(p => p.GetFillPattern().IsSolidFill == false) as FillPatternElement;\nFilledRegionType filledRegionType = new FilteredElementCollector(doc, activeView.Id).OfClass(typeof(FilledRegionType)).FirstOrDefault() as FilledRegionType;\nif(fillPattern != null && filledRegionType != null)\n{\n    FilledRegionType newType = filledRegionType.Duplicate(\"Temp Diagonal Region\") as FilledRegionType;\n    newType.ForegroundPatternId = fillPattern.Id;\n    CurveLoop profile = CurveLoop.CreateViaRectangle(new XYZ(0,0,0), new XYZ(5,5,0));\n    FilledRegion.Create(doc, newType.Id, activeView.Id, new List<CurveLoop>{profile});\n}"}
{"prompt":"Crea un nuevo parámetro de proyecto de tipo texto, llamado 'Clasificación de Espacio', y aplícalo a la categoría de habitaciones.","completion":"string paramName = \"Clasificación de Espacio\";\nCategory roomCat = doc.Settings.Categories.get_Item(BuiltInCategory.OST_Rooms);\nCategorySet catSet = doc.Application.Create.NewCategorySet();\ncatSet.Insert(roomCat);\nDefinitionFile sharedParamFile = doc.Application.OpenSharedParameterFile();\nif (sharedParamFile != null && System.IO.File.Exists(sharedParamFile.Filename))\n{\n    DefinitionGroup group = sharedParamFile.Groups.get_Item(\"CustomParams\");\n    if(group == null) group = sharedParamFile.Groups.Create(\"CustomParams\");\n    Definition definition = group.Definitions.get_Item(paramName);\n    if(definition == null) definition = group.Definitions.Create(new ExternalDefinitionCreationOptions(paramName, SpecTypeId.String.Text));\n    \n    InstanceBinding binding = doc.Application.Create.NewInstanceBinding(catSet);\n    if (doc.ParameterBindings.Insert(definition, binding, BuiltInParameterGroup.PG_IDENTITY_DATA))\n    {\n        TaskDialog.Show(\"Éxito\", $\"Parámetro '{paramName}' creado y enlazado a Habitaciones.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se ha configurado un archivo de parámetros compartidos.\");\n}"}
{"prompt":"Create a text project parameter named 'Space Classification' and apply it to the Rooms category.","completion":"string paramName = \"Space Classification\";\nCategory roomCat = doc.Settings.Categories.get_Item(BuiltInCategory.OST_Rooms);\nCategorySet catSet = doc.Application.Create.NewCategorySet();\ncatSet.Insert(roomCat);\nDefinitionFile sharedParamFile = doc.Application.OpenSharedParameterFile();\nif (sharedParamFile != null && System.IO.File.Exists(sharedParamFile.Filename))\n{\n    DefinitionGroup group = sharedParamFile.Groups.get_Item(\"CustomParams\");\n    if(group == null) group = sharedParamFile.Groups.Create(\"CustomParams\");\n    Definition definition = group.Definitions.get_Item(paramName);\n    if(definition == null) definition = group.Definitions.Create(new ExternalDefinitionCreationOptions(paramName, SpecTypeId.String.Text));\n    \n    InstanceBinding binding = doc.Application.Create.NewInstanceBinding(catSet);\n    if (doc.ParameterBindings.Insert(definition, binding, BuiltInParameterGroup.PG_IDENTITY_DATA))\n    {\n        TaskDialog.Show(\"Success\", $\"Parameter '{paramName}' created and bound to Rooms.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A shared parameter file has not been configured.\");\n}"}
{"prompt":"Establece el parámetro 'Comentarios' de todas las puertas del Nivel 1 a 'Clasificación Fuego - 90 min'.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nif (level1 != null)\n{\n    List<FamilyInstance> doorsOnLevel1 = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsNotElementType().Cast<FamilyInstance>().Where(fi => fi.LevelId == level1.Id).ToList();\n    int updatedCount = 0;\n    foreach(FamilyInstance door in doorsOnLevel1)\n    {\n        Parameter commentsParam = door.get_Parameter(BuiltInParameter.ALL_MODEL_INSTANCE_COMMENTS);\n        if(commentsParam != null && !commentsParam.IsReadOnly) \n        {\n            commentsParam.Set(\"Clasificación Fuego - 90 min\");\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{updatedCount} puertas en '{level1.Name}' actualizadas.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el 'Nivel 1'.\");\n}"}
{"prompt":"Set the 'Comments' parameter for all doors on Level 1 to 'Fire Rating - 90 min'.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nif (level1 != null)\n{\n    List<FamilyInstance> doorsOnLevel1 = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsNotElementType().Cast<FamilyInstance>().Where(fi => fi.LevelId == level1.Id).ToList();\n    int updatedCount = 0;\n    foreach(FamilyInstance door in doorsOnLevel1)\n    {\n        Parameter commentsParam = door.get_Parameter(BuiltInParameter.ALL_MODEL_INSTANCE_COMMENTS);\n        if(commentsParam != null && !commentsParam.IsReadOnly) \n        {\n            commentsParam.Set(\"Fire Rating - 90 min\");\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{updatedCount} doors on '{level1.Name}' were updated.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Level 1' not found.\");\n}"}
{"prompt":"Exporta cada tabla de planificación a un archivo CSV individual.","completion":"string exportPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(exportPath)) System.IO.Directory.CreateDirectory(exportPath);\nList<ViewSchedule> schedules = new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Cast<ViewSchedule>().Where(vs => !vs.IsTemplate).ToList();\nViewScheduleExportOptions options = new ViewScheduleExportOptions();\noptions.FieldDelimiter = \",\";\nint exportedCount = 0;\nforeach(ViewSchedule schedule in schedules)\n{\n    try\n    {\n        schedule.Export(exportPath, schedule.Name + \".csv\", options);\n        exportedCount++;\n    }\n    catch{}\n}\nTaskDialog.Show(\"Resultado\", $\"{exportedCount} tablas de planificación exportadas a '{exportPath}'.\");"}
{"prompt":"Export each schedule to an individual CSV file.","completion":"string exportPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(exportPath)) System.IO.Directory.CreateDirectory(exportPath);\nList<ViewSchedule> schedules = new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Cast<ViewSchedule>().Where(vs => !vs.IsTemplate).ToList();\nViewScheduleExportOptions options = new ViewScheduleExportOptions();\noptions.FieldDelimiter = \",\";\nint exportedCount = 0;\nforeach(ViewSchedule schedule in schedules)\n{\n    try\n    {\n        schedule.Export(exportPath, schedule.Name + \".csv\", options);\n        exportedCount++;\n    }\n    catch{}\n}\nTaskDialog.Show(\"Result\", $\"{exportedCount} schedules exported to '{exportPath}'.\");"}

{"prompt":"Exporta el modelo a formato IFC4 para coordinación.","completion":"string folderPath = \"C:/RevitExports/\";\nstring fileName = doc.Title + \"-Coordination.ifc\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nIFCExportOptions options = new IFCExportOptions();\noptions.FileVersion = IFCVersion.IFC4;\ndoc.Export(folderPath, fileName, options);\nTaskDialog.Show(\"Éxito\", $\"Modelo exportado a IFC4 en: {folderPath}{fileName}\");"}
{"prompt":"Export the model to IFC4 format for coordination.","completion":"string folderPath = \"C:/RevitExports/\";\nstring fileName = doc.Title + \"-Coordination.ifc\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nIFCExportOptions options = new IFCExportOptions();\noptions.FileVersion = IFCVersion.IFC4;\ndoc.Export(folderPath, fileName, options);\nTaskDialog.Show(\"Success\", $\"Model exported to IFC4 at: {folderPath}{fileName}\");"}
{"prompt":"Vincula un archivo DWG como referencia en la vista activa.","completion":"string filePath = \"C:/CAD_Files/Base_Plan.dwg\";\nif(System.IO.File.Exists(filePath))\n{\n    DWGImportOptions options = new DWGImportOptions();\n    options.ColorMode = ImportColorMode.Preserved;\n    ElementId linkedFileId;\n    doc.Link(filePath, options, doc.ActiveView, out linkedFileId);\n    if (linkedFileId != ElementId.InvalidElementId) \n    {\n        TaskDialog.Show(\"Éxito\", $\"Archivo DWG vinculado: {filePath}\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"No se encontró el archivo DWG en la ruta: {filePath}\");\n}"}
{"prompt":"Link a DWG file as a reference in the active view.","completion":"string filePath = \"C:/CAD_Files/Base_Plan.dwg\";\nif(System.IO.File.Exists(filePath))\n{\n    DWGImportOptions options = new DWGImportOptions();\n    options.ColorMode = ImportColorMode.Preserved;\n    ElementId linkedFileId;\n    doc.Link(filePath, options, doc.ActiveView, out linkedFileId);\n    if (linkedFileId != ElementId.InvalidElementId) \n    {\n        TaskDialog.Show(\"Success\", $\"DWG file linked: {filePath}\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"DWG file not found at: {filePath}\");\n}"}
{"prompt":"Exporta todas las hojas de un conjunto a un único PDF.","completion":"ViewSheetSet sheetSet = new FilteredElementCollector(doc).OfClass(typeof(ViewSheetSet)).FirstOrDefault() as ViewSheetSet;\nif(sheetSet != null)\n{\n    string folderPath = \"C:/RevitExports/\";\n    if(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\n    PDFExportOptions options = new PDFExportOptions();\n    options.Combine = true;\n    options.FileName = sheetSet.Name;\n    List<ElementId> sheetIds = sheetSet.Views.Cast<ViewSheet>().Select(s => s.Id).ToList();\n    if(sheetIds.Any()) \n    {\n        doc.Export(folderPath, sheetIds, options);\n        TaskDialog.Show(\"Éxito\", $\"Conjunto de planos '{sheetSet.Name}' exportado a PDF.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Advertencia\", \"El conjunto de planos seleccionado no contiene ninguna hoja.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron conjuntos de planos en el proyecto.\");\n}"}
{"prompt":"Export all sheets in a set to a single combined PDF.","completion":"ViewSheetSet sheetSet = new FilteredElementCollector(doc).OfClass(typeof(ViewSheetSet)).FirstOrDefault() as ViewSheetSet;\nif(sheetSet != null)\n{\n    string folderPath = \"C:/RevitExports/\";\n    if(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\n    PDFExportOptions options = new PDFExportOptions();\n    options.Combine = true;\n    options.FileName = sheetSet.Name;\n    List<ElementId> sheetIds = sheetSet.Views.Cast<ViewSheet>().Select(s => s.Id).ToList();\n    if(sheetIds.Any()) \n    {\n        doc.Export(folderPath, sheetIds, options);\n        TaskDialog.Show(\"Success\", $\"Sheet set '{sheetSet.Name}' exported to PDF.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Warning\", \"The selected sheet set does not contain any sheets.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No sheet sets found in the project.\");\n}"}
{"prompt":"Crea una 'Caja de Referencia' (Scope Box) para el Bloque A.","completion":"string boxName = \"Bloque A\";\nScopeBox existingBox = new FilteredElementCollector(doc, doc.ActiveView.Id).OfClass(typeof(ScopeBox)).Cast<ScopeBox>().FirstOrDefault(sb => sb.Name == boxName);\nif (existingBox == null)\n{\n    BoundingBoxXYZ scopeBoxVolume = new BoundingBoxXYZ();\n    scopeBoxVolume.Min = new XYZ(0,0,0);\n    scopeBoxVolume.Max = new XYZ(UnitUtils.ConvertToInternalUnits(50, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(40, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(20, UnitTypeId.Meters));\n    ScopeBox box = ScopeBox.Create(doc, scopeBoxVolume);\n    box.Name = boxName;\n    TaskDialog.Show(\"Éxito\", $\"Caja de Referencia '{boxName}' creada.\");\n}\nelse\n{\n    TaskDialog.Show(\"Advertencia\", $\"La Caja de Referencia '{boxName}' ya existe.\");\n}"}
{"prompt":"Create a Scope Box for Block A.","completion":"string boxName = \"Block A\";\nScopeBox existingBox = new FilteredElementCollector(doc, doc.ActiveView.Id).OfClass(typeof(ScopeBox)).Cast<ScopeBox>().FirstOrDefault(sb => sb.Name == boxName);\nif (existingBox == null)\n{\n    BoundingBoxXYZ scopeBoxVolume = new BoundingBoxXYZ();\n    scopeBoxVolume.Min = new XYZ(0,0,0);\n    scopeBoxVolume.Max = new XYZ(UnitUtils.ConvertToInternalUnits(50, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(40, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(20, UnitTypeId.Meters));\n    ScopeBox box = ScopeBox.Create(doc, scopeBoxVolume);\n    box.Name = boxName;\n    TaskDialog.Show(\"Success\", $\"Scope Box '{boxName}' created.\");\n}\nelse\n{\n    TaskDialog.Show(\"Warning\", $\"Scope Box '{boxName}' already exists.\");\n}"}
{"prompt":"Crea un barrido de muro en el primer muro que encuentres.","completion":"Wall wall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault() as Wall;\nWallSweepType sweepType = new FilteredElementCollector(doc).OfClass(typeof(WallSweepType)).FirstOrDefault() as WallSweepType;\nif (wall != null && sweepType != null)\n{\n    WallSweepInfo info = new WallSweepInfo(true, WallSweepType.Sweep);\n    info.Distance = 0;\n    WallSweep.Create(doc, wall.Id, sweepType.Id, info);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita al menos un muro y un tipo de barrido en el proyecto.\");\n}"}
{"prompt":"Create a wall sweep on the first wall found.","completion":"Wall wall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault() as Wall;\nWallSweepType sweepType = new FilteredElementCollector(doc).OfClass(typeof(WallSweepType)).FirstOrDefault() as WallSweepType;\nif (wall != null && sweepType != null)\n{\n    WallSweepInfo info = new WallSweepInfo(true, WallSweepType.Sweep);\n    info.Distance = 0;\n    WallSweep.Create(doc, wall.Id, sweepType.Id, info);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"At least one wall and one sweep type are needed in the project.\");\n}"}
{"prompt":"Obtén el espacio MEP asociado a la habitación 'Oficina 101'.","completion":"Room room = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).FirstOrDefault(r => r.Name == \"Oficina 101\") as Room;\nif (room != null)\n{\n    MEPSpace space = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_MEPSpaces).Cast<MEPSpace>().FirstOrDefault(s => s.Room != null && s.Room.Id == room.Id);\n    if (space != null)\n    {\n        TaskDialog.Show(\"Espacio MEP Encontrado\", $\"El espacio asociado a '{room.Name}' es: {space.Name}\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", $\"La habitación '{room.Name}' no tiene un espacio MEP asociado.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró la habitación 'Oficina 101'.\");\n}"}
{"prompt":"Get the MEP space associated with the room 'Office 101'.","completion":"Room room = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).FirstOrDefault(r => r.Name == \"Office 101\") as Room;\nif (room != null)\n{\n    MEPSpace space = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_MEPSpaces).Cast<MEPSpace>().FirstOrDefault(s => s.Room != null && s.Room.Id == room.Id);\n    if (space != null)\n    {\n        TaskDialog.Show(\"MEP Space Found\", $\"The space associated with '{room.Name}' is: {space.Name}\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", $\"Room '{room.Name}' does not have an associated MEP space.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Room 'Office 101' not found.\");\n}"}
{"prompt":"Crea un nuevo material llamado 'Roble Oscuro' con un patrón de superficie de madera.","completion":"string materialName = \"Roble Oscuro\";\nMaterial material = new FilteredElementCollector(doc).OfClass(typeof(Material)).Cast<Material>().FirstOrDefault(m => m.Name == materialName);\nif (material == null)\n{\n    ElementId materialId = Material.Create(doc, materialName);\n    material = doc.GetElement(materialId) as Material;\n}\nif(material != null)\n{\n    FillPatternElement fillPattern = new FilteredElementCollector(doc).OfClass(typeof(FillPatternElement)).FirstOrDefault(p => p.Name.Contains(\"Wood\") || p.Name.Contains(\"Madera\")) as FillPatternElement;\n    if(fillPattern != null) material.SurfaceForegroundPatternId = fillPattern.Id;\n    material.Color = new Color(139, 69, 19);\n    TaskDialog.Show(\"Éxito\", $\"Material '{materialName}' creado o actualizado.\");\n}"}
{"prompt":"Create a new material named 'Dark Oak' with a wood surface pattern.","completion":"string materialName = \"Dark Oak\";\nMaterial material = new FilteredElementCollector(doc).OfClass(typeof(Material)).Cast<Material>().FirstOrDefault(m => m.Name == materialName);\nif (material == null)\n{\n    ElementId materialId = Material.Create(doc, materialName);\n    material = doc.GetElement(materialId) as Material;\n}\nif(material != null)\n{\n    FillPatternElement fillPattern = new FilteredElementCollector(doc).OfClass(typeof(FillPatternElement)).FirstOrDefault(p => p.Name.Contains(\"Wood\") || p.Name.Contains(\"Madera\")) as FillPatternElement;\n    if(fillPattern != null) material.SurfaceForegroundPatternId = fillPattern.Id;\n    material.Color = new Color(139, 69, 19);\n    TaskDialog.Show(\"Success\", $\"Material '{materialName}' created or updated.\");\n}"}
{"prompt":"Establece la configuración de sol y sombra para la vista 3D activa a una fecha y hora.","completion":"View3D view3D = doc.ActiveView as View3D;\nif (view3D != null)\n{\n    if(view3D.CanEnableSunAndShadows())\n    {\n        SunAndShadowSettings settings = view3D.SunAndShadowSettings;\n        settings.SunAndShadowType = SunAndShadowType.Still;\n        settings.SetTimeAndDate(new DateTime(2024, 6, 21, 15, 30, 0));\n        view3D.ShadowsOn = true;\n    }\n    else\n    {\n        TaskDialog.Show(\"Advertencia\", \"No se pueden habilitar las sombras en esta vista 3D (quizás por la configuración de la plantilla).\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"La vista activa no es una vista 3D.\");\n}"}
{"prompt":"Set the sun and shadow settings for the active 3D view to a specific date and time.","completion":"View3D view3D = doc.ActiveView as View3D;\nif (view3D != null)\n{\n    if(view3D.CanEnableSunAndShadows())\n    {\n        SunAndShadowSettings settings = view3D.SunAndShadowSettings;\n        settings.SunAndShadowType = SunAndShadowType.Still;\n        settings.SetTimeAndDate(new DateTime(2024, 6, 21, 15, 30, 0));\n        view3D.ShadowsOn = true;\n    }\n    else\n    {\n        TaskDialog.Show(\"Warning\", \"Cannot enable shadows in this 3D view (perhaps due to template settings).\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"The active view is not a 3D view.\");\n}"}
{"prompt":"Crea una abertura rectangular en un suelo.","completion":"Floor floor = new FilteredElementCollector(doc).OfClass(typeof(Floor)).FirstOrDefault() as Floor;\nif (floor != null)\n{\n    XYZ p1 = new XYZ(UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters), 0);\n    XYZ p2 = new XYZ(UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0);\n    CurveLoop profile = CurveLoop.CreateViaRectangle(p1, p2);\n    doc.Create.NewOpening(floor, profile, true);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró ningún suelo para crear la abertura.\");\n}"}
{"prompt":"Create a rectangular opening in a floor.","completion":"Floor floor = new FilteredElementCollector(doc).OfClass(typeof(Floor)).FirstOrDefault() as Floor;\nif (floor != null)\n{\n    XYZ p1 = new XYZ(UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters), 0);\n    XYZ p2 = new XYZ(UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0);\n    CurveLoop profile = CurveLoop.CreateViaRectangle(p1, p2);\n    doc.Create.NewOpening(floor, profile, true);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No floor found to create the opening.\");\n}"}
{"prompt":"Cambia el estilo visual de la vista activa a 'Línea Oculta'.","completion":"View activeView = doc.ActiveView;\nif (activeView != null && activeView.CanBePrinted)\n{\n    if(activeView.DisplayStyle != DisplayStyle.HLR)\n    {\n        activeView.DisplayStyle = DisplayStyle.HLR;\n        TaskDialog.Show(\"Éxito\", \"Estilo visual cambiado a 'Línea Oculta'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", \"El estilo visual ya era 'Línea Oculta'.\");\n    }\n}"}
{"prompt":"Change the visual style of the active view to 'Hidden Line'.","completion":"View activeView = doc.ActiveView;\nif (activeView != null && activeView.CanBePrinted)\n{\n    if(activeView.DisplayStyle != DisplayStyle.HLR)\n    {\n        activeView.DisplayStyle = DisplayStyle.HLR;\n        TaskDialog.Show(\"Success\", \"Visual style changed to 'Hidden Line'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", \"The visual style was already 'Hidden Line'.\");\n    }\n}"}
{"prompt":"Duplica la vista 'Nivel 1' como una vista dependiente.","completion":"ViewPlan viewToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).FirstOrDefault(v => v.Name == \"Nivel 1\") as ViewPlan;\nif (viewToDuplicate != null)\n{\n    ElementId newViewId = viewToDuplicate.Duplicate(ViewDuplicateOption.AsDependent);\n    View newView = doc.GetElement(newViewId) as View;\n    if(newView != null) \n    {\n        TaskDialog.Show(\"Éxito\", $\"Vista dependiente '{newView.Name}' creada para '{viewToDuplicate.Name}'.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró la vista 'Nivel 1' para duplicar.\");\n}"}
{"prompt":"Duplicate the 'Level 1' view as a dependent view.","completion":"ViewPlan viewToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).FirstOrDefault(v => v.Name == \"Level 1\") as ViewPlan;\nif (viewToDuplicate != null)\n{\n    ElementId newViewId = viewToDuplicate.Duplicate(ViewDuplicateOption.AsDependent);\n    View newView = doc.GetElement(newViewId) as View;\n    if(newView != null) \n    {\n        TaskDialog.Show(\"Success\", $\"Dependent view '{newView.Name}' created for '{viewToDuplicate.Name}'.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"View 'Level 1' not found to duplicate.\");\n}"}
{"prompt":"Coloca una cámara en la vista activa.","completion":"ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(f => f.ViewFamily == ViewFamily.ThreeDimensional);\nif (vft != null)\n{\n    View3D cameraView = View3D.CreatePerspective(doc, vft.Id);\n    cameraView.Name = \"Nueva Vista de Cámara\";\n    XYZ eyePos = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters));\n    XYZ upDir = XYZ.BasisZ;\n    XYZ forwardDir = XYZ.Zero - eyePos;\n    ViewOrientation3D orientation = new ViewOrientation3D(eyePos, upDir, forwardDir);\n    cameraView.SetOrientation(orientation);\n    TaskDialog.Show(\"Éxito\", $\"Cámara creada con la vista '{cameraView.Name}'.\");\n}"}
{"prompt":"Place a camera in the active view.","completion":"ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(f => f.ViewFamily == ViewFamily.ThreeDimensional);\nif (vft != null)\n{\n    View3D cameraView = View3D.CreatePerspective(doc, vft.Id);\n    cameraView.Name = \"New Camera View\";\n    XYZ eyePos = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters));\n    XYZ upDir = XYZ.BasisZ;\n    XYZ forwardDir = XYZ.Zero - eyePos;\n    ViewOrientation3D orientation = new ViewOrientation3D(eyePos, upDir, forwardDir);\n    cameraView.SetOrientation(orientation);\n    TaskDialog.Show(\"Success\", $\"Camera created with view '{cameraView.Name}'.\");\n}"}
{"prompt":"Obtén todas las habitaciones en el Nivel 'Planta Baja'.","completion":"Level groundFloor = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Planta Baja\") as Level;\nif (groundFloor != null)\n{\n    List<Element> roomsOnGround = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).Where(r => r.LevelId == groundFloor.Id).ToList();\n    TaskDialog.Show(\"Resultado\", $\"Se encontraron {roomsOnGround.Count} habitaciones en '{groundFloor.Name}'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el nivel 'Planta Baja'.\");\n}"}
{"prompt":"Get all rooms on the 'Ground Floor' Level.","completion":"Level groundFloor = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Ground Floor\") as Level;\nif (groundFloor != null)\n{\n    List<Element> roomsOnGround = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).Where(r => r.LevelId == groundFloor.Id).ToList();\n    TaskDialog.Show(\"Result\", $\"Found {roomsOnGround.Count} rooms on '{groundFloor.Name}'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Level 'Ground Floor' not found.\");\n}"}
{"prompt":"Cambia el nivel de detalle de la vista actual a 'Bajo'.","completion":"View activeView = doc.ActiveView;\nif (activeView != null)\n{\n    if (activeView.DetailLevel != ViewDetailLevel.Coarse)\n    {\n        activeView.DetailLevel = ViewDetailLevel.Coarse;\n        TaskDialog.Show(\"Éxito\", \"Nivel de detalle cambiado a 'Bajo'.\");\n    }\n}"}
{"prompt":"Change the detail level of the current view to 'Coarse'.","completion":"View activeView = doc.ActiveView;\nif (activeView != null)\n{\n    if (activeView.DetailLevel != ViewDetailLevel.Coarse)\n    {\n        activeView.DetailLevel = ViewDetailLevel.Coarse;\n        TaskDialog.Show(\"Success\", \"Detail level changed to 'Coarse'.\");\n    }\n}"}
{"prompt":"Crea un SketchPlane en el Nivel 2.","completion":"Level level2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 2\") as Level;\nif(level2 != null)\n{\n    Plane plane = Plane.CreateByNormalAndOrigin(level2.GetPlane().Normal, level2.GetPlane().Origin);\n    SketchPlane skp = SketchPlane.Create(doc, plane);\n    if (skp != null) TaskDialog.Show(\"Éxito\", $\"SketchPlane creado en el '{level2.Name}'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el 'Nivel 2'.\");\n}"}
{"prompt":"Create a SketchPlane on Level 2.","completion":"Level level2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 2\") as Level;\nif(level2 != null)\n{\n    Plane plane = Plane.CreateByNormalAndOrigin(level2.GetPlane().Normal, level2.GetPlane().Origin);\n    SketchPlane skp = SketchPlane.Create(doc, plane);\n    if (skp != null) TaskDialog.Show(\"Success\", $\"SketchPlane created on '{level2.Name}'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Level 2' not found.\");\n}"}
{"prompt":"Activa todos los FamilySymbol del proyecto.","completion":"List<FamilySymbol> symbols = new FilteredElementCollector(doc).OfClass(typeof(FamilySymbol)).Cast<FamilySymbol>().ToList();\nint activatedCount = 0;\nforeach (FamilySymbol sym in symbols)\n{\n    if (!sym.IsActive)\n    {\n        sym.Activate();\n        activatedCount++;\n    }\n}\nTaskDialog.Show(\"Resultado\", $\"{activatedCount} símbolos de familia fueron activados. {symbols.Count} símbolos en total.\");"}
{"prompt":"Activate all FamilySymbols in the project.","completion":"List<FamilySymbol> symbols = new FilteredElementCollector(doc).OfClass(typeof(FamilySymbol)).Cast<FamilySymbol>().ToList();\nint activatedCount = 0;\nforeach (FamilySymbol sym in symbols)\n{\n    if (!sym.IsActive)\n    {\n        sym.Activate();\n        activatedCount++;\n    }\n}\nTaskDialog.Show(\"Result\", $\"{activatedCount} family symbols were activated. {symbols.Count} total symbols.\");"}
{"prompt":"Inicia y confirma una transacción para 'Modificar Proyecto'.","completion":"TaskDialog.Show(\"Información\", \"La acción solicitada ya se ejecuta dentro de una transacción gestionada por el agente de IA.\");"}
{"prompt":"Start and commit a transaction for 'Modify Project'.","completion":"TaskDialog.Show(\"Information\", \"The requested action is already running inside a transaction managed by the AI agent.\");"}
{"prompt":"Crea un DirectShape con forma de caja de 2x2x2 metros.","completion":"TessellatedShapeBuilder builder = new TessellatedShapeBuilder();\nbuilder.OpenConnectedFaceSet(true);\ndouble size = UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters);\nXYZ p0=new XYZ(0,0,0); XYZ p1=new XYZ(size,0,0); XYZ p2=new XYZ(size,size,0); XYZ p3=new XYZ(0,size,0);\nXYZ p4=new XYZ(0,0,size); XYZ p5=new XYZ(size,0,size); XYZ p6=new XYZ(size,size,size); XYZ p7=new XYZ(0,size,size);\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{p0,p1,p2,p3}, ElementId.InvalidElementId));\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{p7,p6,p5,p4}, ElementId.InvalidElementId));\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{p0,p4,p5,p1}, ElementId.InvalidElementId));\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{p1,p5,p6,p2}, ElementId.InvalidElementId));\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{p2,p6,p7,p3}, ElementId.InvalidElementId));\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{p3,p7,p4,p0}, ElementId.InvalidElementId));\nbuilder.CloseConnectedFaceSet();\nbuilder.Build();\nTessellatedShapeBuilderResult result = builder.GetBuildResult();\nif (result.GetGeometricalObjects().Any())\n{\n    DirectShape ds = DirectShape.CreateElement(doc, new ElementId(BuiltInCategory.OST_GenericModel));\n    ds.SetShape(result.GetGeometricalObjects());\n    ds.Name = \"Caja DirectShape\";\n}"}
{"prompt":"Create a DirectShape with a 2x2x2 meter box shape.","completion":"TessellatedShapeBuilder builder = new TessellatedShapeBuilder();\nbuilder.OpenConnectedFaceSet(true);\ndouble size = UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters);\nXYZ p0=new XYZ(0,0,0); XYZ p1=new XYZ(size,0,0); XYZ p2=new XYZ(size,size,0); XYZ p3=new XYZ(0,size,0);\nXYZ p4=new XYZ(0,0,size); XYZ p5=new XYZ(size,0,size); XYZ p6=new XYZ(size,size,size); XYZ p7=new XYZ(0,size,size);\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{p0,p1,p2,p3}, ElementId.InvalidElementId));\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{p7,p6,p5,p4}, ElementId.InvalidElementId));\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{p0,p4,p5,p1}, ElementId.InvalidElementId));\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{p1,p5,p6,p2}, ElementId.InvalidElementId));\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{p2,p6,p7,p3}, ElementId.InvalidElementId));\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{p3,p7,p4,p0}, ElementId.InvalidElementId));\nbuilder.CloseConnectedFaceSet();\nbuilder.Build();\nTessellatedShapeBuilderResult result = builder.GetBuildResult();\nif (result.GetGeometricalObjects().Any())\n{\n    DirectShape ds = DirectShape.CreateElement(doc, new ElementId(BuiltInCategory.OST_GenericModel));\n    ds.SetShape(result.GetGeometricalObjects());\n    ds.Name = \"DirectShape Box\";\n}"}
{"prompt":"Crea un nuevo parámetro compartido de tipo entero llamado 'Capacidad' y aplícalo a la categoría de mobiliario.","completion":"string paramName = \"Capacidad\";\nstring groupName = \"CustomData\";\nDefinitionFile sharedParamFile = doc.Application.OpenSharedParameterFile();\nif (sharedParamFile == null || !System.IO.File.Exists(sharedParamFile.Filename))\n{\n    TaskDialog.Show(\"Error\", \"No se ha configurado un archivo de parámetros compartidos en Revit. Por favor, cree o vincule uno primero.\");\n}\nelse\n{\n    DefinitionGroup group = sharedParamFile.Groups.get_Item(groupName) ?? sharedParamFile.Groups.Create(groupName);\n    Definition definition = group.Definitions.get_Item(paramName);\n    if(definition == null)\n    {\n        ExternalDefinitionCreationOptions options = new ExternalDefinitionCreationOptions(paramName, SpecTypeId.Int.Integer);\n        definition = group.Definitions.Create(options);\n    }\n    Category cat = doc.Settings.Categories.get_Item(BuiltInCategory.OST_Furniture);\n    CategorySet catSet = doc.Application.Create.NewCategorySet();\n    catSet.Insert(cat);\n    InstanceBinding binding = doc.Application.Create.NewInstanceBinding(catSet);\n    if (doc.ParameterBindings.Insert(definition, binding, BuiltInParameterGroup.PG_DATA))\n    {\n        TaskDialog.Show(\"Éxito\", $\"Parámetro '{paramName}' enlazado a la categoría Mobiliario.\");\n    }\n}"}
{"prompt":"Create a new shared integer parameter named 'Capacity' and apply it to the furniture category.","completion":"string paramName = \"Capacity\";\nstring groupName = \"CustomData\";\nDefinitionFile sharedParamFile = doc.Application.OpenSharedParameterFile();\nif (sharedParamFile == null || !System.IO.File.Exists(sharedParamFile.Filename))\n{\n    TaskDialog.Show(\"Error\", \"A shared parameter file has not been configured in Revit. Please create or link one first.\");\n}\nelse\n{\n    DefinitionGroup group = sharedParamFile.Groups.get_Item(groupName) ?? sharedParamFile.Groups.Create(groupName);\n    Definition definition = group.Definitions.get_Item(paramName);\n    if(definition == null)\n    {\n        ExternalDefinitionCreationOptions options = new ExternalDefinitionCreationOptions(paramName, SpecTypeId.Int.Integer);\n        definition = group.Definitions.Create(options);\n    }\n    Category cat = doc.Settings.Categories.get_Item(BuiltInCategory.OST_Furniture);\n    CategorySet catSet = doc.Application.Create.NewCategorySet();\n    catSet.Insert(cat);\n    InstanceBinding binding = doc.Application.Create.NewInstanceBinding(catSet);\n    if (doc.ParameterBindings.Insert(definition, binding, BuiltInParameterGroup.PG_DATA))\n    {\n        TaskDialog.Show(\"Success\", $\"Parameter '{paramName}' bound to the Furniture category.\");\n    }\n}"}
{"prompt":"Mueve un muro 5 metros a la derecha.","completion":"Wall wall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault() as Wall;\nif(wall != null)\n{\n    XYZ translation = new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters),0,0);\n    ElementTransformUtils.MoveElement(doc, wall.Id, translation);\n}"}
{"prompt":"Move a wall 5 meters to the right.","completion":"Wall wall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault() as Wall;\nif(wall != null)\n{\n    XYZ translation = new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters),0,0);\n    ElementTransformUtils.MoveElement(doc, wall.Id, translation);\n}"}
{"prompt":"Cambia la visibilidad de los muros cortados en la vista activa para que no sean visibles.","completion":"View activeView = doc.ActiveView;\nif(activeView != null)\n{\n    ElementId wallCategoryId = new ElementId(BuiltInCategory.OST_Walls);\n    OverrideGraphicSettings ogs = activeView.GetCategoryOverrides(wallCategoryId) ?? new OverrideGraphicSettings();\n    ogs.SetCutPatternVisible(false);\n    activeView.SetCategoryOverrides(wallCategoryId, ogs);\n    TaskDialog.Show(\"Éxito\", \"La visibilidad de los muros cortados ha sido desactivada en esta vista.\");\n}"}
{"prompt":"Change the visibility of cut walls in the active view to not be visible.","completion":"View activeView = doc.ActiveView;\nif(activeView != null)\n{\n    ElementId wallCategoryId = new ElementId(BuiltInCategory.OST_Walls);\n    OverrideGraphicSettings ogs = activeView.GetCategoryOverrides(wallCategoryId) ?? new OverrideGraphicSettings();\n    ogs.SetCutPatternVisible(false);\n    activeView.SetCategoryOverrides(wallCategoryId, ogs);\n    TaskDialog.Show(\"Success\", \"Visibility for cut walls has been turned off in this view.\");\n}"}
{"prompt":"Exporta el documento a un archivo IFC con la versión IFC4x3.","completion":"string folderPath = \"C:/RevitExports/\";\nstring fileName = doc.Title + \"_IFC4x3.ifc\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nIFCExportOptions options = new IFCExportOptions();\noptions.FileVersion = IFCVersion.IFC4x3;\ndoc.Export(folderPath, fileName, options);\nTaskDialog.Show(\"Éxito\", $\"Modelo exportado a IFC4x3 en: {folderPath}{fileName}\");"}
{"prompt":"Export the document to an IFC file with version IFC4x3.","completion":"string folderPath = \"C:/RevitExports/\";\nstring fileName = doc.Title + \"_IFC4x3.ifc\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nIFCExportOptions options = new IFCExportOptions();\noptions.FileVersion = IFCVersion.IFC4x3;\ndoc.Export(folderPath, fileName, options);\nTaskDialog.Show(\"Success\", $\"Model exported to IFC4x3 at: {folderPath}{fileName}\");"}
{"prompt":"Duplica el tipo de muro 'Basic Wall' y renómbralo.","completion":"string typeToDuplicate = \"Basic Wall\";\nstring newTypeName = \"Basic Wall Copy\";\nWallType wt = new FilteredElementCollector(doc).OfClass(typeof(WallType)).Cast<WallType>().FirstOrDefault(w=>w.Name==typeToDuplicate);\nif(wt != null)\n{\n    WallType newWt = wt.Duplicate(newTypeName) as WallType;\n    if(newWt != null) TaskDialog.Show(\"Éxito\", $\"Tipo '{typeToDuplicate}' duplicado como '{newTypeName}'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"No se encontró el tipo de muro '{typeToDuplicate}'.\");\n}"}
{"prompt":"Duplicate the 'Basic Wall' type and rename it.","completion":"string typeToDuplicate = \"Basic Wall\";\nstring newTypeName = \"Basic Wall Copy\";\nWallType wt = new FilteredElementCollector(doc).OfClass(typeof(WallType)).Cast<WallType>().FirstOrDefault(w=>w.Name==typeToDuplicate);\nif(wt != null)\n{\n    WallType newWt = wt.Duplicate(newTypeName) as WallType;\n    if(newWt != null) TaskDialog.Show(\"Success\", $\"Type '{typeToDuplicate}' duplicated as '{newTypeName}'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"Wall type '{typeToDuplicate}' not found.\");\n}"}
{"prompt":"Crea una nueva vista 3D orientada desde el punto (10,10,10) mirando hacia el origen.","completion":"ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v=>v.ViewFamily==ViewFamily.ThreeDimensional);\nif(vft != null)\n{\n    View3D view = View3D.CreateIsometric(doc, vft.Id);\n    XYZ eyePos = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters));\n    XYZ upDir = XYZ.BasisZ;\n    XYZ forwardDir = XYZ.Zero - eyePos;\n    ViewOrientation3D vo = new ViewOrientation3D(eyePos, upDir, forwardDir);\n    view.SetOrientation(vo);\n    view.Name = \"Vista desde (10,10,10)\";\n    TaskDialog.Show(\"Éxito\", $\"Vista '{view.Name}' creada.\");\n}"}
{"prompt":"Create a new 3D view oriented from point (10,10,10) looking at the origin.","completion":"ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v=>v.ViewFamily==ViewFamily.ThreeDimensional);\nif(vft != null)\n{\n    View3D view = View3D.CreateIsometric(doc, vft.Id);\n    XYZ eyePos = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters));\n    XYZ upDir = XYZ.BasisZ;\n    XYZ forwardDir = XYZ.Zero - eyePos;\n    ViewOrientation3D vo = new ViewOrientation3D(eyePos, upDir, forwardDir);\n    view.SetOrientation(vo);\n    view.Name = \"View from (10,10,10)\";\n    TaskDialog.Show(\"Success\", $\"View '{view.Name}' created.\");\n}"}

{"prompt":"Crea un texto de modelo en la vista activa que diga 'PROYECTO BIM'.","completion":"SketchPlane sp = doc.ActiveView.SketchPlane;\nif (sp != null)\n{\n    double height = UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters);\n    ModelText.Create(doc, \"PROYECTO BIM\", sp.GetPlane(), new XYZ(0,0,0), height);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"La vista activa no tiene un SketchPlane válido.\");\n}"}
{"prompt":"Create a model text in the active view that says 'BIM PROJECT'.","completion":"SketchPlane sp = doc.ActiveView.SketchPlane;\nif (sp != null)\n{\n    double height = UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters);\n    ModelText.Create(doc, \"BIM PROJECT\", sp.GetPlane(), new XYZ(0,0,0), height);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"The active view does not have a valid SketchPlane.\");\n}"}
{"prompt":"Añade un material llamado 'Vidrio Reflectante' con 80% de reflectividad.","completion":"string materialName = \"Vidrio Reflectante\";\nMaterial material = new FilteredElementCollector(doc).OfClass(typeof(Material)).Cast<Material>().FirstOrDefault(m => m.Name == materialName);\nif (material == null)\n{\n    ElementId materialId = Material.Create(doc, materialName);\n    material = doc.GetElement(materialId) as Material;\n}\nif(material != null)\n{\n    AppearanceAssetElement appearanceAsset = new FilteredElementCollector(doc).OfClass(typeof(AppearanceAssetElement)).Cast<AppearanceAssetElement>().FirstOrDefault(a => a.Name.Contains(\"Glass\"));\n    if (appearanceAsset != null)\n    {\n        AppearanceAssetElement newAsset = appearanceAsset.Duplicate(materialName + \"_Asset\");\n        using(AppearanceAssetEditScope scope = new AppearanceAssetEditScope(newAsset))\n        {\n            Asset editableAsset = scope.Start();\n            AssetPropertyDouble reflectivity = editableAsset.FindByName(\"generic_reflectivity\") as AssetPropertyDouble;\n            if(reflectivity != null) reflectivity.Value = 0.8;\n            scope.Commit(true);\n        }\n        material.AppearanceAssetId = newAsset.Id;\n    }\n    TaskDialog.Show(\"Éxito\", $\"Material '{materialName}' creado o actualizado.\");\n}"}
{"prompt":"Add a material named 'Reflective Glass' with 80% reflectivity.","completion":"string materialName = \"Reflective Glass\";\nMaterial material = new FilteredElementCollector(doc).OfClass(typeof(Material)).Cast<Material>().FirstOrDefault(m => m.Name == materialName);\nif (material == null)\n{\n    ElementId materialId = Material.Create(doc, materialName);\n    material = doc.GetElement(materialId) as Material;\n}\nif(material != null)\n{\n    AppearanceAssetElement appearanceAsset = new FilteredElementCollector(doc).OfClass(typeof(AppearanceAssetElement)).Cast<AppearanceAssetElement>().FirstOrDefault(a => a.Name.Contains(\"Glass\"));\n    if (appearanceAsset != null)\n    {\n        AppearanceAssetElement newAsset = appearanceAsset.Duplicate(materialName + \"_Asset\");\n        using(AppearanceAssetEditScope scope = new AppearanceAssetEditScope(newAsset))\n        {\n            Asset editableAsset = scope.Start();\n            AssetPropertyDouble reflectivity = editableAsset.FindByName(\"generic_reflectivity\") as AssetPropertyDouble;\n            if(reflectivity != null) reflectivity.Value = 0.8;\n            scope.Commit(true);\n        }\n        material.AppearanceAssetId = newAsset.Id;\n    }\n    TaskDialog.Show(\"Success\", $\"Material '{materialName}' created or updated.\");\n}"}
{"prompt":"Crea una topografía DirectShape a partir de una lista de puntos.","completion":"List<XYZ> points = new List<XYZ>\n{\n    new XYZ(0,0,0),\n    new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0, UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters)),\n    new XYZ(0, UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters)),\n    new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0)\n};\nTessellatedShapeBuilder builder = new TessellatedShapeBuilder();\nbuilder.OpenConnectedFaceSet(true);\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{points[0], points[1], points[2]}, ElementId.InvalidElementId));\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{points[1], points[3], points[2]}, ElementId.InvalidElementId));\nbuilder.CloseConnectedFaceSet();\nbuilder.Build();\nTessellatedShapeBuilderResult result = builder.GetBuildResult();\nif (result.GetGeometricalObjects().Any())\n{\n    DirectShape ds = DirectShape.CreateElement(doc, new ElementId(BuiltInCategory.OST_Topography));\n    ds.SetShape(result.GetGeometricalObjects());\n    ds.Name = \"Topografía DirectShape\";\n}"}
{"prompt":"Create a DirectShape topography from a list of points.","completion":"List<XYZ> points = new List<XYZ>\n{\n    new XYZ(0,0,0),\n    new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0, UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters)),\n    new XYZ(0, UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters)),\n    new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0)\n};\nTessellatedShapeBuilder builder = new TessellatedShapeBuilder();\nbuilder.OpenConnectedFaceSet(true);\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{points[0], points[1], points[2]}, ElementId.InvalidElementId));\nbuilder.AddFace(new TessellatedFace(new List<XYZ>{points[1], points[3], points[2]}, ElementId.InvalidElementId));\nbuilder.CloseConnectedFaceSet();\nbuilder.Build();\nTessellatedShapeBuilderResult result = builder.GetBuildResult();\nif (result.GetGeometricalObjects().Any())\n{\n    DirectShape ds = DirectShape.CreateElement(doc, new ElementId(BuiltInCategory.OST_Topography));\n    ds.SetShape(result.GetGeometricalObjects());\n    ds.Name = \"Topography DirectShape\";\n}"}
{"prompt":"Carga un enlace DWG preservando los colores.","completion":"string filePath = \"C:/CAD/Planos.dwg\";\nif(System.IO.File.Exists(filePath))\n{\n    DWGImportOptions opts = new DWGImportOptions();\n    opts.ColorMode = ImportColorMode.Preserved;\n    ElementId linkId;\n    doc.Link(filePath, opts, doc.ActiveView, out linkId);\n    if(linkId != ElementId.InvalidElementId) TaskDialog.Show(\"Éxito\", \"Enlace DWG cargado.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"Archivo no encontrado en: {filePath}\");\n}"}
{"prompt":"Load a DWG link, preserving its colors.","completion":"string filePath = \"C:/CAD/Plans.dwg\";\nif(System.IO.File.Exists(filePath))\n{\n    DWGImportOptions opts = new DWGImportOptions();\n    opts.ColorMode = ImportColorMode.Preserved;\n    ElementId linkId;\n    doc.Link(filePath, opts, doc.ActiveView, out linkId);\n    if(linkId != ElementId.InvalidElementId) TaskDialog.Show(\"Success\", \"DWG link loaded.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"File not found at: {filePath}\");\n}"}
{"prompt":"Obtén todas las vistas de planta y muestra sus nombres.","completion":"List<ViewPlan> planViews = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).Cast<ViewPlan>().ToList();\nStringBuilder viewNames = new StringBuilder($\"Se encontraron {planViews.Count} Vistas de Plano:\\n\");\nforeach(var vp in planViews)\n{\n    viewNames.AppendLine(\"- \" + vp.Name);\n}\nTaskDialog.Show(\"Vistas de Plano\", viewNames.ToString());"}
{"prompt":"Get all plan views and list their names.","completion":"List<ViewPlan> planViews = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).Cast<ViewPlan>().ToList();\nStringBuilder viewNames = new StringBuilder($\"Found {planViews.Count} Plan Views:\\n\");\nforeach(var vp in planViews)\n{\n    viewNames.AppendLine(\"- \" + vp.Name);\n}\nTaskDialog.Show(\"Plan Views\", viewNames.ToString());"}
{"prompt":"Crea un nuevo nivel llamado 'Mezzanine' a 7.5 metros de elevación.","completion":"string levelName = \"Mezzanine\";\nif (new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == levelName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El nivel '{levelName}' ya existe.\");\n}\nelse\n{\n    double elevation = UnitUtils.ConvertToInternalUnits(7.5, UnitTypeId.Meters);\n    Level newLevel = Level.Create(doc, elevation);\n    newLevel.Name = levelName;\n    TaskDialog.Show(\"Éxito\", $\"Nivel '{levelName}' creado.\");\n}"}
{"prompt":"Create a new level named 'Mezzanine' at 7.5 meters elevation.","completion":"string levelName = \"Mezzanine\";\nif (new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == levelName))\n{\n    TaskDialog.Show(\"Warning\", $\"Level '{levelName}' already exists.\");\n}\nelse\n{\n    double elevation = UnitUtils.ConvertToInternalUnits(7.5, UnitTypeId.Meters);\n    Level newLevel = Level.Create(doc, elevation);\n    newLevel.Name = levelName;\n    TaskDialog.Show(\"Success\", $\"Level '{levelName}' created.\");\n}"}
{"prompt":"Define un filtro de vista para ocultar las líneas de detalle.","completion":"string filterName = \"Ocultar Líneas de Detalle\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ParameterFilterElement)).Any(f => f.Name == filterName))\n{\n    TaskDialog.Show(\"Advertencia\", \"Un filtro con ese nombre ya existe.\");\n}\nelse\n{\n    ICollection<ElementId> catsToHide = new List<ElementId>{new ElementId(BuiltInCategory.OST_Lines)};\n    ElementFilter filter = new ElementCategoryFilter(new ElementId(BuiltInCategory.OST_Lines));\n    ParameterFilterElement pfe = ParameterFilterElement.Create(doc, filterName, catsToHide, filter);\n    doc.ActiveView.AddFilter(pfe.Id);\n    doc.ActiveView.SetFilterVisibility(pfe.Id, false);\n    TaskDialog.Show(\"Éxito\", \"Filtro para ocultar líneas de detalle creado y aplicado.\");\n}"}
{"prompt":"Define a view filter to hide detail lines.","completion":"string filterName = \"Hide Detail Lines\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ParameterFilterElement)).Any(f => f.Name == filterName))\n{\n    TaskDialog.Show(\"Warning\", \"A filter with that name already exists.\");\n}\nelse\n{\n    ICollection<ElementId> catsToHide = new List<ElementId>{new ElementId(BuiltInCategory.OST_Lines)};\n    ElementFilter filter = new ElementCategoryFilter(new ElementId(BuiltInCategory.OST_Lines));\n    ParameterFilterElement pfe = ParameterFilterElement.Create(doc, filterName, catsToHide, filter);\n    doc.ActiveView.AddFilter(pfe.Id);\n    doc.ActiveView.SetFilterVisibility(pfe.Id, false);\n    TaskDialog.Show(\"Success\", \"Filter to hide detail lines created and applied.\");\n}"}
{"prompt":"Crea una vista de sección usando una caja de 10x10x3 metros.","completion":"ViewFamilyType sectionVFT = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(vft => vft.ViewFamily == ViewFamily.Section);\nif(sectionVFT != null)\n{\n    BoundingBoxXYZ sectionBox = new BoundingBoxXYZ();\n    sectionBox.Min = new XYZ(0,0,0);\n    sectionBox.Max = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters));\n    Transform transform = Transform.Identity;\n    sectionBox.Transform = transform;\n    ViewSection.CreateSection(doc, sectionVFT.Id, sectionBox);\n}"}
{"prompt":"Create a section view using a 10x10x3 meter box.","completion":"ViewFamilyType sectionVFT = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(vft => vft.ViewFamily == ViewFamily.Section);\nif(sectionVFT != null)\n{\n    BoundingBoxXYZ sectionBox = new BoundingBoxXYZ();\n    sectionBox.Min = new XYZ(0,0,0);\n    sectionBox.Max = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters));\n    Transform transform = Transform.Identity;\n    sectionBox.Transform = transform;\n    ViewSection.CreateSection(doc, sectionVFT.Id, sectionBox);\n}"}
{"prompt":"Crea un workset llamado 'Estructura'.","completion":"if(doc.IsWorkshared)\n{\n    string wsName = \"Estructura\";\n    if (WorksetTable.IsWorksetNameUnique(doc, wsName))\n    {\n        Workset.Create(doc, wsName);\n        TaskDialog.Show(\"Éxito\", $\"Workset '{wsName}' creado.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Advertencia\", $\"El workset '{wsName}' ya existe.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Esta acción requiere un modelo compartido (Workshared).\");\n}"}
{"prompt":"Create a new workset named 'Structure'.","completion":"if(doc.IsWorkshared)\n{\n    string wsName = \"Structure\";\n    if (WorksetTable.IsWorksetNameUnique(doc, wsName))\n    {\n        Workset.Create(doc, wsName);\n        TaskDialog.Show(\"Success\", $\"Workset '{wsName}' created.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Warning\", $\"Workset '{wsName}' already exists.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"This action requires a workshared model.\");\n}"}
{"prompt":"Asigna todos los muros al workset 'Estructura'.","completion":"if(doc.IsWorkshared)\n{\n    Workset ws = new FilteredWorksetCollector(doc).OfKind(WorksetKind.UserWorkset).FirstOrDefault(w => w.Name == \"Estructura\");\n    if(ws != null)\n    {\n        ICollection<ElementId> wallIds = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().ToElementIds();\n        if(wallIds.Any()) \n        {\n            WorksharingUtils.ChangeWorkset(doc, wallIds, ws.Id);\n            TaskDialog.Show(\"Éxito\", $\"{wallIds.Count} muros asignados al workset '{ws.Name}'.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró el workset 'Estructura'.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Esta acción requiere un modelo compartido (Workshared).\");\n}"}
{"prompt":"Assign all walls to the 'Structure' workset.","completion":"if(doc.IsWorkshared)\n{\n    Workset ws = new FilteredWorksetCollector(doc).OfKind(WorksetKind.UserWorkset).FirstOrDefault(w => w.Name == \"Structure\");\n    if(ws != null)\n    {\n        ICollection<ElementId> wallIds = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().ToElementIds();\n        if(wallIds.Any()) \n        {\n            WorksharingUtils.ChangeWorkset(doc, wallIds, ws.Id);\n            TaskDialog.Show(\"Success\", $\"{wallIds.Count} walls assigned to workset '{ws.Name}'.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Workset 'Structure' not found.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"This action requires a workshared model.\");\n}"}
{"prompt":"Crea un techo por extrusión con una pendiente del 10%.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nRoofType roofType = new FilteredElementCollector(doc).OfClass(typeof(RoofType)).FirstOrDefault() as RoofType;\nif(level != null && roofType != null)\n{\n    CurveLoop profile = new CurveLoop();\n    profile.Append(Line.CreateBound(new XYZ(0,0,0), new XYZ(10,0,1)));\n    profile.Append(Line.CreateBound(new XYZ(10,0,1), new XYZ(10,0,0)));\n    profile.Append(Line.CreateBound(new XYZ(10,0,0), new XYZ(0,0,0)));\n    Plane plane = Plane.CreateByNormalAndOrigin(XYZ.BasisY, XYZ.Zero);\n    ReferencePlane refPlane = ReferencePlane.Create(doc, plane);\n    ExtrusionRoof extrusionRoof = doc.Create.NewExtrusionRoof(profile, refPlane, level, roofType, 0, 10);\n    extrusionRoof.get_Parameter(BuiltInParameter.ROOF_SLOPE).Set(0.1);\n}"}
{"prompt":"Create an extrusion roof with a 10% slope.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nRoofType roofType = new FilteredElementCollector(doc).OfClass(typeof(RoofType)).FirstOrDefault() as RoofType;\nif(level != null && roofType != null)\n{\n    CurveLoop profile = new CurveLoop();\n    profile.Append(Line.CreateBound(new XYZ(0,0,0), new XYZ(10,0,1)));\n    profile.Append(Line.CreateBound(new XYZ(10,0,1), new XYZ(10,0,0)));\n    profile.Append(Line.CreateBound(new XYZ(10,0,0), new XYZ(0,0,0)));\n    Plane plane = Plane.CreateByNormalAndOrigin(XYZ.BasisY, XYZ.Zero);\n    ReferencePlane refPlane = ReferencePlane.Create(doc, plane);\n    ExtrusionRoof extrusionRoof = doc.Create.NewExtrusionRoof(profile, refPlane, level, roofType, 0, 10);\n    extrusionRoof.get_Parameter(BuiltInParameter.ROOF_SLOPE).Set(0.1);\n}"}
{"prompt":"Obtén la tabla de planificación 'Muros' y exporta sus datos a un archivo CSV.","completion":"ViewSchedule schedule = new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Cast<ViewSchedule>().FirstOrDefault(s=>s.Name==\"Muros\");\nif(schedule != null)\n{\n    string folderPath = \"C:/RevitExports/\";\n    if(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\n    ViewScheduleExportOptions options = new ViewScheduleExportOptions() { FieldDelimiter = \",\" };\n    schedule.Export(folderPath, \"Muros.csv\", options);\n    TaskDialog.Show(\"Éxito\", \"Tabla de planificación 'Muros' exportada.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró la tabla de planificación 'Muros'.\");\n}"}
{"prompt":"Get the 'Walls' schedule and export its data to CSV.","completion":"ViewSchedule schedule = new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Cast<ViewSchedule>().FirstOrDefault(s=>s.Name==\"Walls\");\nif(schedule != null)\n{\n    string folderPath = \"C:/RevitExports/\";\n    if(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\n    ViewScheduleExportOptions options = new ViewScheduleExportOptions() { FieldDelimiter = \",\" };\n    schedule.Export(folderPath, \"Walls.csv\", options);\n    TaskDialog.Show(\"Success\", \"'Walls' schedule exported.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Walls' schedule not found.\");\n}"}
{"prompt":"Permite al usuario seleccionar un muro y resáltalo en la vista.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Por favor, selecciona un muro\");\nif (pickedRef != null && pickedRef.ElementId != ElementId.InvalidElementId)\n{\n    uidoc.Selection.SetElementIds(new List<ElementId>{pickedRef.ElementId});\n    uidoc.ShowElements(pickedRef.ElementId);\n}"}
{"prompt":"Allow the user to select a wall and highlight it in the view.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Please select a wall\");\nif (pickedRef != null && pickedRef.ElementId != ElementId.InvalidElementId)\n{\n    uidoc.Selection.SetElementIds(new List<ElementId>{pickedRef.ElementId});\n    uidoc.ShowElements(pickedRef.ElementId);\n}"}
{"prompt":"Crea una nueva hoja A1 usando el primer cajetín disponible.","completion":"FamilySymbol titleBlock = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_TitleBlocks).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nif (titleBlock != null)\n{\n    ViewSheet sheet = ViewSheet.Create(doc, titleBlock.Id);\n    sheet.Name = \"A1 - Nueva Hoja\";\n    sheet.SheetNumber = \"A1\";\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron familias de cajetín (Title Block) en el proyecto.\");\n}"}
{"prompt":"Create a new A1 sheet using the first available title block.","completion":"FamilySymbol titleBlock = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_TitleBlocks).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nif (titleBlock != null)\n{\n    ViewSheet sheet = ViewSheet.Create(doc, titleBlock.Id);\n    sheet.Name = \"A1 - New Sheet\";\n    sheet.SheetNumber = \"A1\";\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No Title Block families found in the project.\");\n}"}
{"prompt":"Coloca la vista 'Nivel 1' en el centro de la hoja activa.","completion":"ViewPlan viewToPlace = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).FirstOrDefault(v => v.Name == \"Nivel 1\") as ViewPlan;\nViewSheet activeSheet = doc.ActiveView as ViewSheet;\nif (activeSheet == null)\n{\n    TaskDialog.Show(\"Error\", \"La vista activa no es una hoja (Sheet).\");\n}\nelse if (viewToPlace == null)\n{\n    TaskDialog.Show(\"Error\", \"No se encontró la vista 'Nivel 1'.\");\n}\nelse if (Viewport.CanAddViewToSheet(doc, activeSheet.Id, viewToPlace.Id))\n{\n    BoundingBoxUV sheetBox = activeSheet.Outline;\n    XYZ centerPoint = new XYZ((sheetBox.Min.U + sheetBox.Max.U) / 2, (sheetBox.Min.V + sheetBox.Max.V) / 2, 0);\n    Viewport.Create(doc, activeSheet.Id, viewToPlace.Id, centerPoint);\n}\nelse\n{\n    TaskDialog.Show(\"Advertencia\", \"La vista 'Nivel 1' ya está colocada en una hoja.\");\n}"}
{"prompt":"Place the 'Level 1' view in the center of the active sheet.","completion":"ViewPlan viewToPlace = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).FirstOrDefault(v => v.Name == \"Level 1\") as ViewPlan;\nViewSheet activeSheet = doc.ActiveView as ViewSheet;\nif (activeSheet == null)\n{\n    TaskDialog.Show(\"Error\", \"The active view is not a sheet.\");\n}\nelse if (viewToPlace == null)\n{\n    TaskDialog.Show(\"Error\", \"View 'Level 1' not found.\");\n}\nelse if (Viewport.CanAddViewToSheet(doc, activeSheet.Id, viewToPlace.Id))\n{\n    BoundingBoxUV sheetBox = activeSheet.Outline;\n    XYZ centerPoint = new XYZ((sheetBox.Min.U + sheetBox.Max.U) / 2, (sheetBox.Min.V + sheetBox.Max.V) / 2, 0);\n    Viewport.Create(doc, activeSheet.Id, viewToPlace.Id, centerPoint);\n}\nelse\n{\n    TaskDialog.Show(\"Warning\", \"The 'Level 1' view is already placed on a sheet.\");\n}"}
{"prompt":"Aplica la plantilla de vista 'Plantilla Arquitectónica' a la vista activa.","completion":"View activeView = doc.ActiveView;\nView viewTemplate = new FilteredElementCollector(doc).OfClass(typeof(View)).Cast<View>().FirstOrDefault(v => v.IsTemplate && v.Name == \"Plantilla Arquitectónica\");\nif (activeView != null && viewTemplate != null)\n{\n    if (activeView.ViewTemplateId != viewTemplate.Id)\n    {\n        activeView.ViewTemplateId = viewTemplate.Id;\n        TaskDialog.Show(\"Éxito\", \"Plantilla de vista aplicada.\");\n    }\n    else\n    {\n         TaskDialog.Show(\"Información\", \"La plantilla seleccionada ya estaba aplicada.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró la plantilla de vista 'Plantilla Arquitectónica'.\");\n}"}
{"prompt":"Apply the 'Architectural Template' view template to the active view.","completion":"View activeView = doc.ActiveView;\nView viewTemplate = new FilteredElementCollector(doc).OfClass(typeof(View)).Cast<View>().FirstOrDefault(v => v.IsTemplate && v.Name == \"Architectural Template\");\nif (activeView != null && viewTemplate != null)\n{\n    if (activeView.ViewTemplateId != viewTemplate.Id)\n    {\n        activeView.ViewTemplateId = viewTemplate.Id;\n        TaskDialog.Show(\"Success\", \"View template applied.\");\n    }\n    else\n    {\n         TaskDialog.Show(\"Information\", \"The selected template was already applied.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"View template 'Architectural Template' not found.\");\n}"}
{"prompt":"Crea un circuito eléctrico conectando luminarias a un panel.","completion":"FamilyInstance panel = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_ElectricalEquipment).WhereElementIsNotElementType().FirstOrDefault() as FamilyInstance;\nICollection<ElementId> fixtures = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_LightingFixtures).WhereElementIsNotElementType().ToElementIds();\nif (panel != null && fixtures.Any())\n{\n    ElectricalSystem.Create(doc, fixtures, panel, ElectricalSystemType.PowerCircuit);\n    TaskDialog.Show(\"Éxito\", $\"Circuito creado conectando {fixtures.Count} luminarias al panel '{panel.Name}'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita al menos un panel eléctrico y una luminaria.\");\n}"}
{"prompt":"Create an electrical circuit connecting light fixtures to a panel.","completion":"FamilyInstance panel = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_ElectricalEquipment).WhereElementIsNotElementType().FirstOrDefault() as FamilyInstance;\nICollection<ElementId> fixtures = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_LightingFixtures).WhereElementIsNotElementType().ToElementIds();\nif (panel != null && fixtures.Any())\n{\n    ElectricalSystem.Create(doc, fixtures, panel, ElectricalSystemType.PowerCircuit);\n    TaskDialog.Show(\"Success\", $\"Circuit created connecting {fixtures.Count} fixtures to panel '{panel.Name}'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"At least one electrical panel and one light fixture are needed.\");\n}"}
{"prompt":"Modela una bandeja de cables entre dos puntos.","completion":"CableTrayType trayType = new FilteredElementCollector(doc).OfClass(typeof(CableTrayType)).FirstOrDefault() as CableTrayType;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nif (trayType != null && level != null)\n{\n    XYZ p1 = new XYZ(0,10,3); \n    XYZ p2 = new XYZ(15,10,3);\n    CableTray.Create(doc, trayType.Id, p1, p2, level.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un tipo de bandeja de cables y un nivel en el proyecto.\");\n}"}
{"prompt":"Model a cable tray between two points.","completion":"CableTrayType trayType = new FilteredElementCollector(doc).OfClass(typeof(CableTrayType)).FirstOrDefault() as CableTrayType;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nif (trayType != null && level != null)\n{\n    XYZ p1 = new XYZ(0,10,3); \n    XYZ p2 = new XYZ(15,10,3);\n    CableTray.Create(doc, trayType.Id, p1, p2, level.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A cable tray type and a level are needed in the project.\");\n}"}
{"prompt":"Encuentra todas las colisiones entre tuberías y vigas.","completion":"ICollection<ElementId> pipeIds = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_PipeCurves).WhereElementIsNotElementType().ToElementIds();\nif (pipeIds.Any())\n{\n    ElementIntersectsElementFilter clashFilter = new ElementIntersectsElementFilter(new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsNotElementType().ToElementIds());\n    ICollection<ElementId> clashingPipeIds = new FilteredElementCollector(doc, pipeIds).WherePasses(clashFilter).ToElementIds();\n    TaskDialog.Show(\"Detección de Colisiones\", $\"Se encontraron {clashingPipeIds.Count} tuberías que colisionan con vigas.\");\n    if (clashingPipeIds.Any()) \n    {\n        UIDocument uidoc = new UIDocument(doc);\n        uidoc.Selection.SetElementIds(clashingPipeIds);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Detección de Colisiones\", \"No se encontraron tuberías para verificar.\");\n}"}
{"prompt":"Find all clashes between pipes and beams.","completion":"ICollection<ElementId> pipeIds = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_PipeCurves).WhereElementIsNotElementType().ToElementIds();\nif (pipeIds.Any())\n{\n    ElementIntersectsElementFilter clashFilter = new ElementIntersectsElementFilter(new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsNotElementType().ToElementIds());\n    ICollection<ElementId> clashingPipeIds = new FilteredElementCollector(doc, pipeIds).WherePasses(clashFilter).ToElementIds();\n    TaskDialog.Show(\"Clash Detection\", $\"Found {clashingPipeIds.Count} pipes clashing with beams.\");\n    if (clashingPipeIds.Any()) \n    {\n        UIDocument uidoc = new UIDocument(doc);\n        uidoc.Selection.SetElementIds(clashingPipeIds);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Clash Detection\", \"No pipes found to check.\");\n}"}
{"prompt":"Crea un parámetro global de longitud llamado 'AnchoCorredor' con valor de 1.2m.","completion":"string paramName = \"AnchoCorredor\";\nif (GlobalParametersManager.IsGlobalParameterValidName(doc, paramName))\n{\n    GlobalParameter gp = GlobalParameter.Create(doc, paramName, SpecTypeId.Length);\n    gp.SetValue(new DoubleParameterValue(UnitUtils.ConvertToInternalUnits(1.2, UnitTypeId.Meters)));\n    TaskDialog.Show(\"Éxito\", $\"Parámetro Global '{paramName}' creado.\");\n}\nelse\n{\n    TaskDialog.Show(\"Advertencia\", $\"Ya existe un Parámetro Global con el nombre '{paramName}'.\");\n}"}
{"prompt":"Create a global length parameter named 'CorridorWidth' with a value of 1.2m.","completion":"string paramName = \"CorridorWidth\";\nif (GlobalParametersManager.IsGlobalParameterValidName(doc, paramName))\n{\n    GlobalParameter gp = GlobalParameter.Create(doc, paramName, SpecTypeId.Length);\n    gp.SetValue(new DoubleParameterValue(UnitUtils.ConvertToInternalUnits(1.2, UnitTypeId.Meters)));\n    TaskDialog.Show(\"Success\", $\"Global Parameter '{paramName}' created.\");\n}\nelse\n{\n    TaskDialog.Show(\"Warning\", $\"A Global Parameter named '{paramName}' already exists.\");\n}"}
{"prompt":"Obtén la geometría sólida de un elemento seleccionado.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un elemento para obtener su geometría\");\nif (pickedRef != null)\n{\n    Element elem = doc.GetElement(pickedRef);\n    Options opt = new Options() { ComputeReferences = true, DetailLevel = ViewDetailLevel.Fine };\n    GeometryElement geoElem = elem.get_Geometry(opt);\n    List<Solid> solids = geoElem.OfType<Solid>().Where(s => s.Volume > 0).ToList();\n    TaskDialog.Show(\"Geometría\", $\"Se encontraron {solids.Count} sólidos en el elemento seleccionado.\");\n}"}
{"prompt":"Get the solid geometry of a selected element.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select an element to get its geometry\");\nif (pickedRef != null)\n{\n    Element elem = doc.GetElement(pickedRef);\n    Options opt = new Options() { ComputeReferences = true, DetailLevel = ViewDetailLevel.Fine };\n    GeometryElement geoElem = elem.get_Geometry(opt);\n    List<Solid> solids = geoElem.OfType<Solid>().Where(s => s.Volume > 0).ToList();\n    TaskDialog.Show(\"Geometry\", $\"Found {solids.Count} solids in the selected element.\");\n}"}
{"prompt":"Alinea la cara de un muro con la cara de otro.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference ref1 = uidoc.Selection.PickObject(ObjectType.Face, \"Selecciona la cara de destino (estática)\");\nif (ref1 == null) return;\nReference ref2 = uidoc.Selection.PickObject(ObjectType.Face, \"Selecciona la cara a mover\");\nif (ref2 == null) return;\ndoc.Create.NewAlignment(doc.ActiveView, ref1, ref2);"}
{"prompt":"Align the face of one wall with the face of another.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference ref1 = uidoc.Selection.PickObject(ObjectType.Face, \"Select the target face (stationary)\");\nif (ref1 == null) return;\nReference ref2 = uidoc.Selection.PickObject(ObjectType.Face, \"Select the face to move\");\nif (ref2 == null) return;\ndoc.Create.NewAlignment(doc.ActiveView, ref1, ref2);"}
{"prompt":"Cambia el tipo de todas las ventanas de 'Fijo' a 'Abatible'.","completion":"FamilySymbol newType = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsElementType().Cast<FamilySymbol>().FirstOrDefault(fs => fs.Name.Contains(\"Abatible\"));\nFamilySymbol oldType = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsElementType().Cast<FamilySymbol>().FirstOrDefault(fs => fs.Name.Contains(\"Fijo\"));\nif (newType != null && oldType != null)\n{\n    List<FamilyInstance> windowsToChange = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().Cast<FamilyInstance>().Where(fi => fi.Symbol.Id == oldType.Id).ToList();\n    int changedCount = 0;\n    foreach (FamilyInstance window in windowsToChange)\n    {\n        window.Symbol = newType;\n        changedCount++;\n    }\n    TaskDialog.Show(\"Resultado\", $\"{changedCount} ventanas cambiadas de tipo.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron los tipos de ventana 'Fijo' o 'Abatible'.\");\n}"}
{"prompt":"Change the type of all 'Fixed' windows to 'Casement'.","completion":"FamilySymbol newType = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsElementType().Cast<FamilySymbol>().FirstOrDefault(fs => fs.Name.Contains(\"Casement\"));\nFamilySymbol oldType = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsElementType().Cast<FamilySymbol>().FirstOrDefault(fs => fs.Name.Contains(\"Fixed\"));\nif (newType != null && oldType != null)\n{\n    List<FamilyInstance> windowsToChange = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().Cast<FamilyInstance>().Where(fi => fi.Symbol.Id == oldType.Id).ToList();\n    int changedCount = 0;\n    foreach (FamilyInstance window in windowsToChange)\n    {\n        window.Symbol = newType;\n        changedCount++;\n    }\n    TaskDialog.Show(\"Result\", $\"{changedCount} windows had their type changed.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Fixed' or 'Casement' window types not found.\");\n}"}
{"prompt":"Recarga el vínculo de Revit 'Estructura_LINK.rvt'.","completion":"RevitLinkType linkType = new FilteredElementCollector(doc).OfClass(typeof(RevitLinkType)).Cast<RevitLinkType>().FirstOrDefault(lt => lt.Name == \"Estructura_LINK.rvt\");\nif (linkType != null)\n{\n    linkType.Reload();\n    TaskDialog.Show(\"Éxito\", \"El vínculo 'Estructura_LINK.rvt' ha sido recargado.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el vínculo de Revit 'Estructura_LINK.rvt'.\");\n}"}
{"prompt":"Reload the Revit link 'Structure_LINK.rvt'.","completion":"RevitLinkType linkType = new FilteredElementCollector(doc).OfClass(typeof(RevitLinkType)).Cast<RevitLinkType>().FirstOrDefault(lt => lt.Name == \"Structure_LINK.rvt\");\nif (linkType != null)\n{\n    linkType.Reload();\n    TaskDialog.Show(\"Success\", \"The link 'Structure_LINK.rvt' has been reloaded.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Revit link 'Structure_LINK.rvt' not found.\");\n}"}
{"prompt":"Crea una vista de planta para el 'Nivel 3'.","completion":"string levelName = \"Nivel 3\";\nLevel level3 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == levelName) as Level;\nif (level3 == null)\n{\n    TaskDialog.Show(\"Error\", $\"No se encontró el nivel '{levelName}'.\");\n}\nelse\n{\n    ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.FloorPlan);\n    if (vft != null)\n    {\n        ViewPlan viewPlan = ViewPlan.Create(doc, vft.Id, level3.Id);\n        TaskDialog.Show(\"Éxito\", $\"Vista de planta creada para el nivel '{levelName}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró el tipo de familia de vista de planta.\");\n    }\n}"}
{"prompt":"Create a floor plan view for 'Level 3'.","completion":"string levelName = \"Level 3\";\nLevel level3 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == levelName) as Level;\nif (level3 == null)\n{\n    TaskDialog.Show(\"Error\", $\"Level '{levelName}' not found.\");\n}\nelse\n{\n    ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.FloorPlan);\n    if (vft != null)\n    {\n        ViewPlan viewPlan = ViewPlan.Create(doc, vft.Id, level3.Id);\n        TaskDialog.Show(\"Success\", $\"Floor plan view created for level '{levelName}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Floor Plan View Family Type not found.\");\n    }\n}"}

{"prompt":"Calcula y muestra el área total de todas las habitaciones.","completion":"double totalArea = 0.0;\nList<Room> rooms = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).WhereElementIsNotElementType().Cast<Room>().ToList();\nforeach (Room room in rooms)\n{\n    totalArea += room.Area;\n}\nTaskDialog.Show(\"Área Total de Habitaciones\", $\"Se encontraron {rooms.Count} habitaciones.\\nÁrea total: {UnitUtils.ConvertFromInternalUnits(totalArea, UnitTypeId.SquareMeters):F2} m²\");"}
{"prompt":"Calculate and display the total area of all rooms.","completion":"double totalArea = 0.0;\nList<Room> rooms = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).WhereElementIsNotElementType().Cast<Room>().ToList();\nforeach (Room room in rooms)\n{\n    totalArea += room.Area;\n}\nTaskDialog.Show(\"Total Room Area\", $\"Found {rooms.Count} rooms.\\nTotal area: {UnitUtils.ConvertFromInternalUnits(totalArea, UnitTypeId.SquareMeters):F2} m²\");"}
{"prompt":"Exporta una lista de familias y sus tipos a un archivo de texto.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"FamilyList.txt\");\nList<string> lines = new List<string>();\nList<Family> families = new FilteredElementCollector(doc).OfClass(typeof(Family)).Cast<Family>().ToList();\nforeach (Family fam in families)\n{\n    lines.Add($\"Familia: {fam.Name}\");\n    foreach (ElementId symbolId in fam.GetFamilySymbolIds())\n    {\n        FamilySymbol sym = doc.GetElement(symbolId) as FamilySymbol;\n        if(sym != null) lines.Add($\"\\tTipo: {sym.Name}\");\n    }\n}\nSystem.IO.File.WriteAllLines(filePath, lines);\nTaskDialog.Show(\"Exportación Completa\", $\"{families.Count} familias exportadas a: {filePath}\");"}
{"prompt":"Export a list of families and their types to a text file.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"FamilyList.txt\");\nList<string> lines = new List<string>();\nList<Family> families = new FilteredElementCollector(doc).OfClass(typeof(Family)).Cast<Family>().ToList();\nforeach (Family fam in families)\n{\n    lines.Add($\"Family: {fam.Name}\");\n    foreach (ElementId symbolId in fam.GetFamilySymbolIds())\n    {\n        FamilySymbol sym = doc.GetElement(symbolId) as FamilySymbol;\n        if(sym != null) lines.Add($\"\\tType: {sym.Name}\");\n    }\n}\nSystem.IO.File.WriteAllLines(filePath, lines);\nTaskDialog.Show(\"Export Complete\", $\"{families.Count} families exported to: {filePath}\");"}
{"prompt":"Cambia un panel de vidrio de un muro cortina por un panel sólido.","completion":"Wall curtainWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.WallType.Kind == WallKind.Curtain) as Wall;\nPanelType solidPanelType = new FilteredElementCollector(doc).OfClass(typeof(PanelType)).Cast<PanelType>().FirstOrDefault(pt => pt.Name.Contains(\"Solid\") || pt.Name.Contains(\"Sólido\"));\nif (curtainWall != null && solidPanelType != null)\n{\n    CurtainGrid grid = curtainWall.CurtainGrid;\n    ICollection<ElementId> panelIds = grid.GetPanelIds();\n    if(panelIds.Any()){\n        Panel panelToChange = doc.GetElement(panelIds.First()) as Panel;\n        if (panelToChange != null) panelToChange.ChangeTypeId(solidPanelType.Id);\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", \"El muro cortina seleccionado no tiene paneles.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró un muro cortina o un tipo de panel sólido.\");\n}"}
{"prompt":"Change a glass panel in a curtain wall to a solid panel.","completion":"Wall curtainWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.WallType.Kind == WallKind.Curtain) as Wall;\nPanelType solidPanelType = new FilteredElementCollector(doc).OfClass(typeof(PanelType)).Cast<PanelType>().FirstOrDefault(pt => pt.Name.Contains(\"Solid\"));\nif (curtainWall != null && solidPanelType != null)\n{\n    CurtainGrid grid = curtainWall.CurtainGrid;\n    ICollection<ElementId> panelIds = grid.GetPanelIds();\n    if(panelIds.Any()){\n        Panel panelToChange = doc.GetElement(panelIds.First()) as Panel;\n        if (panelToChange != null) panelToChange.ChangeTypeId(solidPanelType.Id);\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", \"The selected curtain wall has no panels.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A curtain wall or a solid panel type was not found.\");\n}"}
{"prompt":"Obtén las coordenadas del punto base y del punto de reconocimiento.","completion":"BasePoint surveyPoint = new FilteredElementCollector(doc).OfClass(typeof(BasePoint)).Cast<BasePoint>().FirstOrDefault(p => p.IsSurveyPoint);\nBasePoint projectBasePoint = new FilteredElementCollector(doc).OfClass(typeof(BasePoint)).Cast<BasePoint>().FirstOrDefault(p => !p.IsSurveyPoint);\nif(surveyPoint != null && projectBasePoint != null)\n{\n    XYZ surveyCoords = surveyPoint.Position;\n    XYZ projectCoords = projectBasePoint.Position;\n    TaskDialog.Show(\"Coordenadas de Puntos Base\", $\"Punto de Levantamiento (Survey Point): {surveyCoords}\\nPunto Base del Proyecto (Project Base Point): {projectCoords}\");\n}"}
{"prompt":"Get the coordinates of the project base point and the survey point.","completion":"BasePoint surveyPoint = new FilteredElementCollector(doc).OfClass(typeof(BasePoint)).Cast<BasePoint>().FirstOrDefault(p => p.IsSurveyPoint);\nBasePoint projectBasePoint = new FilteredElementCollector(doc).OfClass(typeof(BasePoint)).Cast<BasePoint>().FirstOrDefault(p => !p.IsSurveyPoint);\nif(surveyPoint != null && projectBasePoint != null)\n{\n    XYZ surveyCoords = surveyPoint.Position;\n    XYZ projectCoords = projectBasePoint.Position;\n    TaskDialog.Show(\"Base Point Coordinates\", $\"Survey Point: {surveyCoords}\\nProject Base Point: {projectCoords}\");\n}"}
{"prompt":"Crea una región rellena con un patrón de 'Concreto'.","completion":"FilledRegionType regionType = new FilteredElementCollector(doc).OfClass(typeof(FilledRegionType)).Cast<FilledRegionType>().FirstOrDefault(frt => frt.Name.Contains(\"Concrete\") || frt.Name.Contains(\"Concreto\"));\nif (regionType != null)\n{\n    CurveLoop profile = CurveLoop.CreateViaRectangle(new XYZ(0,0,0), new XYZ(5,5,0));\n    FilledRegion.Create(doc, regionType.Id, doc.ActiveView.Id, new List<CurveLoop>{profile});\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró un tipo de región rellena con el patrón 'Concreto'.\");\n}"}
{"prompt":"Create a filled region with a 'Concrete' pattern.","completion":"FilledRegionType regionType = new FilteredElementCollector(doc).OfClass(typeof(FilledRegionType)).Cast<FilledRegionType>().FirstOrDefault(frt => frt.Name.Contains(\"Concrete\"));\nif (regionType != null)\n{\n    CurveLoop profile = CurveLoop.CreateViaRectangle(new XYZ(0,0,0), new XYZ(5,5,0));\n    FilledRegion.Create(doc, regionType.Id, doc.ActiveView.Id, new List<CurveLoop>{profile});\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A filled region type with a 'Concrete' pattern was not found.\");\n}"}
{"prompt":"Encuentra el elemento de pórtico estructural con la marca 'B-101'.","completion":"string markValue = \"B-101\";\nElement framingElement = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsNotElementType().FirstOrDefault(e => e.get_Parameter(BuiltInParameter.ALL_MODEL_MARK).AsString() == markValue);\nif (framingElement != null)\n{\n    TaskDialog.Show(\"Elemento Encontrado\", $\"Se encontró el elemento con marca '{markValue}'. ID: {framingElement.Id}\");\n    UIDocument uidoc = new UIDocument(doc);\n    uidoc.Selection.SetElementIds(new List<ElementId>{framingElement.Id});\n}\nelse\n{\n    TaskDialog.Show(\"No Encontrado\", $\"No se encontró ningún elemento de pórtico estructural con la marca '{markValue}'.\");\n}"}
{"prompt":"Find the structural framing element with the mark 'B-101'.","completion":"string markValue = \"B-101\";\nElement framingElement = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsNotElementType().FirstOrDefault(e => e.get_Parameter(BuiltInParameter.ALL_MODEL_MARK).AsString() == markValue);\nif (framingElement != null)\n{\n    TaskDialog.Show(\"Element Found\", $\"Found element with mark '{markValue}'. ID: {framingElement.Id}\");\n    UIDocument uidoc = new UIDocument(doc);\n    uidoc.Selection.SetElementIds(new List<ElementId>{framingElement.Id});\n}\nelse\n{\n    TaskDialog.Show(\"Not Found\", $\"No structural framing element with mark '{markValue}' was found.\");\n}"}
{"prompt":"Crea una losa de cimentación de 20x15 metros.","completion":"Level foundationLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.IsGroundPlane) as Level;\nFloorType slabType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Cast<FloorType>().FirstOrDefault(ft => ft.Category.Id.IntegerValue == (int)BuiltInCategory.OST_StructuralFoundations);\nif(foundationLevel != null && slabType != null)\n{\n    XYZ p1 = new XYZ(0,0,0);\n    XYZ p2 = new XYZ(UnitUtils.ConvertToInternalUnits(20, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(15, UnitTypeId.Meters), 0);\n    CurveLoop profile = CurveLoop.CreateViaRectangle(p1, p2);\n    Floor.Create(doc, new List<CurveLoop>{profile}, slabType.Id, foundationLevel.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un nivel de cimentación y un tipo de suelo estructural.\");\n}"}
{"prompt":"Create a 20x15 meter foundation slab.","completion":"Level foundationLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.IsGroundPlane) as Level;\nFloorType slabType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Cast<FloorType>().FirstOrDefault(ft => ft.Category.Id.IntegerValue == (int)BuiltInCategory.OST_StructuralFoundations);\nif(foundationLevel != null && slabType != null)\n{\n    XYZ p1 = new XYZ(0,0,0);\n    XYZ p2 = new XYZ(UnitUtils.ConvertToInternalUnits(20, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(15, UnitTypeId.Meters), 0);\n    CurveLoop profile = CurveLoop.CreateViaRectangle(p1, p2);\n    Floor.Create(doc, new List<CurveLoop>{profile}, slabType.Id, foundationLevel.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A foundation level and a structural floor type are required.\");\n}"}
{"prompt":"Añade montantes a todas las líneas de rejilla de un muro cortina.","completion":"Wall curtainWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.WallType.Kind == WallKind.Curtain) as Wall;\nMullionType mullionType = new FilteredElementCollector(doc).OfClass(typeof(MullionType)).FirstOrDefault() as MullionType;\nif (curtainWall != null && mullionType != null)\n{\n    CurtainGrid grid = curtainWall.CurtainGrid;\n    foreach (ElementId gridLineId in grid.GetVGridLineIds())\n    {\n        CurtainGridLine line = doc.GetElement(gridLineId) as CurtainGridLine;\n        if(line != null && !line.MullionOnLine) line.AddMullions(mullionType, false);\n    }\n    foreach (ElementId gridLineId in grid.GetUGridLineIds())\n    {\n        CurtainGridLine line = doc.GetElement(gridLineId) as CurtainGridLine;\n        if(line != null && !line.MullionOnLine) line.AddMullions(mullionType, false);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró un muro cortina o un tipo de montante.\");\n}"}
{"prompt":"Add mullions to all grid lines of a curtain wall.","completion":"Wall curtainWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.WallType.Kind == WallKind.Curtain) as Wall;\nMullionType mullionType = new FilteredElementCollector(doc).OfClass(typeof(MullionType)).FirstOrDefault() as MullionType;\nif (curtainWall != null && mullionType != null)\n{\n    CurtainGrid grid = curtainWall.CurtainGrid;\n    foreach (ElementId gridLineId in grid.GetVGridLineIds())\n    {\n        CurtainGridLine line = doc.GetElement(gridLineId) as CurtainGridLine;\n        if(line != null && !line.MullionOnLine) line.AddMullions(mullionType, false);\n    }\n    foreach (ElementId gridLineId in grid.GetUGridLineIds())\n    {\n        CurtainGridLine line = doc.GetElement(gridLineId) as CurtainGridLine;\n        if(line != null && !line.MullionOnLine) line.AddMullions(mullionType, false);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A curtain wall or a mullion type was not found.\");\n}"}
{"prompt":"Rota el elemento seleccionado 45 grados alrededor de su centro.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un elemento para rotar\");\nif (pickedRef != null)\n{\n    Element elem = doc.GetElement(pickedRef.ElementId);\n    LocationPoint lp = elem.Location as LocationPoint;\n    if (lp != null)\n    {\n        Line axis = Line.CreateBound(lp.Point, lp.Point + XYZ.BasisZ);\n        double angle = 45 * Math.PI / 180.0;\n        ElementTransformUtils.RotateElement(doc, elem.Id, axis, angle);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no tiene un punto de ubicación para rotar (ej. un muro).\");\n    }\n}"}
{"prompt":"Rotate the selected element 45 degrees about its center.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select an element to rotate\");\nif (pickedRef != null)\n{\n    Element elem = doc.GetElement(pickedRef.ElementId);\n    LocationPoint lp = elem.Location as LocationPoint;\n    if (lp != null)\n    {\n        Line axis = Line.CreateBound(lp.Point, lp.Point + XYZ.BasisZ);\n        double angle = 45 * Math.PI / 180.0;\n        ElementTransformUtils.RotateElement(doc, elem.Id, axis, angle);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element does not have a location point to rotate around (e.g. a wall).\");\n    }\n}"}
{"prompt":"Crea una apertura de hueco (shaft) que atraviese desde el Nivel 1 al Nivel 3.","completion":"Level bottomLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nLevel topLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 3\") as Level;\nif(bottomLevel != null && topLevel != null)\n{\n    XYZ p1 = new XYZ(5,5,0);\n    XYZ p2 = new XYZ(8,8,0);\n    CurveLoop profile = CurveLoop.CreateViaRectangle(p1, p2);\n    doc.Create.NewOpening(bottomLevel, topLevel, profile, true);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron los niveles 'Nivel 1' o 'Nivel 3'.\");\n}"}
{"prompt":"Create a shaft opening that passes through from Level 1 to Level 3.","completion":"Level bottomLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nLevel topLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 3\") as Level;\nif(bottomLevel != null && topLevel != null)\n{\n    XYZ p1 = new XYZ(5,5,0);\n    XYZ p2 = new XYZ(8,8,0);\n    CurveLoop profile = CurveLoop.CreateViaRectangle(p1, p2);\n    doc.Create.NewOpening(bottomLevel, topLevel, profile, true);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Level 1' or 'Level 3' not found.\");\n}"}
{"prompt":"Muestra un cuadro de diálogo con opciones 'Sí' y 'No'.","completion":"TaskDialog mainDialog = new TaskDialog(\"Confirmación\");\nmainDialog.MainInstruction = \"¿Desea proceder con la operación?\";\nmainDialog.CommonButtons = TaskDialogCommonButtons.Yes | TaskDialogCommonButtons.No;\nTaskDialogResult result = mainDialog.Show();"}
{"prompt":"Display a dialog box with 'Yes' and 'No' options.","completion":"TaskDialog mainDialog = new TaskDialog(\"Confirmation\");\nmainDialog.MainInstruction = \"Do you want to proceed with the operation?\";\nmainDialog.CommonButtons = TaskDialogCommonButtons.Yes | TaskDialogCommonButtons.No;\nTaskDialogResult result = mainDialog.Show();"}
{"prompt":"Sincroniza el modelo local con el central, añadiendo el comentario 'Actualización de diseño'.","completion":"if(doc.IsWorkshared)\n{\n    TransactWithCentralOptions tco = new TransactWithCentralOptions();\n    SynchronizeWithCentralOptions swcOpts = new SynchronizeWithCentralOptions();\n    swcOpts.SetComment(\"Actualización de diseño\");\n    swcOpts.SaveLocalAfter = true;\n    doc.SyncWithCentral(tco, swcOpts);\n    TaskDialog.Show(\"Sincronización\", \"Modelo sincronizado con el central.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Esta acción requiere un modelo compartido (Workshared).\");\n}"}
{"prompt":"Synchronize the local model with the central model, adding the comment 'Design update'.","completion":"if(doc.IsWorkshared)\n{\n    TransactWithCentralOptions tco = new TransactWithCentralOptions();\n    SynchronizeWithCentralOptions swcOpts = new SynchronizeWithCentralOptions();\n    swcOpts.SetComment(\"Design update\");\n    swcOpts.SaveLocalAfter = true;\n    doc.SyncWithCentral(tco, swcOpts);\n    TaskDialog.Show(\"Synchronization\", \"Model synchronized with central.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"This action requires a workshared model.\");\n}"}
{"prompt":"Obtén la curva del modelo analítico de una viga.","completion":"FamilyInstance beam = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsNotElementType().FirstOrDefault() as FamilyInstance;\nif (beam != null)\n{\n    AnalyticalModel am = beam.GetAnalyticalModel();\n    if (am != null && am.IsSingleCurve())\n    {\n        Curve analyticalCurve = am.GetCurve();\n        TaskDialog.Show(\"Resultado\", \"Se obtuvo la curva analítica de la viga.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", \"La viga seleccionada no tiene un modelo analítico de curva única.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron vigas en el proyecto.\");\n}"}
{"prompt":"Get the analytical model curve of a beam.","completion":"FamilyInstance beam = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsNotElementType().FirstOrDefault() as FamilyInstance;\nif (beam != null)\n{\n    AnalyticalModel am = beam.GetAnalyticalModel();\n    if (am != null && am.IsSingleCurve())\n    {\n        Curve analyticalCurve = am.GetCurve();\n        TaskDialog.Show(\"Result\", \"Analytical curve of the beam has been retrieved.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", \"The selected beam does not have a single-curve analytical model.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No beams found in the project.\");\n}"}
{"prompt":"Crea una nota de texto con una flecha apuntando a un elemento seleccionado.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference target = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un elemento para anotar\");\nif(target != null)\n{\n    XYZ textLocation = uidoc.Selection.PickPoint(\"Elige la ubicación del texto\");\n    TextNoteOptions opts = new TextNoteOptions(doc.GetDefaultElementTypeId(ElementTypeGroup.TextNoteType));\n    opts.HorizontalAlignment = HorizontalTextAlignment.Left;\n    TextNote note = TextNote.Create(doc, doc.ActiveView.Id, textLocation, \"Revisar este elemento\", opts);\n    note.AddLeader(TextNoteLeaderTypes.TNLT_STRAIGHT_L, target.GlobalPoint);\n}"}
{"prompt":"Create a text note with a leader pointing to a selected element.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference target = uidoc.Selection.PickObject(ObjectType.Element, \"Select an element to annotate\");\nif(target != null)\n{\n    XYZ textLocation = uidoc.Selection.PickPoint(\"Choose the text location\");\n    TextNoteOptions opts = new TextNoteOptions(doc.GetDefaultElementTypeId(ElementTypeGroup.TextNoteType));\n    opts.HorizontalAlignment = HorizontalTextAlignment.Left;\n    TextNote note = TextNote.Create(doc, doc.ActiveView.Id, \"Review this element\", textLocation, opts);\n    note.AddLeader(TextNoteLeaderTypes.TNLT_STRAIGHT_L, target.GlobalPoint);\n}"}
{"prompt":"Conecta dos bandejas de cables con un codo.","completion":"List<CableTray> trays = new FilteredElementCollector(doc).OfClass(typeof(CableTray)).Take(2).ToList();\nif (trays.Count == 2)\n{\n    Connector c1 = trays[0].ConnectorManager.UnusedConnectors.Cast<Connector>().FirstOrDefault();\n    Connector c2 = trays[1].ConnectorManager.UnusedConnectors.Cast<Connector>().FirstOrDefault();\n    if (c1 != null && c2 != null) \n    {\n        doc.Create.NewUnionFitting(c1, c2);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontraron conectores libres en una o ambas bandejas.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesitan al menos dos bandejas de cables en el proyecto.\");\n}"}
{"prompt":"Connect two cable trays with an elbow fitting.","completion":"List<CableTray> trays = new FilteredElementCollector(doc).OfClass(typeof(CableTray)).Take(2).ToList();\nif (trays.Count == 2)\n{\n    Connector c1 = trays[0].ConnectorManager.UnusedConnectors.Cast<Connector>().FirstOrDefault();\n    Connector c2 = trays[1].ConnectorManager.UnusedConnectors.Cast<Connector>().FirstOrDefault();\n    if (c1 != null && c2 != null) \n    {\n        doc.Create.NewUnionFitting(c1, c2);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Could not find unused connectors on one or both trays.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"At least two cable trays are needed in the project.\");\n}"}
{"prompt":"Crea una vista 3D axonométrica orientada al Noroeste.","completion":"ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.ThreeDimensional);\nif(vft != null)\n{\n    View3D view3d = View3D.CreateIsometric(doc, vft.Id);\n    XYZ eye = new XYZ(-1, 1, 1);\n    XYZ up = new XYZ(0, 0, 1);\n    XYZ forward = new XYZ(1, -1, -1);\n    view3d.SetOrientation(new ViewOrientation3D(eye, up, forward));\n    view3d.Name = \"Vista 3D Noroeste\";\n}"}
{"prompt":"Create an axonometric 3D view oriented to the Northwest.","completion":"ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.ThreeDimensional);\nif(vft != null)\n{\n    View3D view3d = View3D.CreateIsometric(doc, vft.Id);\n    XYZ eye = new XYZ(-1, 1, 1);\n    XYZ up = new XYZ(0, 0, 1);\n    XYZ forward = new XYZ(1, -1, -1);\n    view3d.SetOrientation(new ViewOrientation3D(eye, up, forward));\n    view3d.Name = \"3D View Northwest\";\n}"}
{"prompt":"Encuentra todas las puertas en el Nivel 1 usando un filtro combinado.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nif(level1 != null)\n{\n    ElementCategoryFilter categoryFilter = new ElementCategoryFilter(BuiltInCategory.OST_Doors);\n    ElementLevelFilter levelFilter = new ElementLevelFilter(level1.Id);\n    LogicalAndFilter combinedFilter = new LogicalAndFilter(categoryFilter, levelFilter);\n    List<Element> doors = new FilteredElementCollector(doc).WherePasses(combinedFilter).ToList();\n    TaskDialog.Show(\"Resultado\", $\"Se encontraron {doors.Count} puertas en el Nivel 1.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el 'Nivel 1'.\");\n}"}
{"prompt":"Find all doors on Level 1 using a combined filter.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nif(level1 != null)\n{\n    ElementCategoryFilter categoryFilter = new ElementCategoryFilter(BuiltInCategory.OST_Doors);\n    ElementLevelFilter levelFilter = new ElementLevelFilter(level1.Id);\n    LogicalAndFilter combinedFilter = new LogicalAndFilter(categoryFilter, levelFilter);\n    List<Element> doors = new FilteredElementCollector(doc).WherePasses(combinedFilter).ToList();\n    TaskDialog.Show(\"Result\", $\"Found {doors.Count} doors on Level 1.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Level 1' not found.\");\n}"}
{"prompt":"Crea un texto de modelo 3D que diga 'TORRE A'.","completion":"Level baseLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.IsGroundPlane) as Level;\nif(baseLevel != null)\n{\n    XYZ origin = new XYZ(0,0,baseLevel.Elevation);\n    Plane plane = Plane.CreateByNormalAndOrigin(XYZ.BasisY, origin);\n    SketchPlane sp = SketchPlane.Create(doc, plane);\n    if(sp != null) ModelText.Create(doc, \"TORRE A\", sp.GetPlane(), origin, UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters));\n}"}
{"prompt":"Create a 3D model text that says 'TOWER A'.","completion":"Level baseLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.IsGroundPlane) as Level;\nif(baseLevel != null)\n{\n    XYZ origin = new XYZ(0,0,baseLevel.Elevation);\n    Plane plane = Plane.CreateByNormalAndOrigin(XYZ.BasisY, origin);\n    SketchPlane sp = SketchPlane.Create(doc, plane);\n    if(sp != null) ModelText.Create(doc, \"TOWER A\", sp.GetPlane(), origin, UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters));\n}"}
{"prompt":"Exporta todas las advertencias del proyecto a un archivo de texto.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"ProjectWarnings.txt\");\nIList<FailureMessage> warnings = doc.GetWarnings();\nif (warnings.Any())\n{\n    List<string> warningDescriptions = warnings.Select(w => w.GetDescriptionText()).ToList();\n    System.IO.File.WriteAllLines(filePath, warningDescriptions);\n    TaskDialog.Show(\"Exportación Completa\", $\"{warnings.Count} advertencias exportadas a: {filePath}\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"El proyecto no tiene advertencias.\");\n}"}
{"prompt":"Export all project warnings to a text file.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"ProjectWarnings.txt\");\nIList<FailureMessage> warnings = doc.GetWarnings();\nif (warnings.Any())\n{\n    List<string> warningDescriptions = warnings.Select(w => w.GetDescriptionText()).ToList();\n    System.IO.File.WriteAllLines(filePath, warningDescriptions);\n    TaskDialog.Show(\"Export Complete\", $\"{warnings.Count} warnings exported to: {filePath}\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"The project has no warnings.\");\n}"}
{"prompt":"Agrupa una tabla de planificación de habitaciones por Nivel.","completion":"ViewSchedule schedule = new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Cast<ViewSchedule>().FirstOrDefault(vs => vs.Definition.CategoryId.IntegerValue == (int)BuiltInCategory.OST_Rooms);\nif (schedule != null)\n{\n    ScheduleDefinition def = schedule.Definition;\n    SchedulableField levelField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.ROOM_LEVEL_ID);\n    if(levelField != null)\n    {\n        ScheduleSortGroupField sortGroupField = new ScheduleSortGroupField(levelField.FieldId);\n        sortGroupField.ShowHeader = true;\n        def.AddSortGroupField(sortGroupField);\n        def.IsItemized = false;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se pudo encontrar el campo 'Nivel' en la tabla.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró una tabla de planificación de habitaciones.\");\n}"}
{"prompt":"Group a room schedule by Level.","completion":"ViewSchedule schedule = new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Cast<ViewSchedule>().FirstOrDefault(vs => vs.Definition.CategoryId.IntegerValue == (int)BuiltInCategory.OST_Rooms);\nif (schedule != null)\n{\n    ScheduleDefinition def = schedule.Definition;\n    SchedulableField levelField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.ROOM_LEVEL_ID);\n    if(levelField != null)\n    {\n        ScheduleSortGroupField sortGroupField = new ScheduleSortGroupField(levelField.FieldId);\n        sortGroupField.ShowHeader = true;\n        def.AddSortGroupField(sortGroupField);\n        def.IsItemized = false;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Could not find the 'Level' field in the schedule.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A room schedule was not found.\");\n}"}
{"prompt":"Obtén todos los muros de un modelo vinculado que se cruzan con una caja de delimitación.","completion":"RevitLinkInstance linkInstance = new FilteredElementCollector(doc).OfClass(typeof(RevitLinkInstance)).FirstOrDefault() as RevitLinkInstance;\nif (linkInstance != null)\n{\n    Document linkDoc = linkInstance.GetLinkDocument();\n    if (linkDoc != null)\n    {\n        BoundingBoxXYZ bbox = new BoundingBoxXYZ();\n        bbox.Min = new XYZ(0,0,0);\n        bbox.Max = new XYZ(50,50,10);\n        BoundingBoxIntersectsFilter filter = new BoundingBoxIntersectsFilter(new Outline(bbox.Min, bbox.Max));\n        List<Element> linkedWalls = new FilteredElementCollector(linkDoc).OfClass(typeof(Wall)).WherePasses(filter).ToList();\n        TaskDialog.Show(\"Resultado\", $\"Se encontraron {linkedWalls.Count} muros en el vínculo que se cruzan con la caja.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron vínculos de Revit en el proyecto.\");\n}"}
{"prompt":"Get all walls from a linked model that intersect with a bounding box.","completion":"RevitLinkInstance linkInstance = new FilteredElementCollector(doc).OfClass(typeof(RevitLinkInstance)).FirstOrDefault() as RevitLinkInstance;\nif (linkInstance != null)\n{\n    Document linkDoc = linkInstance.GetLinkDocument();\n    if (linkDoc != null)\n    {\n        BoundingBoxXYZ bbox = new BoundingBoxXYZ();\n        bbox.Min = new XYZ(0,0,0);\n        bbox.Max = new XYZ(50,50,10);\n        BoundingBoxIntersectsFilter filter = new BoundingBoxIntersectsFilter(new Outline(bbox.Min, bbox.Max));\n        List<Element> linkedWalls = new FilteredElementCollector(linkDoc).OfClass(typeof(Wall)).WherePasses(filter).ToList();\n        TaskDialog.Show(\"Result\", $\"Found {linkedWalls.Count} walls in the link intersecting the box.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No Revit links found in the project.\");\n}"}
{"prompt":"Desune la geometría de dos elementos previamente unidos.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference ref1 = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona el primer elemento\");\nif(ref1 == null) return;\nReference ref2 = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona el segundo elemento\");\nif(ref2 == null) return;\nElement e1 = doc.GetElement(ref1.ElementId);\nElement e2 = doc.GetElement(ref2.ElementId);\nif (e1 != null && e2 != null && JoinGeometryUtils.AreElementsJoined(doc, e1, e2))\n{\n    JoinGeometryUtils.UnjoinGeometry(doc, e1, e2);\n    TaskDialog.Show(\"Éxito\", \"La geometría ha sido desunida.\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"Los elementos no estaban unidos.\");\n}"}
{"prompt":"Unjoin the geometry of two previously joined elements.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference ref1 = uidoc.Selection.PickObject(ObjectType.Element, \"Select the first element\");\nif(ref1 == null) return;\nReference ref2 = uidoc.Selection.PickObject(ObjectType.Element, \"Select the second element\");\nif(ref2 == null) return;\nElement e1 = doc.GetElement(ref1.ElementId);\nElement e2 = doc.GetElement(ref2.ElementId);\nif (e1 != null && e2 != null && JoinGeometryUtils.AreElementsJoined(doc, e1, e2))\n{\n    JoinGeometryUtils.UnjoinGeometry(doc, e1, e2);\n    TaskDialog.Show(\"Success\", \"Geometry has been unjoined.\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"The elements were not joined.\");\n}"}
{"prompt":"Coloca una cota de elevación en la cara superior de un suelo.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference faceRef = uidoc.Selection.PickObject(ObjectType.Face, \"Selecciona la cara superior del suelo\");\nif(faceRef != null)\n{\n    XYZ pointOnFace = faceRef.GlobalPoint;\n    XYZ leaderEnd = pointOnFace + new XYZ(1,1,0);\n    doc.Create.NewSpotElevation(doc.ActiveView, faceRef, pointOnFace, pointOnFace, leaderEnd, true, true);\n}"}
{"prompt":"Place a spot elevation on the top face of a floor.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference faceRef = uidoc.Selection.PickObject(ObjectType.Face, \"Select the top face of the floor\");\nif(faceRef != null)\n{\n    XYZ pointOnFace = faceRef.GlobalPoint;\n    XYZ leaderEnd = pointOnFace + new XYZ(1,1,0);\n    doc.Create.NewSpotElevation(doc.ActiveView, faceRef, pointOnFace, pointOnFace, leaderEnd, true, true);\n}"}
{"prompt":"Verifica si una tubería está conectada en ambos extremos.","completion":"Pipe pipe = new FilteredElementCollector(doc).OfClass(typeof(Pipe)).FirstOrDefault() as Pipe;\nif(pipe != null)\n{\n    bool isFullyConnected = pipe.ConnectorManager.UnusedConnectors.IsEmpty;\n    TaskDialog.Show(\"Conectividad de Tubería\", \"La tubería está completamente conectada: \" + isFullyConnected);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron tuberías en el proyecto.\");\n}"}
{"prompt":"Check if a pipe is connected at both ends.","completion":"Pipe pipe = new FilteredElementCollector(doc).OfClass(typeof(Pipe)).FirstOrDefault() as Pipe;\nif(pipe != null)\n{\n    bool isFullyConnected = pipe.ConnectorManager.UnusedConnectors.IsEmpty;\n    TaskDialog.Show(\"Pipe Connectivity\", \"The pipe is fully connected: \" + isFullyConnected);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No pipes found in the project.\");\n}"}
{"prompt":"Dentro del editor de familias, crea un plano de referencia vertical llamado 'Eje Central'.","completion":"if(doc.IsFamilyDocument)\n{\n    string rpName = \"Eje Central\";\n    ReferencePlane existingRp = new FilteredElementCollector(doc).OfClass(typeof(ReferencePlane)).Cast<ReferencePlane>().FirstOrDefault(rp => rp.Name == rpName);\n    if (existingRp == null)\n    {\n        XYZ start = new XYZ(0, -5, 0);\n        XYZ end = new XYZ(0, 5, 0);\n        XYZ normal = start.CrossProduct(end);\n        ReferencePlane rp = doc.FamilyCreate.NewReferencePlane(start, end, normal, doc.ActiveView);\n        rp.Name = rpName;\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error de Contexto\", \"Este comando solo funciona dentro del Editor de Familias.\");\n}"}
{"prompt":"Inside the family editor, create a vertical reference plane named 'Center Axis'.","completion":"if(doc.IsFamilyDocument)\n{\n    string rpName = \"Center Axis\";\n    ReferencePlane existingRp = new FilteredElementCollector(doc).OfClass(typeof(ReferencePlane)).Cast<ReferencePlane>().FirstOrDefault(rp => rp.Name == rpName);\n    if (existingRp == null)\n    {\n        XYZ start = new XYZ(0, -5, 0);\n        XYZ end = new XYZ(0, 5, 0);\n        XYZ normal = start.CrossProduct(end);\n        ReferencePlane rp = doc.FamilyCreate.NewReferencePlane(start, end, normal, doc.ActiveView);\n        rp.Name = rpName;\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Context Error\", \"This command only works inside the Family Editor.\");\n}"}

{"prompt":"Averigua quién es el propietario de un elemento seleccionado.","completion":"if(doc.IsWorkshared)\n{\n    UIDocument uidoc = new UIDocument(doc);\n    Reference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un elemento\");\n    if(pickedRef != null)\n    {\n        Element elem = doc.GetElement(pickedRef.ElementId);\n        if(elem != null)\n        {\n            WorksharingTooltipInfo info = WorksharingUtils.GetWorksharingTooltipInfo(doc, elem.Id);\n            TaskDialog.Show(\"Propietario del Elemento\", $\"Propietario: {info.Owner}\\nCreador: {info.Creator}\\nÚltimo en modificar: {info.LastChangedBy}\");\n        }\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Esta acción requiere un modelo compartido (Workshared).\");\n}"}
{"prompt":"Find out who the owner of a selected element is.","completion":"if(doc.IsWorkshared)\n{\n    UIDocument uidoc = new UIDocument(doc);\n    Reference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select an element\");\n    if(pickedRef != null)\n    {\n        Element elem = doc.GetElement(pickedRef.ElementId);\n        if(elem != null)\n        {\n            WorksharingTooltipInfo info = WorksharingUtils.GetWorksharingTooltipInfo(doc, elem.Id);\n            TaskDialog.Show(\"Element Owner\", $\"Owner: {info.Owner}\\nCreator: {info.Creator}\\nLast changed by: {info.LastChangedBy}\");\n        }\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"This action requires a workshared model.\");\n}"}
{"prompt":"Aísla temporalmente un elemento seleccionado.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> idsToIsolate = uidoc.Selection.GetElementIds();\nif (idsToIsolate.Any())\n{\n    doc.ActiveView.IsolateElementsTemporary(idsToIsolate);\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No había elementos seleccionados para aislar.\");\n}"}
{"prompt":"Temporarily isolate a selected element.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> idsToIsolate = uidoc.Selection.GetElementIds();\nif (idsToIsolate.Any())\n{\n    doc.ActiveView.IsolateElementsTemporary(idsToIsolate);\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No elements were selected to isolate.\");\n}"}
{"prompt":"Crea un componente de detalle repetitivo a lo largo de una línea.","completion":"DetailComponentType dct = new FilteredElementCollector(doc).OfClass(typeof(DetailComponentType)).FirstOrDefault() as DetailComponentType;\nif (dct != null)\n{\n    Line path = Line.CreateBound(new XYZ(0,0,0), new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters),0,0));\n    RepeatingDetailComponent.Create(doc, doc.ActiveView.Id, dct.Id, path);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron tipos de componente de detalle en el proyecto.\");\n}"}
{"prompt":"Create a repeating detail component along a line.","completion":"DetailComponentType dct = new FilteredElementCollector(doc).OfClass(typeof(DetailComponentType)).FirstOrDefault() as DetailComponentType;\nif (dct != null)\n{\n    Line path = Line.CreateBound(new XYZ(0,0,0), new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters),0,0));\n    RepeatingDetailComponent.Create(doc, doc.ActiveView.Id, dct.Id, path);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No detail component types were found in the project.\");\n}"}
{"prompt":"Crea un nuevo panel en la cinta de opciones llamado 'Mis Herramientas' con un botón.","completion":"TaskDialog.Show(\"Acción no soportada\", \"La creación de paneles y botones en la cinta de opciones (Ribbon) no se puede realizar en tiempo real. Requiere la programación de un complemento de Revit (IExternalApplication) y reiniciar Revit para ver los cambios.\");"}
{"prompt":"Create a new Ribbon panel named 'My Tools' with a button.","completion":"TaskDialog.Show(\"Unsupported Action\", \"Creating Ribbon panels and buttons cannot be done in real-time. It requires programming a Revit Add-in (IExternalApplication) and restarting Revit to see the changes.\");"}
{"prompt":"Cambia el tipo de una losa por uno que contenga 'Concreto'.","completion":"Floor floorToChange = new FilteredElementCollector(doc).OfClass(typeof(Floor)).FirstOrDefault() as Floor;\nFloorType newType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Cast<FloorType>().FirstOrDefault(ft => ft.Name.Contains(\"Concreto\") || ft.Name.Contains(\"Concrete\"));\nif(floorToChange != null && newType != null)\n{\n    floorToChange.ChangeTypeId(newType.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró una losa para cambiar o un tipo de losa de concreto.\");\n}"}
{"prompt":"Change the type of a floor to one that contains 'Concrete'.","completion":"Floor floorToChange = new FilteredElementCollector(doc).OfClass(typeof(Floor)).FirstOrDefault() as Floor;\nFloorType newType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Cast<FloorType>().FirstOrDefault(ft => ft.Name.Contains(\"Concrete\"));\nif(floorToChange != null && newType != null)\n{\n    floorToChange.ChangeTypeId(newType.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Could not find a floor to change or a concrete floor type.\");\n}"}
{"prompt":"Obtén todas las subcategorías de la categoría Muros.","completion":"Category wallCat = doc.Settings.Categories.get_Item(BuiltInCategory.OST_Walls);\nif (wallCat != null)\n{\n    CategoryNameMap subcategories = wallCat.SubCategories;\n    StringBuilder sb = new StringBuilder($\"Subcategorías de Muros ({subcategories.Size}):\\n\");\n    foreach(Category subcat in subcategories)\n    {\n        sb.AppendLine(\"- \" + subcat.Name);\n    }\n    TaskDialog.Show(\"Subcategorías\", sb.ToString());\n}"}
{"prompt":"Get all subcategories from the Walls category.","completion":"Category wallCat = doc.Settings.Categories.get_Item(BuiltInCategory.OST_Walls);\nif (wallCat != null)\n{\n    CategoryNameMap subcategories = wallCat.SubCategories;\n    StringBuilder sb = new StringBuilder($\"Wall Subcategories ({subcategories.Size}):\\n\");\n    foreach(Category subcat in subcategories)\n    {\n        sb.AppendLine(\"- \" + subcat.Name);\n    }\n    TaskDialog.Show(\"Subcategories\", sb.ToString());\n}"}
{"prompt":"Crea un parámetro de proyecto de tipo URL llamado 'Enlace a Especificaciones'.","completion":"string paramName = \"Enlace a Especificaciones\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ParameterElement)).Any(p => p.Name == paramName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El parámetro '{paramName}' ya existe.\");\n}\nelse\n{\n    DefinitionFile defFile = doc.Application.OpenSharedParameterFile();\n    if (defFile == null || !System.IO.File.Exists(defFile.Filename))\n    {\n        TaskDialog.Show(\"Error\", \"Se necesita un archivo de parámetros compartidos configurado en Revit.\");\n    }\n    else\n    {\n        DefinitionGroup group = defFile.Groups.get_Item(\"Documentation\") ?? defFile.Groups.Create(\"Documentation\");\n        Definition definition = group.Definitions.get_Item(paramName) ?? group.Definitions.Create(new ExternalDefinitionCreationOptions(paramName, SpecTypeId.Url));\n        Category wallCat = doc.Settings.Categories.get_Item(BuiltInCategory.OST_Walls);\n        CategorySet catSet = doc.Application.Create.NewCategorySet();\n        catSet.Insert(wallCat);\n        doc.ParameterBindings.Insert(doc.Application.Create.NewInstanceBinding(catSet), (ExternalDefinition)definition, BuiltInParameterGroup.PG_DATA);\n        TaskDialog.Show(\"Éxito\", $\"Parámetro '{paramName}' creado y asignado a la categoría Muros.\");\n    }\n}"}
{"prompt":"Create a URL type project parameter named 'Link to Specifications'.","completion":"string paramName = \"Link to Specifications\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ParameterElement)).Any(p => p.Name == paramName))\n{\n    TaskDialog.Show(\"Warning\", $\"Parameter '{paramName}' already exists.\");\n}\nelse\n{\n    DefinitionFile defFile = doc.Application.OpenSharedParameterFile();\n    if (defFile == null || !System.IO.File.Exists(defFile.Filename))\n    {\n        TaskDialog.Show(\"Error\", \"A shared parameter file needs to be configured in Revit.\");\n    }\n    else\n    {\n        DefinitionGroup group = defFile.Groups.get_Item(\"Documentation\") ?? defFile.Groups.Create(\"Documentation\");\n        Definition definition = group.Definitions.get_Item(paramName) ?? group.Definitions.Create(new ExternalDefinitionCreationOptions(paramName, SpecTypeId.Url));\n        Category wallCat = doc.Settings.Categories.get_Item(BuiltInCategory.OST_Walls);\n        CategorySet catSet = doc.Application.Create.NewCategorySet();\n        catSet.Insert(wallCat);\n        doc.ParameterBindings.Insert(doc.Application.Create.NewInstanceBinding(catSet), (ExternalDefinition)definition, BuiltInParameterGroup.PG_DATA);\n        TaskDialog.Show(\"Success\", $\"Parameter '{paramName}' created and assigned to the Walls category.\");\n    }\n}"}
{"prompt":"Crea una nueva vista de alzado mirando al sur.","completion":"ViewFamilyType elevationVFT = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(vft => vft.ViewFamily == ViewFamily.Elevation);\nif(elevationVFT != null)\n{\n    ElevationMarker marker = ElevationMarker.CreateElevationMarker(doc, elevationVFT.Id, new XYZ(0, -20, 0), 100);\n    for (int i = 0; i < 4; i++)\n    {\n        View aev = marker.CreateElevation(doc, doc.ActiveView.Id, i);\n        if(i == 0) aev.Name = \"Alzado Sur\";\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el tipo de familia de vista de alzado.\");\n}"}
{"prompt":"Create a new elevation view looking south.","completion":"ViewFamilyType elevationVFT = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(vft => vft.ViewFamily == ViewFamily.Elevation);\nif(elevationVFT != null)\n{\n    ElevationMarker marker = ElevationMarker.CreateElevationMarker(doc, elevationVFT.Id, new XYZ(0, -20, 0), 100);\n    for (int i = 0; i < 4; i++)\n    {\n        View aev = marker.CreateElevation(doc, doc.ActiveView.Id, i);\n        if(i == 0) aev.Name = \"South Elevation\";\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Elevation View Family Type not found.\");\n}"}
{"prompt":"Exporta la geometría de un elemento seleccionado a un archivo SAT.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un elemento para exportar\");\nif (pickedRef != null)\n{\n    Element elem = doc.GetElement(pickedRef);\n    string folderPath = \"C:/RevitExports/\";\n    if(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\n    string fileName = elem.Name + \".sat\";\n    SATExportOptions options = new SATExportOptions();\n    doc.Export(folderPath, fileName, new List<ElementId>{elem.Id}, options);\n    TaskDialog.Show(\"Éxito\", $\"Geometría exportada a {folderPath}{fileName}\");\n}"}
{"prompt":"Export the geometry of a selected element to an SAT file.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select an element to export\");\nif (pickedRef != null)\n{\n    Element elem = doc.GetElement(pickedRef);\n    string folderPath = \"C:/RevitExports/\";\n    if(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\n    string fileName = elem.Name + \".sat\";\n    SATExportOptions options = new SATExportOptions();\n    doc.Export(folderPath, fileName, new List<ElementId>{elem.Id}, options);\n    TaskDialog.Show(\"Success\", $\"Geometry exported to {folderPath}{fileName}\");\n}"}
{"prompt":"Obtén el tipo de sistema de una tubería seleccionada.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona una tubería\");\nif (pickedRef != null)\n{\n    Pipe pipe = doc.GetElement(pickedRef.ElementId) as Pipe;\n    if(pipe != null)\n    {\n        PipingSystemType systemType = doc.GetElement(pipe.get_Parameter(BuiltInParameter.RBS_PIPING_SYSTEM_TYPE_PARAM).AsElementId()) as PipingSystemType;\n        if(systemType != null) TaskDialog.Show(\"Sistema de Tubería\", $\"El sistema de la tubería seleccionada es: '{systemType.Name}'\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no es una tubería.\");\n    }\n}"}
{"prompt":"Get the system type of a selected pipe.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a pipe\");\nif (pickedRef != null)\n{\n    Pipe pipe = doc.GetElement(pickedRef.ElementId) as Pipe;\n    if(pipe != null)\n    {\n        PipingSystemType systemType = doc.GetElement(pipe.get_Parameter(BuiltInParameter.RBS_PIPING_SYSTEM_TYPE_PARAM).AsElementId()) as PipingSystemType;\n        if(systemType != null) TaskDialog.Show(\"Piping System\", $\"The selected pipe's system is: '{systemType.Name}'\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element is not a pipe.\");\n    }\n}"}
{"prompt":"Crea un nuevo tipo de tubería con material de Cobre.","completion":"string newTypeName = \"Tubería de Cobre\";\nif (new FilteredElementCollector(doc).OfClass(typeof(PipeType)).Any(pt => pt.Name == newTypeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de tubería '{newTypeName}' ya existe.\");\n}\nelse\n{\n    PipeType pipeTypeToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(PipeType)).FirstOrDefault() as PipeType;\n    Material copper = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name.Contains(\"Copper\") || m.Name.Contains(\"Cobre\")) as Material;\n    if(pipeTypeToDuplicate != null && copper != null)\n    {\n        PipeType newType = pipeTypeToDuplicate.Duplicate(newTypeName) as PipeType;\n        newType.get_Parameter(BuiltInParameter.MATERIAL_ID_PARAM).Set(copper.Id);\n        TaskDialog.Show(\"Éxito\", $\"Tipo de tubería '{newTypeName}' creado.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Se necesita un tipo de tubería para duplicar y un material de cobre.\");\n    }\n}"}
{"prompt":"Create a new pipe type with Copper material.","completion":"string newTypeName = \"Copper Pipe\";\nif (new FilteredElementCollector(doc).OfClass(typeof(PipeType)).Any(pt => pt.Name == newTypeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Pipe type '{newTypeName}' already exists.\");\n}\nelse\n{\n    PipeType pipeTypeToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(PipeType)).FirstOrDefault() as PipeType;\n    Material copper = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name.Contains(\"Copper\")) as Material;\n    if(pipeTypeToDuplicate != null && copper != null)\n    {\n        PipeType newType = pipeTypeToDuplicate.Duplicate(newTypeName) as PipeType;\n        newType.get_Parameter(BuiltInParameter.MATERIAL_ID_PARAM).Set(copper.Id);\n        TaskDialog.Show(\"Success\", $\"Pipe type '{newTypeName}' created.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"A pipe type to duplicate and a copper material are required.\");\n    }\n}"}
{"prompt":"Oculta un elemento seleccionado en la vista activa.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> idsToHide = uidoc.Selection.GetElementIds();\nif(idsToHide.Any())\n{\n    doc.ActiveView.HideElements(idsToHide);\n}"}
{"prompt":"Hide a selected element in the active view.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> idsToHide = uidoc.Selection.GetElementIds();\nif(idsToHide.Any())\n{\n    doc.ActiveView.HideElements(idsToHide);\n}"}
{"prompt":"Cambia el nombre de la familia de una puerta seleccionada a 'Puerta_Nueva'.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona una puerta\");\nif (pickedRef != null)\n{\n    FamilyInstance door = doc.GetElement(pickedRef.ElementId) as FamilyInstance;\n    if(door != null && door.Category.Id.IntegerValue == (int)BuiltInCategory.OST_Doors)\n    {\n        Family family = door.Symbol.Family;\n        family.Name = \"Puerta_Nueva\";\n        TaskDialog.Show(\"Éxito\", $\"El nombre de la familia ha sido cambiado a '{family.Name}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no es una puerta.\");\n    }\n}"}
{"prompt":"Change the family name of a selected door to 'New_Door'.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a door\");\nif (pickedRef != null)\n{\n    FamilyInstance door = doc.GetElement(pickedRef.ElementId) as FamilyInstance;\n    if(door != null && door.Category.Id.IntegerValue == (int)BuiltInCategory.OST_Doors)\n    {\n        Family family = door.Symbol.Family;\n        family.Name = \"New_Door\";\n        TaskDialog.Show(\"Success\", $\"The family name has been changed to '{family.Name}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element is not a door.\");\n    }\n}"}
{"prompt":"Crea una nueva hoja A2 con el número 'A-201'.","completion":"string sheetNumber = \"A-201\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewSheet)).Cast<ViewSheet>().Any(s => s.SheetNumber == sheetNumber))\n{\n    TaskDialog.Show(\"Advertencia\", $\"Ya existe una hoja con el número '{sheetNumber}'.\");\n}\nelse\n{\n    FamilySymbol titleBlock = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_TitleBlocks).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\n    if (titleBlock != null)\n    {\n        ViewSheet sheet = ViewSheet.Create(doc, titleBlock.Id);\n        sheet.Name = \"Detalles Constructivos\";\n        sheet.SheetNumber = sheetNumber;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontraron familias de cajetín (Title Block) en el proyecto.\");\n    }\n}"}
{"prompt":"Create a new A2 sheet with the number 'A-201'.","completion":"string sheetNumber = \"A-201\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewSheet)).Cast<ViewSheet>().Any(s => s.SheetNumber == sheetNumber))\n{\n    TaskDialog.Show(\"Warning\", $\"A sheet with the number '{sheetNumber}' already exists.\");\n}\nelse\n{\n    FamilySymbol titleBlock = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_TitleBlocks).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\n    if (titleBlock != null)\n    {\n        ViewSheet sheet = ViewSheet.Create(doc, titleBlock.Id);\n        sheet.Name = \"Construction Details\";\n        sheet.SheetNumber = sheetNumber;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No Title Block families were found in the project.\");\n    }\n}"}
{"prompt":"Coloca todos los elementos seleccionados en el workset 'Fachada'.","completion":"if(doc.IsWorkshared)\n{\n    UIDocument uidoc = new UIDocument(doc);\n    Workset workset = new FilteredWorksetCollector(doc).OfKind(WorksetKind.UserWorkset).FirstOrDefault(ws => ws.Name == \"Fachada\");\n    if(workset == null) workset = Workset.Create(doc, \"Fachada\");\n    ICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\n    if(workset != null && selectedIds.Any())\n    {\n        WorksharingUtils.ChangeWorkset(doc, selectedIds, workset.Id);\n        TaskDialog.Show(\"Éxito\", $\"{selectedIds.Count} elementos asignados al workset '{workset.Name}'.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Esta acción requiere un modelo compartido (Workshared).\");\n}"}
{"prompt":"Place all selected elements on the 'Facade' workset.","completion":"if(doc.IsWorkshared)\n{\n    UIDocument uidoc = new UIDocument(doc);\n    Workset workset = new FilteredWorksetCollector(doc).OfKind(WorksetKind.UserWorkset).FirstOrDefault(ws => ws.Name == \"Facade\");\n    if(workset == null) workset = Workset.Create(doc, \"Facade\");\n    ICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\n    if(workset != null && selectedIds.Any())\n    {\n        WorksharingUtils.ChangeWorkset(doc, selectedIds, workset.Id);\n        TaskDialog.Show(\"Success\", $\"{selectedIds.Count} elements assigned to workset '{workset.Name}'.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"This action requires a workshared model.\");\n}"}
{"prompt":"Crea una nueva revisión y aplícala a la hoja activa.","completion":"string revDescription = \"Emitido para Construcción\";\nRevision rev = Revision.Create(doc);\nrev.Description = revDescription;\nrev.RevisionDate = DateTime.Now.ToString(\"yyyy-MM-dd\");\nrev.IssuedBy = \"Departamento BIM\";\nViewSheet sheet = doc.ActiveView as ViewSheet;\nif (sheet != null)\n{\n    ICollection<ElementId> revisions = sheet.GetAdditionalRevisionIds();\n    if(!revisions.Contains(rev.Id))\n    {\n        revisions.Add(rev.Id);\n        sheet.SetAdditionalRevisionIds(revisions);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"La vista activa debe ser una hoja para aplicar revisiones.\");\n}"}
{"prompt":"Create a new revision and apply it to the active sheet.","completion":"string revDescription = \"Issued for Construction\";\nRevision rev = Revision.Create(doc);\nrev.Description = revDescription;\nrev.RevisionDate = DateTime.Now.ToString(\"yyyy-MM-dd\");\nrev.IssuedBy = \"BIM Department\";\nViewSheet sheet = doc.ActiveView as ViewSheet;\nif (sheet != null)\n{\n    ICollection<ElementId> revisions = sheet.GetAdditionalRevisionIds();\n    if(!revisions.Contains(rev.Id))\n    {\n        revisions.Add(rev.Id);\n        sheet.SetAdditionalRevisionIds(revisions);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"The active view must be a sheet to apply revisions.\");\n}"}
{"prompt":"Crea una dimensión radial para un muro curvo.","completion":"Wall curvedWall = new FilteredElementCollector(doc, doc.ActiveView.Id).OfClass(typeof(Wall)).Cast<Wall>().FirstOrDefault(w => w.Location is LocationCurve && (w.Location as LocationCurve).Curve is Arc);\nif (curvedWall != null)\n{\n    Arc arc = (curvedWall.Location as LocationCurve).Curve as Arc;\n    XYZ leaderEndPoint = arc.Center + new XYZ(arc.Radius + 5, 0, 0);\n    doc.Create.NewRadialDimension(doc.ActiveView, new Reference(arc), leaderEndPoint, arc.Radius);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró ningún muro curvo en la vista activa.\");\n}"}
{"prompt":"Create a radial dimension for a curved wall.","completion":"Wall curvedWall = new FilteredElementCollector(doc, doc.ActiveView.Id).OfClass(typeof(Wall)).Cast<Wall>().FirstOrDefault(w => w.Location is LocationCurve && (w.Location as LocationCurve).Curve is Arc);\nif (curvedWall != null)\n{\n    Arc arc = (curvedWall.Location as LocationCurve).Curve as Arc;\n    XYZ leaderEndPoint = arc.Center + new XYZ(arc.Radius + 5, 0, 0);\n    doc.Create.NewRadialDimension(doc.ActiveView, new Reference(arc), leaderEndPoint, arc.Radius);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No curved wall found in the active view.\");\n}"}
{"prompt":"Encuentra el host de una luminaria basada en cara.","completion":"FamilyInstance lightFixture = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_LightingFixtures).WhereElementIsNotElementType().FirstOrDefault(fi => fi.HostFace != null) as FamilyInstance;\nif (lightFixture != null)\n{\n    Reference hostFaceRef = lightFixture.HostFace;\n    Element host = doc.GetElement(hostFaceRef.ElementId);\n    TaskDialog.Show(\"Anfitrión Encontrado\", $\"El anfitrión de la luminaria '{lightFixture.Name}' es: {host.Name}\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró ninguna luminaria basada en cara.\");\n}"}
{"prompt":"Find the host of a face-based light fixture.","completion":"FamilyInstance lightFixture = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_LightingFixtures).WhereElementIsNotElementType().FirstOrDefault(fi => fi.HostFace != null) as FamilyInstance;\nif (lightFixture != null)\n{\n    Reference hostFaceRef = lightFixture.HostFace;\n    Element host = doc.GetElement(hostFaceRef.ElementId);\n    TaskDialog.Show(\"Host Found\", $\"The host of the light fixture '{lightFixture.Name}' is: {host.Name}\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No face-based light fixture was found.\");\n}"}
{"prompt":"Obtén todas las subcategorías de la categoría Puertas.","completion":"Category doorCat = doc.Settings.Categories.get_Item(BuiltInCategory.OST_Doors);\nif (doorCat != null)\n{\n    CategoryNameMap subcategories = doorCat.SubCategories;\n    StringBuilder sb = new StringBuilder($\"Subcategorías de Puertas ({subcategories.Size}):\\n\");\n    foreach(Category subcat in subcategories)\n    {\n        sb.AppendLine(\"- \" + subcat.Name);\n    }\n    TaskDialog.Show(\"Subcategorías\", sb.ToString());\n}"}
{"prompt":"Get all subcategories from the Doors category.","completion":"Category doorCat = doc.Settings.Categories.get_Item(BuiltInCategory.OST_Doors);\nif (doorCat != null)\n{\n    CategoryNameMap subcategories = doorCat.SubCategories;\n    StringBuilder sb = new StringBuilder($\"Door Subcategories ({subcategories.Size}):\\n\");\n    foreach(Category subcat in subcategories)\n    {\n        sb.AppendLine(\"- \" + subcat.Name);\n    }\n    TaskDialog.Show(\"Subcategories\", sb.ToString());\n}"}
{"prompt":"Crea una nueva vista de alzado mirando al norte.","completion":"ViewFamilyType elevationVFT = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(vft => vft.ViewFamily == ViewFamily.Elevation);\nif(elevationVFT != null)\n{\n    ElevationMarker marker = ElevationMarker.CreateElevationMarker(doc, elevationVFT.Id, new XYZ(0, 20, 0), 100);\n    for (int i = 0; i < 4; i++)\n    {\n        View aev = marker.CreateElevation(doc, doc.ActiveView.Id, i);\n        if(i == 2) aev.Name = \"Alzado Norte\"; // Norte es el índice 2\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el tipo de familia de vista de alzado.\");\n}"}
{"prompt":"Create a new elevation view looking north.","completion":"ViewFamilyType elevationVFT = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(vft => vft.ViewFamily == ViewFamily.Elevation);\nif(elevationVFT != null)\n{\n    ElevationMarker marker = ElevationMarker.CreateElevationMarker(doc, elevationVFT.Id, new XYZ(0, 20, 0), 100);\n    for (int i = 0; i < 4; i++)\n    {\n        View aev = marker.CreateElevation(doc, doc.ActiveView.Id, i);\n        if(i == 2) aev.Name = \"North Elevation\"; // North is index 2\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Elevation View Family Type not found.\");\n}"}
{"prompt":"Cambia el nombre de todas las tablas que contienen 'Puertas' por 'Listado de Puertas'.","completion":"List<ViewSchedule> schedules = new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Cast<ViewSchedule>().Where(vs => vs.Name.Contains(\"Puertas\")).ToList();\nint renamedCount = 0;\nforeach(ViewSchedule schedule in schedules)\n{\n    try \n    {\n        schedule.Name = schedule.Name.Replace(\"Puertas\", \"Listado de Puertas\");\n        renamedCount++;\n    }\n    catch {}\n}\nTaskDialog.Show(\"Resultado\", $\"{renamedCount} tablas de planificación renombradas.\");"}
{"prompt":"Rename all schedules containing 'Doors' to 'Door Schedule'.","completion":"List<ViewSchedule> schedules = new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Cast<ViewSchedule>().Where(vs => vs.Name.Contains(\"Doors\")).ToList();\nint renamedCount = 0;\nforeach(ViewSchedule schedule in schedules)\n{\n    try \n    {\n        schedule.Name = schedule.Name.Replace(\"Doors\", \"Door Schedule\");\n        renamedCount++;\n    }\n    catch {}\n}\nTaskDialog.Show(\"Result\", $\"{renamedCount} schedules renamed.\");"}
{"prompt":"Crea un nuevo tipo de cota lineal con texto azul y tamaño 2mm.","completion":"string newTypeName = \"Cota Azul 2mm\";\nif (new FilteredElementCollector(doc).OfClass(typeof(DimensionType)).Any(dt => dt.Name == newTypeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de cota '{newTypeName}' ya existe.\");\n}\nelse\n{\n    DimensionType linearDimType = new FilteredElementCollector(doc).OfClass(typeof(DimensionType)).Cast<DimensionType>().FirstOrDefault(dt => dt.StyleType == DimensionStyleType.Linear);\n    if(linearDimType != null)\n    {\n        DimensionType newDimType = linearDimType.Duplicate(newTypeName) as DimensionType;\n        newDimType.get_Parameter(BuiltInParameter.LINE_COLOR).Set(new Color(0,0,255).GetElementId());\n        newDimType.get_Parameter(BuiltInParameter.TEXT_SIZE).Set(UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Millimeters));\n        TaskDialog.Show(\"Éxito\", $\"Tipo de cota '{newTypeName}' creado.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró un tipo de cota lineal para duplicar.\");\n    }\n}"}
{"prompt":"Create a new linear dimension type with blue text and 2mm size.","completion":"string newTypeName = \"Blue Dimension 2mm\";\nif (new FilteredElementCollector(doc).OfClass(typeof(DimensionType)).Any(dt => dt.Name == newTypeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Dimension type '{newTypeName}' already exists.\");\n}\nelse\n{\n    DimensionType linearDimType = new FilteredElementCollector(doc).OfClass(typeof(DimensionType)).Cast<DimensionType>().FirstOrDefault(dt => dt.StyleType == DimensionStyleType.Linear);\n    if(linearDimType != null)\n    {\n        DimensionType newDimType = linearDimType.Duplicate(newTypeName) as DimensionType;\n        newDimType.get_Parameter(BuiltInParameter.LINE_COLOR).Set(new Color(0,0,255).GetElementId());\n        newDimType.get_Parameter(BuiltInParameter.TEXT_SIZE).Set(UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Millimeters));\n        TaskDialog.Show(\"Success\", $\"Dimension type '{newTypeName}' created.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No linear dimension type found to duplicate.\");\n    }\n}"}
{"prompt":"Reporta el número total de advertencias en el proyecto.","completion":"IList<FailureMessage> warnings = doc.GetWarnings();\nint warningCount = warnings.Count;\nTaskDialog.Show(\"Auditoría de Proyecto\", $\"El proyecto tiene {warningCount} advertencias.\");"}
{"prompt":"Report the total number of warnings in the project.","completion":"IList<FailureMessage> warnings = doc.GetWarnings();\nint warningCount = warnings.Count;\nTaskDialog.Show(\"Project Audit\", $\"The project has {warningCount} warnings.\");"}
{"prompt":"Mueve todos los elementos seleccionados 3 metros hacia arriba.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    XYZ translation = new XYZ(0, 0, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters));\n    ElementTransformUtils.MoveElements(doc, selectedIds, translation);\n}"}
{"prompt":"Move all selected elements 3 meters up.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    XYZ translation = new XYZ(0, 0, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters));\n    ElementTransformUtils.MoveElements(doc, selectedIds, translation);\n}"}
{"prompt":"Exporta todos los tipos de familia de la categoría 'Mobiliario' a un archivo de texto.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"FurnitureTypes.txt\");\nList<Element> furnitureTypes = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Furniture).WhereElementIsElementType().ToList();\nList<string> typeNames = new List<string>();\ntypeNames.Add(\"Tipos de Mobiliario:\");\nforeach(Element type in furnitureTypes)\n{\n    typeNames.Add(type.Name);\n}\nSystem.IO.File.WriteAllLines(filePath, typeNames);\nTaskDialog.Show(\"Exportación Completa\", $\"{furnitureTypes.Count} tipos de mobiliario exportados a: {filePath}\");"}
{"prompt":"Export all family types from the 'Furniture' category to a text file.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"FurnitureTypes.txt\");\nList<Element> furnitureTypes = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Furniture).WhereElementIsElementType().ToList();\nList<string> typeNames = new List<string>();\ntypeNames.Add(\"Furniture Types:\");\nforeach(Element type in furnitureTypes)\n{\n    typeNames.Add(type.Name);\n}\nSystem.IO.File.WriteAllLines(filePath, typeNames);\nTaskDialog.Show(\"Export Complete\", $\"{furnitureTypes.Count} furniture types exported to: {filePath}\");"}

{"prompt":"Copia todos los muros del Nivel 1 al Nivel 2.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nLevel level2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 2\") as Level;\nif (level1 != null && level2 != null)\n{\n    ICollection<ElementId> wallsToCopy = new FilteredElementCollector(doc).OfClass(typeof(Wall)).Where(w => w.LevelId == level1.Id).ToElementIds();\n    if(wallsToCopy.Any())\n    {\n        double elevationDiff = level2.ProjectElevation - level1.ProjectElevation;\n        XYZ translation = new XYZ(0, 0, elevationDiff);\n        ElementTransformUtils.CopyElements(doc, wallsToCopy, translation);\n        TaskDialog.Show(\"Éxito\", $\"{wallsToCopy.Count} muros copiados del '{level1.Name}' al '{level2.Name}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", \"No se encontraron muros en el Nivel 1 para copiar.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron los niveles 'Nivel 1' o 'Nivel 2'.\");\n}"}
{"prompt":"Copy all walls from Level 1 to Level 2.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nLevel level2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 2\") as Level;\nif (level1 != null && level2 != null)\n{\n    ICollection<ElementId> wallsToCopy = new FilteredElementCollector(doc).OfClass(typeof(Wall)).Where(w => w.LevelId == level1.Id).ToElementIds();\n    if(wallsToCopy.Any())\n    {\n        double elevationDiff = level2.ProjectElevation - level1.ProjectElevation;\n        XYZ translation = new XYZ(0, 0, elevationDiff);\n        ElementTransformUtils.CopyElements(doc, wallsToCopy, translation);\n        TaskDialog.Show(\"Success\", $\"{wallsToCopy.Count} walls copied from '{level1.Name}' to '{level2.Name}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", \"No walls were found on Level 1 to copy.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Level 1' or 'Level 2' not found.\");\n}"}
{"prompt":"Encuentra todos los muros que miden más de 3 metros de alto.","completion":"double heightThreshold = UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters);\nElementId heightParamId = new ElementId(BuiltInParameter.WALL_USER_HEIGHT_PARAM);\nParameterValueProvider pvp = new ParameterValueProvider(heightParamId);\nFilterNumericRuleEvaluator evaluator = new FilterNumericGreater();\nFilterRule rule = new FilterDoubleRule(pvp, evaluator, heightThreshold, 1e-6);\nElementParameterFilter filter = new ElementParameterFilter(rule);\nList<ElementId> tallWalls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WherePasses(filter).ToElementIds().ToList();\nTaskDialog.Show(\"Resultado\", $\"Se encontraron {tallWalls.Count} muros con más de 3m de altura.\");\nif(tallWalls.Any()) new UIDocument(doc).Selection.SetElementIds(tallWalls);"}
{"prompt":"Find all walls taller than 3 meters.","completion":"double heightThreshold = UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters);\nElementId heightParamId = new ElementId(BuiltInParameter.WALL_USER_HEIGHT_PARAM);\nParameterValueProvider pvp = new ParameterValueProvider(heightParamId);\nFilterNumericRuleEvaluator evaluator = new FilterNumericGreater();\nFilterRule rule = new FilterDoubleRule(pvp, evaluator, heightThreshold, 1e-6);\nElementParameterFilter filter = new ElementParameterFilter(rule);\nList<ElementId> tallWalls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WherePasses(filter).ToElementIds().ToList();\nTaskDialog.Show(\"Result\", $\"Found {tallWalls.Count} walls taller than 3m.\");\nif(tallWalls.Any()) new UIDocument(doc).Selection.SetElementIds(tallWalls);"}
{"prompt":"Selecciona un muro y encuentra todas las tuberías que lo atraviesan.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference wallRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un muro\");\nif (wallRef != null)\n{\n    Element wall = doc.GetElement(wallRef);\n    if(wall != null && wall.Category.Id.IntegerValue == (int)BuiltInCategory.OST_Walls)\n    {\n        ElementIntersectsElementFilter filter = new ElementIntersectsElementFilter(wall);\n        List<ElementId> intersectingPipes = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_PipeCurves).WherePasses(filter).ToElementIds().ToList();\n        TaskDialog.Show(\"Colisiones\", $\"El muro intersecta con {intersectingPipes.Count} tuberías.\");\n        if(intersectingPipes.Any()) uidoc.Selection.SetElementIds(intersectingPipes);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no es un muro.\");\n    }\n}"}
{"prompt":"Select a wall and find all pipes passing through it.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference wallRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a wall\");\nif (wallRef != null)\n{\n    Element wall = doc.GetElement(wallRef);\n    if(wall != null && wall.Category.Id.IntegerValue == (int)BuiltInCategory.OST_Walls)\n    {\n        ElementIntersectsElementFilter filter = new ElementIntersectsElementFilter(wall);\n        List<ElementId> intersectingPipes = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_PipeCurves).WherePasses(filter).ToElementIds().ToList();\n        TaskDialog.Show(\"Clashes\", $\"The wall intersects with {intersectingPipes.Count} pipes.\");\n        if(intersectingPipes.Any()) uidoc.Selection.SetElementIds(intersectingPipes);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element is not a wall.\");\n    }\n}"}
{"prompt":"Crea una nota de texto que apunte al elemento seleccionado y diga 'REVISAR CLASH'.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference targetRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona el elemento a anotar\");\nif(targetRef != null)\n{\n    XYZ textLocation = uidoc.Selection.PickPoint(\"Elige la ubicación del texto\");\n    TextNoteOptions opts = new TextNoteOptions(doc.GetDefaultElementTypeId(ElementTypeGroup.TextNoteType));\n    TextNote note = TextNote.Create(doc, doc.ActiveView.Id, textLocation, \"REVISAR CLASH\", opts);\n    note.AddLeader(TextNoteLeaderTypes.TNLT_STRAIGHT_L, targetRef.GlobalPoint);\n}"}
{"prompt":"Create a text note pointing to the selected element that says 'REVIEW CLASH'.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference targetRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select an element to annotate\");\nif(targetRef != null)\n{\n    XYZ textLocation = uidoc.Selection.PickPoint(\"Choose the text location\");\n    TextNoteOptions opts = new TextNoteOptions(doc.GetDefaultElementTypeId(ElementTypeGroup.TextNoteType));\n    TextNote note = TextNote.Create(doc, doc.ActiveView.Id, \"REVIEW CLASH\", textLocation, opts);\n    note.AddLeader(TextNoteLeaderTypes.TNLT_STRAIGHT_L, targetRef.GlobalPoint);\n}"}
{"prompt":"Oculta todos los muros que sean más cortos de 2 metros.","completion":"double lengthThreshold = UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters);\nList<Wall> walls = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WhereElementIsNotElementType().Cast<Wall>().ToList();\nList<ElementId> shortWallIds = new List<ElementId>();\nforeach(Wall wall in walls)\n{\n    if(wall.get_Parameter(BuiltInParameter.CURVE_ELEM_LENGTH).AsDouble() < lengthThreshold)\n    {\n        shortWallIds.Add(wall.Id);\n    }\n}\nif(shortWallIds.Any()) \n{\n    doc.ActiveView.HideElements(shortWallIds);\n    TaskDialog.Show(\"Resultado\", $\"{shortWallIds.Count} muros cortos han sido ocultados.\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No se encontraron muros más cortos de 2 metros.\");\n}"}
{"prompt":"Hide all walls shorter than 2 meters.","completion":"double lengthThreshold = UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters);\nList<Wall> walls = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WhereElementIsNotElementType().Cast<Wall>().ToList();\nList<ElementId> shortWallIds = new List<ElementId>();\nforeach(Wall wall in walls)\n{\n    if(wall.get_Parameter(BuiltInParameter.CURVE_ELEM_LENGTH).AsDouble() < lengthThreshold)\n    {\n        shortWallIds.Add(wall.Id);\n    }\n}\nif(shortWallIds.Any()) \n{\n    doc.ActiveView.HideElements(shortWallIds);\n    TaskDialog.Show(\"Result\", $\"{shortWallIds.Count} short walls have been hidden.\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No walls shorter than 2 meters were found.\");\n}"}
{"prompt":"Crea una familia 'in-situ' para un mostrador de recepción personalizado usando una extrusión.","completion":"TaskDialog.Show(\"Acción no soportada\", \"La creación de familias in-situ es un proceso de edición complejo que no puede ser ejecutado directamente. Se recomienda modelar estos elementos usando las herramientas estándar de Revit.\");"}
{"prompt":"Create an in-place family for a custom reception desk using an extrusion.","completion":"TaskDialog.Show(\"Unsupported Action\", \"Creating in-place families is a complex editing process that cannot be executed directly. It is recommended to model these elements using standard Revit tools.\");"}
{"prompt":"Modifica el tipo de muro de un muro existente a uno que contenga 'Aislamiento Térmico'.","completion":"Wall wallToChange = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault() as Wall;\nWallType newType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).Cast<WallType>().FirstOrDefault(x => x.Name.Contains(\"Aislamiento Térmico\") || x.Name.Contains(\"Insulation\"));\nif (wallToChange != null && newType != null)\n{\n    wallToChange.ChangeTypeId(newType.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró un muro para cambiar o un tipo de muro con aislamiento.\");\n}"}
{"prompt":"Change the wall type of an existing wall to one containing 'Thermal Insulation'.","completion":"Wall wallToChange = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault() as Wall;\nWallType newType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).Cast<WallType>().FirstOrDefault(x => x.Name.Contains(\"Thermal Insulation\"));\nif (wallToChange != null && newType != null)\n{\n    wallToChange.ChangeTypeId(newType.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Could not find a wall to change or a wall type with insulation.\");\n}"}
{"prompt":"Crea una apertura de hueco vertical (shaft) desde el nivel base hasta el nivel más alto.","completion":"Level bottomLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().OrderBy(l => l.ProjectElevation).FirstOrDefault();\nLevel topLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().OrderByDescending(l => l.ProjectElevation).FirstOrDefault();\nif(bottomLevel != null && topLevel != null && bottomLevel.Id != topLevel.Id)\n{\n    XYZ p1 = new XYZ(2,2,0);\n    XYZ p2 = new XYZ(5,5,0);\n    CurveLoop profile = CurveLoop.CreateViaRectangle(p1, p2);\n    doc.Create.NewOpening(bottomLevel, topLevel, profile, true);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesitan al menos dos niveles distintos para crear un hueco.\");\n}"}
{"prompt":"Create a vertical shaft opening from the base level to the top level.","completion":"Level bottomLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().OrderBy(l => l.ProjectElevation).FirstOrDefault();\nLevel topLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().OrderByDescending(l => l.ProjectElevation).FirstOrDefault();\nif(bottomLevel != null && topLevel != null && bottomLevel.Id != topLevel.Id)\n{\n    XYZ p1 = new XYZ(2,2,0);\n    XYZ p2 = new XYZ(5,5,0);\n    CurveLoop profile = CurveLoop.CreateViaRectangle(p1, p2);\n    doc.Create.NewOpening(bottomLevel, topLevel, profile, true);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"At least two different levels are required to create a shaft.\");\n}"}
{"prompt":"Obtén todos los materiales y sus volúmenes de un muro compuesto seleccionado.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un muro\");\nif (pickedRef != null)\n{\n    Wall wall = doc.GetElement(pickedRef) as Wall;\n    if (wall != null)\n    {\n        double wallArea = wall.get_Parameter(BuiltInParameter.HOST_AREA_COMPUTED).AsDouble();\n        CompoundStructure cs = wall.WallType.GetCompoundStructure();\n        if (cs != null)\n        {\n            StringBuilder sb = new StringBuilder($\"Materiales del muro '{wall.Name}':\\n\");\n            for(int i = 0; i < cs.GetLayerCount(); i++)\n            {\n                CompoundStructureLayer layer = cs.GetLayer(i);\n                Material material = doc.GetElement(layer.MaterialId) as Material;\n                if(material != null)\n                {\n                    double volume = layer.Width * wallArea;\n                    sb.AppendLine($\"- {material.Name}: {UnitUtils.ConvertFromInternalUnits(volume, UnitTypeId.CubicMeters):F3} m³\");\n                }\n            }\n            TaskDialog.Show(\"Volumen de Materiales\", sb.ToString());\n        }\n    }\n}"}
{"prompt":"Get all materials and their volumes from a selected compound wall.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a wall\");\nif (pickedRef != null)\n{\n    Wall wall = doc.GetElement(pickedRef) as Wall;\n    if (wall != null)\n    {\n        double wallArea = wall.get_Parameter(BuiltInParameter.HOST_AREA_COMPUTED).AsDouble();\n        CompoundStructure cs = wall.WallType.GetCompoundStructure();\n        if (cs != null)\n        {\n            StringBuilder sb = new StringBuilder($\"Materials in wall '{wall.Name}':\\n\");\n            for(int i = 0; i < cs.GetLayerCount(); i++)\n            {\n                CompoundStructureLayer layer = cs.GetLayer(i);\n                Material material = doc.GetElement(layer.MaterialId) as Material;\n                if(material != null)\n                {\n                    double volume = layer.Width * wallArea;\n                    sb.AppendLine($\"- {material.Name}: {UnitUtils.ConvertFromInternalUnits(volume, UnitTypeId.CubicMeters):F3} m³\");\n                }\n            }\n            TaskDialog.Show(\"Material Volumes\", sb.ToString());\n        }\n    }\n}"}
{"prompt":"Muestra un cuadro de diálogo con las opciones 'Sí', 'No' y 'Cancelar'.","completion":"TaskDialog mainDialog = new TaskDialog(\"Confirmación\");\nmainDialog.MainInstruction = \"¿Desea guardar los cambios?\";\nmainDialog.CommonButtons = TaskDialogCommonButtons.Yes | TaskDialogCommonButtons.No | TaskDialogCommonButtons.Cancel;\nTaskDialogResult result = mainDialog.Show();"}
{"prompt":"Display a dialog box with 'Yes', 'No', and 'Cancel' options.","completion":"TaskDialog mainDialog = new TaskDialog(\"Confirmation\");\nmainDialog.MainInstruction = \"Do you want to save the changes?\";\nmainDialog.CommonButtons = TaskDialogCommonButtons.Yes | TaskDialogCommonButtons.No | TaskDialogCommonButtons.Cancel;\nTaskDialogResult result = mainDialog.Show();"}
{"prompt":"Abre una familia, añade un parámetro de tipo 'Código de Material' y guárdala.","completion":"TaskDialog.Show(\"Acción no soportada\", \"La edición de familias es una operación compleja que no se puede ejecutar directamente. Este proceso requiere abrir un nuevo documento de familia y manejar transacciones separadas, lo cual está fuera del alcance de un comando simple.\");"}
{"prompt":"Open a family, add a type parameter 'Material Code', and save it.","completion":"TaskDialog.Show(\"Unsupported Action\", \"Editing families is a complex operation that cannot be executed directly. This process requires opening a new family document and managing separate transactions, which is beyond the scope of a simple command.\");"}
{"prompt":"Encuentra todas las puertas del Nivel 2 que sean de la familia 'Puerta Sencilla'.","completion":"Level level2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 2\") as Level;\nif(level2 != null)\n{\n    ElementCategoryFilter catFilter = new ElementCategoryFilter(BuiltInCategory.OST_Doors);\n    ElementLevelFilter levelFilter = new ElementLevelFilter(level2.Id);\n    FamilyNameRule famNameRule = new FamilyNameRule(new ParameterValueProvider(new ElementId(BuiltInParameter.ELEM_FAMILY_PARAM)), new FilterStringEquals(), \"Puerta Sencilla\");\n    ElementParameterFilter famFilter = new ElementParameterFilter(famNameRule);\n    LogicalAndFilter andFilter = new LogicalAndFilter(new List<ElementFilter> { catFilter, levelFilter, famFilter });\n    List<Element> doors = new FilteredElementCollector(doc).WherePasses(andFilter).ToList();\n    TaskDialog.Show(\"Resultado\", $\"Se encontraron {doors.Count} puertas de la familia 'Puerta Sencilla' en el Nivel 2.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el 'Nivel 2'.\");\n}"}
{"prompt":"Find all doors on Level 2 that belong to the 'Single-Flush' family.","completion":"Level level2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 2\") as Level;\nif(level2 != null)\n{\n    ElementCategoryFilter catFilter = new ElementCategoryFilter(BuiltInCategory.OST_Doors);\n    ElementLevelFilter levelFilter = new ElementLevelFilter(level2.Id);\n    FamilyNameRule famNameRule = new FamilyNameRule(new ParameterValueProvider(new ElementId(BuiltInParameter.ELEM_FAMILY_PARAM)), new FilterStringEquals(), \"Single-Flush\");\n    ElementParameterFilter famFilter = new ElementParameterFilter(famNameRule);\n    LogicalAndFilter andFilter = new LogicalAndFilter(new List<ElementFilter> { catFilter, levelFilter, famFilter });\n    List<Element> doors = new FilteredElementCollector(doc).WherePasses(andFilter).ToList();\n    TaskDialog.Show(\"Result\", $\"Found {doors.Count} doors of the 'Single-Flush' family on Level 2.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Level 2' not found.\");\n}"}
{"prompt":"Exporta todas las advertencias del proyecto a un archivo de texto.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"ProjectWarnings.txt\");\nIList<FailureMessage> warnings = doc.GetWarnings();\nif (warnings.Any())\n{\n    List<string> warningDescriptions = warnings.Select(w => w.GetDescriptionText()).ToList();\n    System.IO.File.WriteAllLines(filePath, warningDescriptions);\n    TaskDialog.Show(\"Exportación Completa\", $\"{warnings.Count} advertencias exportadas a: {filePath}\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"El proyecto no tiene advertencias.\");\n}"}
{"prompt":"Export all project warnings to a text file.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"ProjectWarnings.txt\");\nIList<FailureMessage> warnings = doc.GetWarnings();\nif (warnings.Any())\n{\n    List<string> warningDescriptions = warnings.Select(w => w.GetDescriptionText()).ToList();\n    System.IO.File.WriteAllLines(filePath, warningDescriptions);\n    TaskDialog.Show(\"Export Complete\", $\"{warnings.Count} warnings exported to: {filePath}\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"The project has no warnings.\");\n}"}
{"prompt":"Desune la geometría de dos elementos seleccionados.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference ref1 = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona el primer elemento\");\nif (ref1 == null) return;\nReference ref2 = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona el segundo elemento\");\nif (ref2 == null) return;\nElement e1 = doc.GetElement(ref1.ElementId);\nElement e2 = doc.GetElement(ref2.ElementId);\nif (e1 != null && e2 != null)\n{\n    if (JoinGeometryUtils.AreElementsJoined(doc, e1, e2))\n    {\n        JoinGeometryUtils.UnjoinGeometry(doc, e1, e2);\n        TaskDialog.Show(\"Éxito\", \"La geometría ha sido desunida.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", \"Los elementos seleccionados no estaban unidos.\");\n    }\n}"}
{"prompt":"Unjoin the geometry of two selected elements.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference ref1 = uidoc.Selection.PickObject(ObjectType.Element, \"Select the first element\");\nif (ref1 == null) return;\nReference ref2 = uidoc.Selection.PickObject(ObjectType.Element, \"Select the second element\");\nif (ref2 == null) return;\nElement e1 = doc.GetElement(ref1.ElementId);\nElement e2 = doc.GetElement(ref2.ElementId);\nif (e1 != null && e2 != null)\n{\n    if (JoinGeometryUtils.AreElementsJoined(doc, e1, e2))\n    {\n        JoinGeometryUtils.UnjoinGeometry(doc, e1, e2);\n        TaskDialog.Show(\"Success\", \"Geometry has been unjoined.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", \"The selected elements were not joined.\");\n    }\n}"}
{"prompt":"Dentro del editor de familias, crea un nuevo plano de referencia horizontal.","completion":"if(doc.IsFamilyDocument)\n{\n    string rpName = \"Plano Horizontal\";\n    ReferencePlane existingRp = new FilteredElementCollector(doc).OfClass(typeof(ReferencePlane)).Cast<ReferencePlane>().FirstOrDefault(rp => rp.Name == rpName);\n    if (existingRp == null)\n    {\n        XYZ start = new XYZ(-5, 0, 0);\n        XYZ end = new XYZ(5, 0, 0);\n        XYZ normal = XYZ.BasisY;\n        ReferencePlane rp = doc.FamilyCreate.NewReferencePlane(start, end, normal, doc.ActiveView);\n        rp.Name = rpName;\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error de Contexto\", \"Este comando solo funciona dentro del Editor de Familias.\");\n}"}
{"prompt":"Inside the family editor, create a new horizontal reference plane.","completion":"if(doc.IsFamilyDocument)\n{\n    string rpName = \"Horizontal Plane\";\n    ReferencePlane existingRp = new FilteredElementCollector(doc).OfClass(typeof(ReferencePlane)).Cast<ReferencePlane>().FirstOrDefault(rp => rp.Name == rpName);\n    if (existingRp == null)\n    {\n        XYZ start = new XYZ(-5, 0, 0);\n        XYZ end = new XYZ(5, 0, 0);\n        XYZ normal = XYZ.BasisY;\n        ReferencePlane rp = doc.FamilyCreate.NewReferencePlane(start, end, normal, doc.ActiveView);\n        rp.Name = rpName;\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Context Error\", \"This command only works inside the Family Editor.\");\n}"}
{"prompt":"Aísla temporalmente la categoría de Puertas en la vista activa.","completion":"ElementId doorCategoryId = new ElementId(BuiltInCategory.OST_Doors);\nICollection<ElementId> categoryIds = new List<ElementId> { doorCategoryId };\ndoc.ActiveView.IsolateCategoriesTemporary(categoryIds);"}
{"prompt":"Temporarily isolate the Doors category in the active view.","completion":"ElementId doorCategoryId = new ElementId(BuiltInCategory.OST_Doors);\nICollection<ElementId> categoryIds = new List<ElementId> { doorCategoryId };\ndoc.ActiveView.IsolateCategoriesTemporary(categoryIds);"}
{"prompt":"Cambia el tipo de una losa seleccionada a 'Concreto 15cm'.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona una losa\");\nif (pickedRef != null)\n{\n    Floor floorToChange = doc.GetElement(pickedRef) as Floor;\n    if (floorToChange != null)\n    {\n        FloorType newType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Cast<FloorType>().FirstOrDefault(ft => ft.Name == \"Concreto 15cm\");\n        if (newType != null)\n        {\n            floorToChange.ChangeTypeId(newType.Id);\n        }\n        else\n        {\n            TaskDialog.Show(\"Error\", \"No se encontró el tipo de losa 'Concreto 15cm'.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no es una losa.\");\n    }\n}"}
{"prompt":"Change the type of a selected floor to 'Concrete 15cm'.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a floor\");\nif (pickedRef != null)\n{\n    Floor floorToChange = doc.GetElement(pickedRef) as Floor;\n    if (floorToChange != null)\n    {\n        FloorType newType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Cast<FloorType>().FirstOrDefault(ft => ft.Name == \"Concrete 15cm\");\n        if (newType != null)\n        {\n            floorToChange.ChangeTypeId(newType.Id);\n        }\n        else\n        {\n            TaskDialog.Show(\"Error\", \"Floor type 'Concrete 15cm' not found.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element is not a floor.\");\n    }\n}"}
{"prompt":"Añade un punto al Path of Travel seleccionado.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un Path of Travel\");\nif (pickedRef != null)\n{\n    PathOfTravel pot = doc.GetElement(pickedRef) as PathOfTravel;\n    if(pot != null)\n    {\n        IList<XYZ> points = pot.GetPath();\n        XYZ midPoint = (points[0] + points[1]) / 2;\n        points.Insert(1, midPoint); \n        pot.Update(points);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no es un Path of Travel.\");\n    }\n}"}
{"prompt":"Add a point to the selected Path of Travel.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a Path of Travel\");\nif (pickedRef != null)\n{\n    PathOfTravel pot = doc.GetElement(pickedRef) as PathOfTravel;\n    if(pot != null)\n    {\n        IList<XYZ> points = pot.GetPath();\n        XYZ midPoint = (points[0] + points[1]) / 2;\n        points.Insert(1, midPoint);\n        pot.Update(points);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element is not a Path of Travel.\");\n    }\n}"}
{"prompt":"Comprueba si la vista activa es una vista de plano.","completion":"View activeView = doc.ActiveView;\nbool isPlanView = activeView.ViewType == ViewType.FloorPlan \n    || activeView.ViewType == ViewType.CeilingPlan \n    || activeView.ViewType == ViewType.AreaPlan \n    || activeView.ViewType == ViewType.EngineeringPlan;\nTaskDialog.Show(\"Verificación de Vista\", \"La vista activa es una vista de plano: \" + isPlanView);"}
{"prompt":"Check if the active view is a plan view.","completion":"View activeView = doc.ActiveView;\nbool isPlanView = activeView.ViewType == ViewType.FloorPlan \n    || activeView.ViewType == ViewType.CeilingPlan \n    || activeView.ViewType == ViewType.AreaPlan \n    || activeView.ViewType == ViewType.EngineeringPlan;\nTaskDialog.Show(\"View Check\", \"Is the active view a plan view? \" + isPlanView);"}
{"prompt":"Crea un nuevo tipo de tubería llamado 'Tubería de Acero' con material 'Acero, Carbono'.","completion":"string newTypeName = \"Tubería de Acero\";\nif (new FilteredElementCollector(doc).OfClass(typeof(PipeType)).Any(pt => pt.Name == newTypeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de tubería '{newTypeName}' ya existe.\");\n}\nelse\n{\n    PipeType pipeTypeToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(PipeType)).FirstOrDefault() as PipeType;\n    Material steel = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name == \"Acero, Carbono\") as Material;\n    if(pipeTypeToDuplicate != null && steel != null)\n    {\n        PipeType newType = pipeTypeToDuplicate.Duplicate(newTypeName) as PipeType;\n        newType.get_Parameter(BuiltInParameter.MATERIAL_ID_PARAM).Set(steel.Id);\n        TaskDialog.Show(\"Éxito\", $\"Tipo de tubería '{newTypeName}' creado.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Se necesita un tipo de tubería para duplicar y el material 'Acero, Carbono'.\");\n    }\n}"}
{"prompt":"Create a new pipe type named 'Steel Pipe' with 'Steel, Carbon' material.","completion":"string newTypeName = \"Steel Pipe\";\nif (new FilteredElementCollector(doc).OfClass(typeof(PipeType)).Any(pt => pt.Name == newTypeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Pipe type '{newTypeName}' already exists.\");\n}\nelse\n{\n    PipeType pipeTypeToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(PipeType)).FirstOrDefault() as PipeType;\n    Material steel = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name == \"Steel, Carbon\") as Material;\n    if(pipeTypeToDuplicate != null && steel != null)\n    {\n        PipeType newType = pipeTypeToDuplicate.Duplicate(newTypeName) as PipeType;\n        newType.get_Parameter(BuiltInParameter.MATERIAL_ID_PARAM).Set(steel.Id);\n        TaskDialog.Show(\"Success\", $\"Pipe type '{newTypeName}' created.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"A pipe type to duplicate and the 'Steel, Carbon' material are required.\");\n    }\n}"}
{"prompt":"Crea una nueva hoja A1 y coloca la vista 'Planta Baja' en ella.","completion":"string sheetNumber = \"A-101\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewSheet)).Cast<ViewSheet>().Any(s => s.SheetNumber == sheetNumber))\n{\n    TaskDialog.Show(\"Advertencia\", $\"Ya existe una hoja con el número '{sheetNumber}'.\");\n}\nelse\n{\n    FamilySymbol titleBlock = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_TitleBlocks).WhereElementIsElementType().FirstOrDefault(tb => tb.Name.Contains(\"A1\")) as FamilySymbol;\n    View viewToPlace = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).FirstOrDefault(v => v.Name == \"Planta Baja\") as View;\n    if (titleBlock != null && viewToPlace != null)\n    {\n        ViewSheet newSheet = ViewSheet.Create(doc, titleBlock.Id);\n        newSheet.Name = \"Planta Arquitectónica - Planta Baja\";\n        newSheet.SheetNumber = sheetNumber;\n        if (Viewport.CanAddViewToSheet(doc, newSheet.Id, viewToPlace.Id))\n        {\n            BoundingBoxUV sheetBox = newSheet.Outline;\n            XYZ centerPoint = (sheetBox.Min + sheetBox.Max) / 2;\n            Viewport.Create(doc, newSheet.Id, viewToPlace.Id, centerPoint);\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró un cajetín A1 o la vista 'Planta Baja'.\");\n    }\n}"}
{"prompt":"Create a new A1 sheet and place the 'Ground Floor' view on it.","completion":"string sheetNumber = \"A-101\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewSheet)).Cast<ViewSheet>().Any(s => s.SheetNumber == sheetNumber))\n{\n    TaskDialog.Show(\"Warning\", $\"A sheet with the number '{sheetNumber}' already exists.\");\n}\nelse\n{\n    FamilySymbol titleBlock = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_TitleBlocks).WhereElementIsElementType().FirstOrDefault(tb => tb.Name.Contains(\"A1\")) as FamilySymbol;\n    View viewToPlace = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).FirstOrDefault(v => v.Name == \"Ground Floor\") as View;\n    if (titleBlock != null && viewToPlace != null)\n    {\n        ViewSheet newSheet = ViewSheet.Create(doc, titleBlock.Id);\n        newSheet.Name = \"Architectural Plan - Ground Floor\";\n        newSheet.SheetNumber = sheetNumber;\n        if (Viewport.CanAddViewToSheet(doc, newSheet.Id, viewToPlace.Id))\n        {\n            BoundingBoxUV sheetBox = newSheet.Outline;\n            XYZ centerPoint = (sheetBox.Min + sheetBox.Max) / 2;\n            Viewport.Create(doc, newSheet.Id, viewToPlace.Id, centerPoint);\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"A1 title block or 'Ground Floor' view not found.\");\n    }\n}"}
{"prompt":"Crea un nuevo tipo de puerta llamado 'Puerta RF-60' y asigna '60 min' al parámetro 'Fire Rating'.","completion":"string newTypeName = \"Puerta RF-60\";\nif (new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().Any(t => t.Name == newTypeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de puerta '{newTypeName}' ya existe.\");\n}\nelse\n{\n    FamilySymbol doorTypeToDuplicate = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\n    if (doorTypeToDuplicate != null)\n    {\n        FamilySymbol newDoorType = doorTypeToDuplicate.Duplicate(newTypeName) as FamilySymbol;\n        Parameter fireRatingParam = newDoorType.get_Parameter(BuiltInParameter.FIRE_RATING);\n        if (fireRatingParam != null && !fireRatingParam.IsReadOnly) \n        {\n            fireRatingParam.Set(\"60 min\");\n            TaskDialog.Show(\"Éxito\", $\"Tipo de puerta '{newTypeName}' creado.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontraron tipos de puerta para duplicar.\");\n    }\n}"}
{"prompt":"Create a new door type named 'FR-60 Door' and set the 'Fire Rating' parameter to '60 min'.","completion":"string newTypeName = \"FR-60 Door\";\nif (new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().Any(t => t.Name == newTypeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Door type '{newTypeName}' already exists.\");\n}\nelse\n{\n    FamilySymbol doorTypeToDuplicate = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\n    if (doorTypeToDuplicate != null)\n    {\n        FamilySymbol newDoorType = doorTypeToDuplicate.Duplicate(newTypeName) as FamilySymbol;\n        Parameter fireRatingParam = newDoorType.get_Parameter(BuiltInParameter.FIRE_RATING);\n        if (fireRatingParam != null && !fireRatingParam.IsReadOnly) \n        {\n            fireRatingParam.Set(\"60 min\");\n            TaskDialog.Show(\"Success\", $\"Door type '{newTypeName}' created.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No door types found to duplicate.\");\n    }\n}"}
{"prompt":"Encuentra todos los muros que no están asociados a ningún nivel.","completion":"ElementFilter unassociatedFilter = new ElementLevelFilter(ElementId.InvalidElementId);\nList<Element> unassignedWalls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WherePasses(unassociatedFilter).ToList();\nTaskDialog.Show(\"Muros sin Nivel\", $\"Se encontraron {unassignedWalls.Count} muros sin nivel base.\");\nif (unassignedWalls.Any()) new UIDocument(doc).Selection.SetElementIds(unassignedWalls.Select(e => e.Id).ToList());"}
{"prompt":"Find all walls that are not associated with any level.","completion":"ElementFilter unassociatedFilter = new ElementLevelFilter(ElementId.InvalidElementId);\nList<Element> unassignedWalls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WherePasses(unassociatedFilter).ToList();\nTaskDialog.Show(\"Unassigned Walls\", $\"Found {unassignedWalls.Count} walls with no base level.\");\nif (unassignedWalls.Any()) new UIDocument(doc).Selection.SetElementIds(unassignedWalls.Select(e => e.Id).ToList());"}

{"prompt":"Crea un nuevo tipo de texto de 3mm de color azul.","completion":"string newTypeName = \"3mm Azul\";\nif (new FilteredElementCollector(doc).OfClass(typeof(TextNoteType)).Any(t => t.Name == newTypeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de texto '{newTypeName}' ya existe.\");\n}\nelse\n{\n    TextNoteType defaultType = new FilteredElementCollector(doc).OfClass(typeof(TextNoteType)).FirstOrDefault() as TextNoteType;\n    if (defaultType != null)\n    {\n        TextNoteType newType = defaultType.Duplicate(newTypeName) as TextNoteType;\n        newType.get_Parameter(BuiltInParameter.TEXT_SIZE).Set(UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Millimeters));\n        newType.get_Parameter(BuiltInParameter.LINE_COLOR).Set(new Color(0,0,255).GetElementId());\n        TaskDialog.Show(\"Éxito\", $\"Tipo de texto '{newTypeName}' creado.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró un tipo de texto por defecto para duplicar.\");\n    }\n}"}
{"prompt":"Create a new 3mm text type in blue color.","completion":"string newTypeName = \"3mm Blue\";\nif (new FilteredElementCollector(doc).OfClass(typeof(TextNoteType)).Any(t => t.Name == newTypeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Text type '{newTypeName}' already exists.\");\n}\nelse\n{\n    TextNoteType defaultType = new FilteredElementCollector(doc).OfClass(typeof(TextNoteType)).FirstOrDefault() as TextNoteType;\n    if (defaultType != null)\n    {\n        TextNoteType newType = defaultType.Duplicate(newTypeName) as TextNoteType;\n        newType.get_Parameter(BuiltInParameter.TEXT_SIZE).Set(UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Millimeters));\n        newType.get_Parameter(BuiltInParameter.LINE_COLOR).Set(new Color(0,0,255).GetElementId());\n        TaskDialog.Show(\"Success\", $\"Text type '{newTypeName}' created.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No default text type found to duplicate.\");\n    }\n}"}
{"prompt":"Crea una vista de sección entre los puntos (0,0,0) y (10,10,0).","completion":"ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.Section);\nif(vft != null)\n{\n    XYZ p1 = new XYZ(0,0,0);\n    XYZ p2 = new XYZ(10,10,0);\n    XYZ midPoint = (p1 + p2) / 2;\n    XYZ direction = (p2 - p1).Normalize();\n    XYZ up = XYZ.BasisZ;\n    XYZ viewdir = up.CrossProduct(direction);\n    BoundingBoxXYZ sectionBox = new BoundingBoxXYZ();\n    Transform t = Transform.Identity;\n    t.Origin = midPoint;\n    t.BasisX = direction;\n    t.BasisY = up;\n    t.BasisZ = viewdir;\n    sectionBox.Transform = t;\n    sectionBox.Min = new XYZ(-p1.DistanceTo(p2)/2, -10, 0);\n    sectionBox.Max = new XYZ(p1.DistanceTo(p2)/2, 10, 20);\n    ViewSection.CreateSection(doc, vft.Id, sectionBox);\n}"}
{"prompt":"Create a section view between points (0,0,0) and (10,10,0).","completion":"ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.Section);\nif(vft != null)\n{\n    XYZ p1 = new XYZ(0,0,0);\n    XYZ p2 = new XYZ(10,10,0);\n    XYZ midPoint = (p1 + p2) / 2;\n    XYZ direction = (p2 - p1).Normalize();\n    XYZ up = XYZ.BasisZ;\n    XYZ viewdir = up.CrossProduct(direction);\n    BoundingBoxXYZ sectionBox = new BoundingBoxXYZ();\n    Transform t = Transform.Identity;\n    t.Origin = midPoint;\n    t.BasisX = direction;\n    t.BasisY = up;\n    t.BasisZ = viewdir;\n    sectionBox.Transform = t;\n    sectionBox.Min = new XYZ(-p1.DistanceTo(p2)/2, -10, 0);\n    sectionBox.Max = new XYZ(p1.DistanceTo(p2)/2, 10, 20);\n    ViewSection.CreateSection(doc, vft.Id, sectionBox);\n}"}
{"prompt":"Aplica aislamiento térmico de 25mm a todas las tuberías de agua caliente.","completion":"PipeInsulationType insulationType = new FilteredElementCollector(doc).OfClass(typeof(PipeInsulationType)).FirstOrDefault() as PipeInsulationType;\nPipingSystemType hotWaterSystem = new FilteredElementCollector(doc).OfClass(typeof(PipingSystemType)).Cast<PipingSystemType>().FirstOrDefault(s => s.Name.Contains(\"Hot Water\") || s.Name.Contains(\"Agua Caliente\"));\nif(insulationType != null && hotWaterSystem != null)\n{\n    List<Pipe> pipes = new FilteredElementCollector(doc).OfClass(typeof(Pipe)).Cast<Pipe>().Where(p => p.get_Parameter(BuiltInParameter.RBS_PIPING_SYSTEM_TYPE_PARAM).AsElementId() == hotWaterSystem.Id).ToList();\n    int count = 0;\n    foreach(Pipe p in pipes)\n    {\n        if(!PipeInsulation.IsPipeInsulated(doc, p.Id)) \n        {\n            PipeInsulation.Create(doc, p.Id, insulationType.Id, UnitUtils.ConvertToInternalUnits(25, UnitTypeId.Millimeters));\n            count++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"Se aplicó aislamiento a {count} tuberías.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Falta un tipo de aislamiento o un sistema de tuberías de agua caliente.\");\n}"}
{"prompt":"Apply 25mm thermal insulation to all hot water pipes.","completion":"PipeInsulationType insulationType = new FilteredElementCollector(doc).OfClass(typeof(PipeInsulationType)).FirstOrDefault() as PipeInsulationType;\nPipingSystemType hotWaterSystem = new FilteredElementCollector(doc).OfClass(typeof(PipingSystemType)).Cast<PipingSystemType>().FirstOrDefault(s => s.Name.Contains(\"Hot Water\"));\nif(insulationType != null && hotWaterSystem != null)\n{\n    List<Pipe> pipes = new FilteredElementCollector(doc).OfClass(typeof(Pipe)).Cast<Pipe>().Where(p => p.get_Parameter(BuiltInParameter.RBS_PIPING_SYSTEM_TYPE_PARAM).AsElementId() == hotWaterSystem.Id).ToList();\n    int count = 0;\n    foreach(Pipe p in pipes)\n    {\n        if(!PipeInsulation.IsPipeInsulated(doc, p.Id)) \n        {\n            PipeInsulation.Create(doc, p.Id, insulationType.Id, UnitUtils.ConvertToInternalUnits(25, UnitTypeId.Millimeters));\n            count++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{count} pipes were insulated.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"An insulation type or a hot water piping system is missing.\");\n}"}
{"prompt":"Genera sombras en la vista 3D para el solsticio de verano al mediodía.","completion":"View3D view3d = new FilteredElementCollector(doc).OfClass(typeof(View3D)).FirstOrDefault(v => !v.IsTemplate) as View3D;\nif(view3d != null)\n{\n    if(view3d.CanEnableSunAndShadows())\n    {\n        SunAndShadowSettings sunSettings = view3d.SunAndShadowSettings;\n        sunSettings.SunAndShadowType = SunAndShadowType.Still;\n        sunSettings.SetTimeAndDate(new DateTime(DateTime.Now.Year, 6, 21, 12, 0, 0));\n        view3d.ShadowsOn = true;\n    }\n    else\n    {\n        TaskDialog.Show(\"Advertencia\", \"No se pueden habilitar las sombras en esta vista 3D.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró una vista 3D en el proyecto.\");\n}"}
{"prompt":"Generate shadows in the 3D view for the summer solstice at noon.","completion":"View3D view3d = new FilteredElementCollector(doc).OfClass(typeof(View3D)).FirstOrDefault(v => !v.IsTemplate) as View3D;\nif(view3d != null)\n{\n    if(view3d.CanEnableSunAndShadows())\n    {\n        SunAndShadowSettings sunSettings = view3d.SunAndShadowSettings;\n        sunSettings.SunAndShadowType = SunAndShadowType.Still;\n        sunSettings.SetTimeAndDate(new DateTime(DateTime.Now.Year, 6, 21, 12, 0, 0));\n        view3d.ShadowsOn = true;\n    }\n    else\n    {\n        TaskDialog.Show(\"Warning\", \"Cannot enable shadows in this 3D view.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No 3D view found in the project.\");\n}"}
{"prompt":"Crea un suelo con un hueco circular en el centro.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\nif(level != null && floorType != null)\n{\n    CurveLoop outerLoop = CurveLoop.CreateViaRectangle(new XYZ(-10,-10,0), new XYZ(10,10,0));\n    XYZ center = XYZ.Zero;\n    double radius = UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters);\n    CurveLoop innerLoop = CurveLoop.CreateViaThruPoints(new List<XYZ> { center + new XYZ(radius,0,0), center + new XYZ(0,radius,0), center - new XYZ(radius,0,0), center - new XYZ(0,radius,0), center + new XYZ(radius,0,0) });\n    Floor.Create(doc, new List<CurveLoop> { outerLoop, innerLoop }, floorType.Id, level.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un nivel y un tipo de suelo para crear el elemento.\");\n}"}
{"prompt":"Create a floor with a circular hole in the center.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nFloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\nif(level != null && floorType != null)\n{\n    CurveLoop outerLoop = CurveLoop.CreateViaRectangle(new XYZ(-10,-10,0), new XYZ(10,10,0));\n    XYZ center = XYZ.Zero;\n    double radius = UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters);\n    CurveLoop innerLoop = CurveLoop.CreateViaThruPoints(new List<XYZ> { center + new XYZ(radius,0,0), center + new XYZ(0,radius,0), center - new XYZ(radius,0,0), center - new XYZ(0,radius,0), center + new XYZ(radius,0,0) });\n    Floor.Create(doc, new List<CurveLoop> { outerLoop, innerLoop }, floorType.Id, level.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A level and a floor type are needed to create the element.\");\n}"}
{"prompt":"Oculta todas las categorías de anotación en la vista activa.","completion":"ICollection<Category> categories = doc.Settings.Categories;\nint hiddenCount = 0;\nforeach(Category cat in categories)\n{\n    if(cat.CategoryType == CategoryType.Annotation && cat.get_AllowsVisibilityControl(doc.ActiveView))\n    {\n        if(cat.get_Visible(doc.ActiveView))\n        {\n             doc.ActiveView.SetCategoryHidden(cat.Id, true);\n             hiddenCount++;\n        }\n    }\n}\nTaskDialog.Show(\"Resultado\", $\"{hiddenCount} categorías de anotación han sido ocultadas.\");"}
{"prompt":"Hide all annotation categories in the active view.","completion":"ICollection<Category> categories = doc.Settings.Categories;\nint hiddenCount = 0;\nforeach(Category cat in categories)\n{\n    if(cat.CategoryType == CategoryType.Annotation && cat.get_AllowsVisibilityControl(doc.ActiveView))\n    {\n        if(cat.get_Visible(doc.ActiveView))\n        {\n             doc.ActiveView.SetCategoryHidden(cat.Id, true);\n             hiddenCount++;\n        }\n    }\n}\nTaskDialog.Show(\"Result\", $\"{hiddenCount} annotation categories have been hidden.\");"}
{"prompt":"Encuentra todas las vistas que no tienen una plantilla de vista asignada.","completion":"List<View> viewsWithoutTemplate = new FilteredElementCollector(doc).OfClass(typeof(View)).Cast<View>().Where(v => v.CanBePrinted() && !v.IsTemplate && v.ViewTemplateId == ElementId.InvalidElementId).ToList();\nTaskDialog.Show(\"Vistas sin Plantilla\", $\"Hay {viewsWithoutTemplate.Count} vistas sin plantilla asignada.\");\nif (viewsWithoutTemplate.Any()) new UIDocument(doc).Selection.SetElementIds(viewsWithoutTemplate.Select(v => v.Id).ToList());"}
{"prompt":"Find all views that do not have an assigned view template.","completion":"List<View> viewsWithoutTemplate = new FilteredElementCollector(doc).OfClass(typeof(View)).Cast<View>().Where(v => v.CanBePrinted() && !v.IsTemplate && v.ViewTemplateId == ElementId.InvalidElementId).ToList();\nTaskDialog.Show(\"Views without Template\", $\"There are {viewsWithoutTemplate.Count} views without an assigned template.\");\nif (viewsWithoutTemplate.Any()) new UIDocument(doc).Selection.SetElementIds(viewsWithoutTemplate.Select(v => v.Id).ToList());"}
{"prompt":"Establece el parámetro 'Marca' de todos los muros seleccionados a 'M-EXT-01'.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nint updatedCount = 0;\nif(selectedIds.Any())\n{\n    foreach(ElementId id in selectedIds)\n    {\n        Element elem = doc.GetElement(id);\n        if(elem is Wall)\n        {\n            elem.get_Parameter(BuiltInParameter.ALL_MODEL_MARK)?.Set(\"M-EXT-01\");\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{updatedCount} muros actualizados.\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No había muros seleccionados.\");\n}"}
{"prompt":"Set the 'Mark' parameter of all selected walls to 'W-EXT-01'.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nint updatedCount = 0;\nif(selectedIds.Any())\n{\n    foreach(ElementId id in selectedIds)\n    {\n        Element elem = doc.GetElement(id);\n        if(elem is Wall)\n        {\n            elem.get_Parameter(BuiltInParameter.ALL_MODEL_MARK)?.Set(\"W-EXT-01\");\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{updatedCount} walls were updated.\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No walls were selected.\");\n}"}
{"prompt":"Crea 5 worksets para las disciplinas de ingeniería.","completion":"if(doc.IsWorkshared)\n{\n    List<string> worksetNames = new List<string> { \"MEP_HVAC\", \"MEP_Plumbing\", \"MEP_Electrical\", \"STRUCT_Framing\", \"STRUCT_Foundations\" };\n    int createdCount = 0;\n    foreach(string name in worksetNames)\n    {\n        if(WorksetTable.IsWorksetNameUnique(doc, name))\n        {\n            Workset.Create(doc, name);\n            createdCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{createdCount} worksets nuevos han sido creados.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Esta acción requiere un modelo compartido (Workshared).\");\n}"}
{"prompt":"Create 5 worksets for engineering disciplines.","completion":"if(doc.IsWorkshared)\n{\n    List<string> worksetNames = new List<string> { \"MEP_HVAC\", \"MEP_Plumbing\", \"MEP_Electrical\", \"STRUCT_Framing\", \"STRUCT_Foundations\" };\n    int createdCount = 0;\n    foreach(string name in worksetNames)\n    {\n        if(WorksetTable.IsWorksetNameUnique(doc, name))\n        {\n            Workset.Create(doc, name);\n            createdCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{createdCount} new worksets were created.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"This action requires a workshared model.\");\n}"}
{"prompt":"Encuentra todas las familias de anotación y muestra sus nombres.","completion":"List<Family> annotationFamilies = new FilteredElementCollector(doc).OfClass(typeof(Family)).Cast<Family>().Where(f => f.FamilyCategory != null && f.FamilyCategory.CategoryType == CategoryType.Annotation).ToList();\nStringBuilder sb = new StringBuilder($\"Se encontraron {annotationFamilies.Count} Familias de Anotación:\\n\");\nforeach(var fam in annotationFamilies)\n{\n    sb.AppendLine(\"- \" + fam.Name);\n}\nTaskDialog.Show(\"Familias de Anotación\", sb.ToString());"}
{"prompt":"Find all annotation families and display their names.","completion":"List<Family> annotationFamilies = new FilteredElementCollector(doc).OfClass(typeof(Family)).Cast<Family>().Where(f => f.FamilyCategory != null && f.FamilyCategory.CategoryType == CategoryType.Annotation).ToList();\nStringBuilder sb = new StringBuilder($\"Found {annotationFamilies.Count} Annotation Families:\\n\");\nforeach(var fam in annotationFamilies)\n{\n    sb.AppendLine(\"- \" + fam.Name);\n}\nTaskDialog.Show(\"Annotation Families\", sb.ToString());"}
{"prompt":"Ajusta todas las ventanas para que tengan la altura del antepecho a 900mm.","completion":"double sillHeight = UnitUtils.ConvertToInternalUnits(900, UnitTypeId.Millimeters);\nList<FamilyInstance> windows = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().Cast<FamilyInstance>().ToList();\nint updatedCount = 0;\nforeach(FamilyInstance window in windows)\n{\n    Parameter sillHeightParam = window.get_Parameter(BuiltInParameter.INSTANCE_SILL_HEIGHT_PARAM);\n    if(sillHeightParam != null && !sillHeightParam.IsReadOnly) \n    {\n        sillHeightParam.Set(sillHeight);\n        updatedCount++;\n    }\n}\nTaskDialog.Show(\"Resultado\", $\"{updatedCount} ventanas actualizadas a una altura de antepecho de 900mm.\");"}
{"prompt":"Set the sill height of all windows to 900mm.","completion":"double sillHeight = UnitUtils.ConvertToInternalUnits(900, UnitTypeId.Millimeters);\nList<FamilyInstance> windows = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().Cast<FamilyInstance>().ToList();\nint updatedCount = 0;\nforeach(FamilyInstance window in windows)\n{\n    Parameter sillHeightParam = window.get_Parameter(BuiltInParameter.INSTANCE_SILL_HEIGHT_PARAM);\n    if(sillHeightParam != null && !sillHeightParam.IsReadOnly) \n    {\n        sillHeightParam.Set(sillHeight);\n        updatedCount++;\n    }\n}\nTaskDialog.Show(\"Result\", $\"{updatedCount} windows were updated to a 900mm sill height.\");"}
{"prompt":"Exporta todas las vistas 3D que empiezan con 'Coord' a imágenes PNG.","completion":"List<ElementId> viewsToExport = new FilteredElementCollector(doc).OfClass(typeof(View3D)).Cast<View3D>().Where(v => v.Name.StartsWith(\"Coord\") && !v.IsTemplate).Select(v => v.Id).ToList();\nif (viewsToExport.Any())\n{\n    string folderPath = \"C:/RevitExports/\";\n    if(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\n    ImageExportOptions options = new ImageExportOptions();\n    options.FilePath = System.IO.Path.Combine(folderPath, \"CoordView_\"); // Revit añadirá el nombre de la vista y la extensión.\n    options.ImageFileType = ImageFileType.PNG;\n    options.ZoomType = ZoomFitType.FitToPage;\n    options.ExportRange = ExportRange.SetOfViews;\n    options.SetViews(viewsToExport);\n    doc.ExportImage(options);\n    TaskDialog.Show(\"Éxito\", $\"{viewsToExport.Count} vistas 3D exportadas a imágenes PNG.\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No se encontraron vistas 3D que empiecen con 'Coord'.\");\n}"}
{"prompt":"Export all 3D views starting with 'Coord' to PNG images.","completion":"List<ElementId> viewsToExport = new FilteredElementCollector(doc).OfClass(typeof(View3D)).Cast<View3D>().Where(v => v.Name.StartsWith(\"Coord\") && !v.IsTemplate).Select(v => v.Id).ToList();\nif (viewsToExport.Any())\n{\n    string folderPath = \"C:/RevitExports/\";\n    if(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\n    ImageExportOptions options = new ImageExportOptions();\n    options.FilePath = System.IO.Path.Combine(folderPath, \"CoordView_\"); // Revit will append the view name and extension.\n    options.ImageFileType = ImageFileType.PNG;\n    options.ZoomType = ZoomFitType.FitToPage;\n    options.ExportRange = ExportRange.SetOfViews;\n    options.SetViews(viewsToExport);\n    doc.ExportImage(options);\n    TaskDialog.Show(\"Success\", $\"{viewsToExport.Count} 3D views were exported to PNG images.\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No 3D views starting with 'Coord' were found.\");\n}"}
{"prompt":"Crea una viga estructural entre (0,0,3) y (5,0,3) en el Nivel 2.","completion":"FamilySymbol beamType = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().FirstOrDefault(l => l.Name == \"Nivel 2\");\nif(beamType != null && level != null)\n{\n    if(!beamType.IsActive) beamType.Activate();\n    XYZ start = new XYZ(0, 0, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters));\n    XYZ end = new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters));\n    Line beamCurve = Line.CreateBound(start, end);\n    doc.Create.NewFamilyInstance(beamCurve, beamType, level, StructuralType.Beam);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un tipo de viga y el 'Nivel 2' para crear el elemento.\");\n}"}
{"prompt":"Create a structural beam between (0,0,3) and (5,0,3) on Level 2.","completion":"FamilySymbol beamType = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().FirstOrDefault(l => l.Name == \"Level 2\");\nif(beamType != null && level != null)\n{\n    if(!beamType.IsActive) beamType.Activate();\n    XYZ start = new XYZ(0, 0, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters));\n    XYZ end = new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters));\n    Line beamCurve = Line.CreateBound(start, end);\n    doc.Create.NewFamilyInstance(beamCurve, beamType, level, StructuralType.Beam);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A beam type and 'Level 2' are required to create the element.\");\n}"}
{"prompt":"Crea un nuevo parámetro de proyecto compartido de texto llamado 'Notas Adicionales' para muros y puertas.","completion":"string paramName = \"Notas Adicionales\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ParameterElement)).Any(p => p.Name == paramName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El parámetro '{paramName}' ya existe.\");\n}\nelse\n{\n    DefinitionFile defFile = doc.Application.OpenSharedParameterFile();\n    if (defFile == null || !System.IO.File.Exists(defFile.Filename))\n    {\n        TaskDialog.Show(\"Error\", \"Se necesita un archivo de parámetros compartidos configurado en Revit.\");\n    }\n    else\n    {\n        DefinitionGroup group = defFile.Groups.get_Item(\"General\") ?? defFile.Groups.Create(\"General\");\n        Definition definition = group.Definitions.get_Item(paramName) ?? group.Definitions.Create(new ExternalDefinitionCreationOptions(paramName, SpecTypeId.String.Text));\n        CategorySet categories = doc.Application.Create.NewCategorySet();\n        categories.Insert(doc.Settings.Categories.get_Item(BuiltInCategory.OST_Walls));\n        categories.Insert(doc.Settings.Categories.get_Item(BuiltInCategory.OST_Doors));\n        doc.ParameterBindings.Insert(doc.Application.Create.NewInstanceBinding(categories), (ExternalDefinition)definition, BuiltInParameterGroup.PG_DATA);\n        TaskDialog.Show(\"Éxito\", $\"Parámetro '{paramName}' creado y asignado.\");\n    }\n}"}
{"prompt":"Create a new shared text project parameter named 'Additional Notes' for walls and doors.","completion":"string paramName = \"Additional Notes\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ParameterElement)).Any(p => p.Name == paramName))\n{\n    TaskDialog.Show(\"Warning\", $\"Parameter '{paramName}' already exists.\");\n}\nelse\n{\n    DefinitionFile defFile = doc.Application.OpenSharedParameterFile();\n    if (defFile == null || !System.IO.File.Exists(defFile.Filename))\n    {\n        TaskDialog.Show(\"Error\", \"A shared parameter file needs to be configured in Revit.\");\n    }\n    else\n    {\n        DefinitionGroup group = defFile.Groups.get_Item(\"General\") ?? defFile.Groups.Create(\"General\");\n        Definition definition = group.Definitions.get_Item(paramName) ?? group.Definitions.Create(new ExternalDefinitionCreationOptions(paramName, SpecTypeId.String.Text));\n        CategorySet categories = doc.Application.Create.NewCategorySet();\n        categories.Insert(doc.Settings.Categories.get_Item(BuiltInCategory.OST_Walls));\n        categories.Insert(doc.Settings.Categories.get_Item(BuiltInCategory.OST_Doors));\n        doc.ParameterBindings.Insert(doc.Application.Create.NewInstanceBinding(categories), (ExternalDefinition)definition, BuiltInParameterGroup.PG_DATA);\n        TaskDialog.Show(\"Success\", $\"Parameter '{paramName}' created and assigned.\");\n    }\n}"}
{"prompt":"Crea un nivel 'Roof Terrace' a 15m.","completion":"string levelName = \"Roof Terrace\";\nif (new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == levelName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El nivel '{levelName}' ya existe.\");\n}\nelse\n{\n    double elev = UnitUtils.ConvertToInternalUnits(15, UnitTypeId.Meters);\n    Level newLevel = Level.Create(doc, elev);\n    newLevel.Name = levelName;\n    TaskDialog.Show(\"Éxito\", $\"Nivel '{levelName}' creado.\");\n}"}
{"prompt":"Create a 'Roof Terrace' level at 15m.","completion":"string levelName = \"Roof Terrace\";\nif (new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == levelName))\n{\n    TaskDialog.Show(\"Warning\", $\"Level '{levelName}' already exists.\");\n}\nelse\n{\n    double elev = UnitUtils.ConvertToInternalUnits(15, UnitTypeId.Meters);\n    Level newLevel = Level.Create(doc, elev);\n    newLevel.Name = levelName;\n    TaskDialog.Show(\"Success\", $\"Level '{levelName}' created.\");\n}"}
{"prompt":"Coloca postes de iluminación cada 10m en un camino de 100m.","completion":"FamilySymbol lightSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_LightingFixtures).WhereElementIsElementType().FirstOrDefault(s => s.Name.Contains(\"Post\") || s.Name.Contains(\"Pole\")) as FamilySymbol;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nif(lightSymbol != null && level != null)\n{\n    if(!lightSymbol.IsActive) lightSymbol.Activate();\n    double spacing = UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters);\n    for(int i = 0; i <= 10; i++)\n    {\n        XYZ point = new XYZ(i * spacing, 0, 0);\n        doc.Create.NewFamilyInstance(point, lightSymbol, level, StructuralType.NonStructural);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un tipo de familia de poste de luz y un nivel.\");\n}"}
{"prompt":"Place lighting posts every 10m along a 100m path.","completion":"FamilySymbol lightSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_LightingFixtures).WhereElementIsElementType().FirstOrDefault(s => s.Name.Contains(\"Post\") || s.Name.Contains(\"Pole\")) as FamilySymbol;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nif(lightSymbol != null && level != null)\n{\n    if(!lightSymbol.IsActive) lightSymbol.Activate();\n    double spacing = UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters);\n    for(int i = 0; i <= 10; i++)\n    {\n        XYZ point = new XYZ(i * spacing, 0, 0);\n        doc.Create.NewFamilyInstance(point, lightSymbol, level, StructuralType.NonStructural);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A light post family type and a level are required.\");\n}"}
{"prompt":"Genera una cuadrícula de columnas 5x5 con separación de 8 metros.","completion":"FamilySymbol columnSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nif(columnSymbol != null && level != null)\n{\n    if(!columnSymbol.IsActive) columnSymbol.Activate();\n    double spacing = UnitUtils.ConvertToInternalUnits(8, UnitTypeId.Meters);\n    for(int i=0; i<5; i++)\n    {\n        for(int j=0; j<5; j++)\n        {\n            doc.Create.NewFamilyInstance(new XYZ(i*spacing, j*spacing, 0), columnSymbol, level, StructuralType.Column);\n        }\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un tipo de columna estructural y un nivel.\");\n}"}
{"prompt":"Generate a 5x5 column grid with 8-meter spacing.","completion":"FamilySymbol columnSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nif(columnSymbol != null && level != null)\n{\n    if(!columnSymbol.IsActive) columnSymbol.Activate();\n    double spacing = UnitUtils.ConvertToInternalUnits(8, UnitTypeId.Meters);\n    for(int i=0; i<5; i++)\n    {\n        for(int j=0; j<5; j++)\n        {\n            doc.Create.NewFamilyInstance(new XYZ(i*spacing, j*spacing, 0), columnSymbol, level, StructuralType.Column);\n        }\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A structural column type and a level are required.\");\n}"}
{"prompt":"Crea una habitación circular con un radio de 5 metros.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nViewPlan planView = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).FirstOrDefault(v => v.GenLevel.Id == level.Id) as ViewPlan;\nif(level != null && planView != null)\n{\n    double radius = UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters);\n    CurveLoop profile = CurveLoop.CreateViaThruPoints(new List<XYZ> { new XYZ(radius,0,0), new XYZ(0,radius,0), new XYZ(-radius,0,0), new XYZ(0,-radius,0), new XYZ(radius,0,0) });\n    ICollection<ElementId> sepLines = doc.Create.NewRoomBoundaryLines(planView.SketchPlane, profile, planView);\n    if (sepLines.Any()) doc.Create.NewRoom(level, new UV(0,0));\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un nivel y una vista de planta asociada.\");\n}"}
{"prompt":"Create a circular room with a 5-meter radius.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nViewPlan planView = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).FirstOrDefault(v => v.GenLevel.Id == level.Id) as ViewPlan;\nif(level != null && planView != null)\n{\n    double radius = UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters);\n    CurveLoop profile = CurveLoop.CreateViaThruPoints(new List<XYZ> { new XYZ(radius,0,0), new XYZ(0,radius,0), new XYZ(-radius,0,0), new XYZ(0,-radius,0), new XYZ(radius,0,0) });\n    ICollection<ElementId> sepLines = doc.Create.NewRoomBoundaryLines(planView.SketchPlane, profile, planView);\n    if (sepLines.Any()) doc.Create.NewRoom(level, new UV(0,0));\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A level and an associated plan view are required.\");\n}"}
{"prompt":"Importa topografía georreferenciada desde un archivo LandXML.","completion":"string filePath = \"C:/CAD/site.xml\";\nif (System.IO.File.Exists(filePath))\n{\n    LandXMLImportOptions options = new LandXMLImportOptions();\n    options.XYLengthUnit = XYLengthUnit.Meter;\n    doc.Import(filePath, options);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"No se encontró el archivo LandXML en: {filePath}\");\n}"}
{"prompt":"Import a georeferenced survey from a LandXML file.","completion":"string filePath = \"C:/CAD/site.xml\";\nif (System.IO.File.Exists(filePath))\n{\n    LandXMLImportOptions options = new LandXMLImportOptions();\n    options.XYLengthUnit = XYLengthUnit.Meter;\n    doc.Import(filePath, options);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"LandXML file not found at: {filePath}\");\n}"}
{"prompt":"Crea una vista de plano de plafón reflejado para el Nivel 1.","completion":"string levelName = \"Nivel 1\";\nstring viewName = \"Plano de Plafón Nivel 1\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).Any(v => v.Name == viewName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"La vista '{viewName}' ya existe.\");\n}\nelse\n{\n    ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.CeilingPlan);\n    Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == levelName) as Level;\n    if(vft != null && level1 != null)\n    {\n        ViewPlan rcp = ViewPlan.Create(doc, vft.Id, level1.Id);\n        rcp.Name = viewName;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró el tipo de vista de plano de plafón o el Nivel 1.\");\n    }\n}"}
{"prompt":"Create a Reflected Ceiling Plan view for Level 1.","completion":"string levelName = \"Level 1\";\nstring viewName = \"Level 1 Ceiling Plan\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).Any(v => v.Name == viewName))\n{\n    TaskDialog.Show(\"Warning\", $\"View '{viewName}' already exists.\");\n}\nelse\n{\n    ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.CeilingPlan);\n    Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == levelName) as Level;\n    if(vft != null && level1 != null)\n    {\n        ViewPlan rcp = ViewPlan.Create(doc, vft.Id, level1.Id);\n        rcp.Name = viewName;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Ceiling Plan view type or Level 1 not found.\");\n    }\n}"}
{"prompt":"Añade un plano de referencia horizontal llamado 'Eje Central A'.","completion":"string rpName = \"Eje Central A\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ReferencePlane)).Any(rp => rp.Name == rpName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El plano de referencia '{rpName}' ya existe.\");\n}\nelse\n{\n    ReferencePlane rp = ReferencePlane.Create(doc, XYZ.Zero, XYZ.BasisX, XYZ.BasisZ, doc.ActiveView);\n    rp.Name = rpName;\n}"}
{"prompt":"Add a horizontal reference plane named 'Centerline A'.","completion":"string rpName = \"Centerline A\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ReferencePlane)).Any(rp => rp.Name == rpName))\n{\n    TaskDialog.Show(\"Warning\", $\"Reference plane '{rpName}' already exists.\");\n}\nelse\n{\n    ReferencePlane rp = ReferencePlane.Create(doc, XYZ.Zero, XYZ.BasisX, XYZ.BasisZ, doc.ActiveView);\n    rp.Name = rpName;\n}"}
{"prompt":"Duplica el nivel 1 con un desfase de 3m y llámalo 'Mezanine'.","completion":"string levelName = \"Mezanine\";\nif (new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == levelName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El nivel '{levelName}' ya existe.\");\n}\nelse\n{\n    Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\n    if(level1 != null)\n    {\n        double newElevation = level1.ProjectElevation + UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters);\n        Level newLevel = Level.Create(doc, newElevation);\n        newLevel.Name = levelName;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró el 'Nivel 1' para duplicar.\");\n    }\n}"}
{"prompt":"Duplicate level 1 with a 3m offset and name it 'Mezzanine'.","completion":"string levelName = \"Mezzanine\";\nif (new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == levelName))\n{\n    TaskDialog.Show(\"Warning\", $\"Level '{levelName}' already exists.\");\n}\nelse\n{\n    Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\n    if(level1 != null)\n    {\n        double newElevation = level1.ProjectElevation + UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters);\n        Level newLevel = Level.Create(doc, newElevation);\n        newLevel.Name = levelName;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"'Level 1' not found to duplicate.\");\n    }\n}"}
{"prompt":"Etiqueta todas las habitaciones con su área.","completion":"View activeView = doc.ActiveView;\nList<Room> rooms = new FilteredElementCollector(doc, activeView.Id).OfCategory(BuiltInCategory.OST_Rooms).WhereElementIsNotElementType().Cast<Room>().ToList();\nint taggedCount = 0;\nforeach(Room room in rooms)\n{\n    if(room.Location != null)\n    {\n        doc.Create.NewRoomTag(new LinkElementId(room.Id), new UV(room.Location.Point.X, room.Location.Point.Y), activeView.Id);\n        taggedCount++;\n    }\n}\nTaskDialog.Show(\"Resultado\", $\"{taggedCount} habitaciones etiquetadas en la vista actual.\");"}
{"prompt":"Tag all rooms with their area.","completion":"View activeView = doc.ActiveView;\nList<Room> rooms = new FilteredElementCollector(doc, activeView.Id).OfCategory(BuiltInCategory.OST_Rooms).WhereElementIsNotElementType().Cast<Room>().ToList();\nint taggedCount = 0;\nforeach(Room room in rooms)\n{\n    if(room.Location != null)\n    {\n        doc.Create.NewRoomTag(new LinkElementId(room.Id), new UV(room.Location.Point.X, room.Location.Point.Y), activeView.Id);\n        taggedCount++;\n    }\n}\nTaskDialog.Show(\"Result\", $\"{taggedCount} rooms were tagged in the current view.\");"}
{"prompt":"Exporta una lista de materiales a un archivo de texto.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"materials.txt\");\nList<Material> materials = new FilteredElementCollector(doc).OfClass(typeof(Material)).Cast<Material>().ToList();\nList<string> materialNames = new List<string>();\nmaterialNames.Add(\"Nombre del Material\");\nforeach(Material m in materials)\n{\n    materialNames.Add(m.Name);\n}\nSystem.IO.File.WriteAllLines(filePath, materialNames);\nTaskDialog.Show(\"Exportación Completa\", $\"{materials.Count} materiales exportados a: {filePath}\");"}
{"prompt":"Export a list of materials to a text file.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"materials.txt\");\nList<Material> materials = new FilteredElementCollector(doc).OfClass(typeof(Material)).Cast<Material>().ToList();\nList<string> materialNames = new List<string>();\nmaterialNames.Add(\"Material Name\");\nforeach(Material m in materials)\n{\n    materialNames.Add(m.Name);\n}\nSystem.IO.File.WriteAllLines(filePath, materialNames);\nTaskDialog.Show(\"Export Complete\", $\"{materials.Count} materials exported to: {filePath}\");"}
{"prompt":"Aísla temporalmente todo el mobiliario en la vista activa.","completion":"ICollection<ElementId> furnitureIds = new FilteredElementCollector(doc, doc.ActiveView.Id).OfCategory(BuiltInCategory.OST_Furniture).WhereElementIsNotElementType().ToElementIds();\nif(furnitureIds.Any())\n{\n    doc.ActiveView.IsolateElementsTemporary(furnitureIds);\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No se encontró mobiliario en la vista activa para aislar.\");\n}"}
{"prompt":"Temporarily isolate all furniture in the active view.","completion":"ICollection<ElementId> furnitureIds = new FilteredElementCollector(doc, doc.ActiveView.Id).OfCategory(BuiltInCategory.OST_Furniture).WhereElementIsNotElementType().ToElementIds();\nif(furnitureIds.Any())\n{\n    doc.ActiveView.IsolateElementsTemporary(furnitureIds);\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No furniture was found in the active view to isolate.\");\n}"}

{"prompt":"Coloca un ducto redondo de 200mm de diámetro.","completion":"DuctType ductType = new FilteredElementCollector(doc).OfClass(typeof(DuctType)).FirstOrDefault(dt => dt.Shape == ConnectorProfileType.Round) as DuctType;\nMEPSystemType systemType = new FilteredElementCollector(doc).OfClass(typeof(MEPSystemType)).Cast<MEPSystemType>().FirstOrDefault(st => st.SystemClassification == MEPSystemClassification.SupplyAir);\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nif(ductType != null && systemType != null && level != null)\n{\n    Duct duct = Duct.Create(doc, systemType.Id, ductType.Id, level.Id, new XYZ(0,0,3), new XYZ(10,0,3));\n    duct.get_Parameter(BuiltInParameter.RBS_CURVE_DIAMETER_PARAM).Set(UnitUtils.ConvertToInternalUnits(200, UnitTypeId.Millimeters));\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un tipo de ducto redondo, un sistema de aire y un nivel en el proyecto.\");\n}"}
{"prompt":"Place a 200mm diameter round duct.","completion":"DuctType ductType = new FilteredElementCollector(doc).OfClass(typeof(DuctType)).FirstOrDefault(dt => dt.Shape == ConnectorProfileType.Round) as DuctType;\nMEPSystemType systemType = new FilteredElementCollector(doc).OfClass(typeof(MEPSystemType)).Cast<MEPSystemType>().FirstOrDefault(st => st.SystemClassification == MEPSystemClassification.SupplyAir);\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nif(ductType != null && systemType != null && level != null)\n{\n    Duct duct = Duct.Create(doc, systemType.Id, ductType.Id, level.Id, new XYZ(0,0,3), new XYZ(10,0,3));\n    duct.get_Parameter(BuiltInParameter.RBS_CURVE_DIAMETER_PARAM).Set(UnitUtils.ConvertToInternalUnits(200, UnitTypeId.Millimeters));\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A round duct type, an air system, and a level are required in the project.\");\n}"}
{"prompt":"Crea un suelo con un contorno definido por el usuario.","completion":"UIDocument uidoc = new UIDocument(doc);\nIList<Reference> pickedRefs = uidoc.Selection.PickObjects(ObjectType.Element, \"Selecciona las líneas de contorno cerradas\");\nCurveLoop profile = new CurveLoop();\nforeach(Reference r in pickedRefs)\n{\n    ModelCurve mc = doc.GetElement(r) as ModelCurve;\n    if(mc != null) profile.Append(mc.GeometryCurve);\n}\nFloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\nLevel level = doc.ActiveView.GenLevel;\nif(floorType != null && level != null && !profile.IsOpen())\n{\n    Floor.Create(doc, new List<CurveLoop>{profile}, floorType.Id, level.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un tipo de suelo, un nivel y un contorno cerrado de líneas.\");\n}"}
{"prompt":"Create a floor with a user-defined boundary.","completion":"UIDocument uidoc = new UIDocument(doc);\nIList<Reference> pickedRefs = uidoc.Selection.PickObjects(ObjectType.Element, \"Select the closed boundary lines\");\nCurveLoop profile = new CurveLoop();\nforeach(Reference r in pickedRefs)\n{\n    ModelCurve mc = doc.GetElement(r) as ModelCurve;\n    if(mc != null) profile.Append(mc.GeometryCurve);\n}\nFloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\nLevel level = doc.ActiveView.GenLevel;\nif(floorType != null && level != null && !profile.IsOpen())\n{\n    Floor.Create(doc, new List<CurveLoop>{profile}, floorType.Id, level.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A floor type, a level, and a closed boundary of lines are required.\");\n}"}
{"prompt":"Encuentra todos los elementos dentro de la habitación 'Sala de Juntas'.","completion":"Room room = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).FirstOrDefault(r => r.Name == \"Sala de Juntas\") as Room;\nif(room != null)\n{\n    ElementIntersectsElementFilter filter = new ElementIntersectsElementFilter(room);\n    List<Element> elementsInRoom = new FilteredElementCollector(doc, doc.ActiveView.Id).WherePasses(filter).WhereElementIsNotElementType().ToList();\n    TaskDialog.Show(\"Resultado\", $\"Se encontraron {elementsInRoom.Count} elementos dentro de la habitación '{room.Name}'.\");\n    if (elementsInRoom.Any()) new UIDocument(doc).Selection.SetElementIds(elementsInRoom.Select(e => e.Id).ToList());\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró la habitación 'Sala de Juntas'.\");\n}"}
{"prompt":"Find all elements inside the 'Conference Room'.","completion":"Room room = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).FirstOrDefault(r => r.Name == \"Conference Room\") as Room;\nif(room != null)\n{\n    ElementIntersectsElementFilter filter = new ElementIntersectsElementFilter(room);\n    List<Element> elementsInRoom = new FilteredElementCollector(doc, doc.ActiveView.Id).WherePasses(filter).WhereElementIsNotElementType().ToList();\n    TaskDialog.Show(\"Result\", $\"Found {elementsInRoom.Count} elements inside the room '{room.Name}'.\");\n    if (elementsInRoom.Any()) new UIDocument(doc).Selection.SetElementIds(elementsInRoom.Select(e => e.Id).ToList());\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Room 'Conference Room' not found.\");\n}"}
{"prompt":"Exporta todos los muros con un parámetro de Marca a un archivo CSV.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"walls_mark.csv\");\nList<Wall> walls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().Cast<Wall>().ToList();\nList<string> lines = new List<string>{\"ElementId,Mark\"};\nforeach(var w in walls)\n{\n    Parameter p = w.get_Parameter(BuiltInParameter.ALL_MODEL_MARK);\n    if(p != null && p.HasValue)\n    {\n        lines.Add($\"{w.Id.IntegerValue},{p.AsString()}\");\n    }\n}\nSystem.IO.File.WriteAllLines(filePath, lines);\nTaskDialog.Show(\"Exportación Completa\", $\"Datos de {lines.Count - 1} muros exportados a: {filePath}\");"}
{"prompt":"Export all walls with a Mark parameter to a CSV file.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"walls_mark.csv\");\nList<Wall> walls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().Cast<Wall>().ToList();\nList<string> lines = new List<string>{\"ElementId,Mark\"};\nforeach(var w in walls)\n{\n    Parameter p = w.get_Parameter(BuiltInParameter.ALL_MODEL_MARK);\n    if(p != null && p.HasValue)\n    {\n        lines.Add($\"{w.Id.IntegerValue},{p.AsString()}\");\n    }\n}\nSystem.IO.File.WriteAllLines(filePath, lines);\nTaskDialog.Show(\"Export Complete\", $\"Data from {lines.Count - 1} walls exported to: {filePath}\");"}
{"prompt":"Crea un nuevo tipo de muro 'Muro Genérico 300mm' con un grosor de 30cm.","completion":"string newTypeName = \"Muro Genérico 300mm\";\nif (new FilteredElementCollector(doc).OfClass(typeof(WallType)).Any(wt => wt.Name == newTypeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de muro '{newTypeName}' ya existe.\");\n}\nelse\n{\n    WallType oldWallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\n    if(oldWallType != null)\n    {\n        WallType newWallType = oldWallType.Duplicate(newTypeName) as WallType;\n        CompoundStructure cs = newWallType.GetCompoundStructure();\n        if(cs != null && cs.GetLayerCount() > 0) \n        {\n            cs.SetLayerWidth(cs.GetFirstCoreLayerIndex(), UnitUtils.ConvertToInternalUnits(300, UnitTypeId.Millimeters));\n            newWallType.SetCompoundStructure(cs);\n            TaskDialog.Show(\"Éxito\", $\"Tipo de muro '{newTypeName}' creado.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró un tipo de muro para duplicar.\");\n    }\n}"}
{"prompt":"Create a new wall type 'Generic Wall 300mm' with a thickness of 30cm.","completion":"string newTypeName = \"Generic Wall 300mm\";\nif (new FilteredElementCollector(doc).OfClass(typeof(WallType)).Any(wt => wt.Name == newTypeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Wall type '{newTypeName}' already exists.\");\n}\nelse\n{\n    WallType oldWallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\n    if(oldWallType != null)\n    {\n        WallType newWallType = oldWallType.Duplicate(newTypeName) as WallType;\n        CompoundStructure cs = newWallType.GetCompoundStructure();\n        if(cs != null && cs.GetLayerCount() > 0) \n        {\n            cs.SetLayerWidth(cs.GetFirstCoreLayerIndex(), UnitUtils.ConvertToInternalUnits(300, UnitTypeId.Millimeters));\n            newWallType.SetCompoundStructure(cs);\n            TaskDialog.Show(\"Success\", $\"Wall type '{newTypeName}' created.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No wall type found to duplicate.\");\n    }\n}"}
{"prompt":"Cambia el tipo de todos los muros seleccionados a 'Muro Exterior'.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    WallType targetWallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).Cast<WallType>().FirstOrDefault(wt => wt.Name == \"Muro Exterior\");\n    if(targetWallType != null)\n    {\n        int updatedCount = 0;\n        foreach(ElementId id in selectedIds)\n        {\n            Wall wall = doc.GetElement(id) as Wall;\n            if(wall != null) \n            {\n                wall.ChangeTypeId(targetWallType.Id);\n                updatedCount++;\n            }\n        }\n        TaskDialog.Show(\"Resultado\", $\"{updatedCount} muros cambiados al tipo '{targetWallType.Name}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró el tipo de muro 'Muro Exterior'.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No había elementos seleccionados.\");\n}"}
{"prompt":"Change the type of all selected walls to 'Exterior Wall'.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    WallType targetWallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).Cast<WallType>().FirstOrDefault(wt => wt.Name == \"Exterior Wall\");\n    if(targetWallType != null)\n    {\n        int updatedCount = 0;\n        foreach(ElementId id in selectedIds)\n        {\n            Wall wall = doc.GetElement(id) as Wall;\n            if(wall != null) \n            {\n                wall.ChangeTypeId(targetWallType.Id);\n                updatedCount++;\n            }\n        }\n        TaskDialog.Show(\"Result\", $\"{updatedCount} walls changed to type '{targetWallType.Name}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Wall type 'Exterior Wall' not found.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No elements were selected.\");\n}"}
{"prompt":"Renombrar el Nivel 'Nivel 1' a 'Planta Baja'.","completion":"string oldName = \"Nivel 1\";\nstring newName = \"Planta Baja\";\nif (new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == newName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"Ya existe un nivel llamado '{newName}'.\");\n}\nelse\n{\n    Level levelToRename = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().FirstOrDefault(l => l.Name == oldName);\n    if(levelToRename != null)\n    {\n        levelToRename.Name = newName;\n        TaskDialog.Show(\"Éxito\", $\"Nivel '{oldName}' renombrado a '{newName}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", $\"No se encontró el nivel '{oldName}'.\");\n    }\n}"}
{"prompt":"Rename the 'Level 1' level to 'Ground Floor'.","completion":"string oldName = \"Level 1\";\nstring newName = \"Ground Floor\";\nif (new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == newName))\n{\n    TaskDialog.Show(\"Warning\", $\"A level named '{newName}' already exists.\");\n}\nelse\n{\n    Level levelToRename = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().FirstOrDefault(l => l.Name == oldName);\n    if(levelToRename != null)\n    {\n        levelToRename.Name = newName;\n        TaskDialog.Show(\"Success\", $\"Level '{oldName}' renamed to '{newName}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", $\"Level '{oldName}' not found.\");\n    }\n}"}
{"prompt":"Crea un pilar estructural de 300x300mm en la coordenada (10,10,0).","completion":"FamilySymbol columnType = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().Cast<FamilySymbol>().FirstOrDefault(fs => fs.Name.Contains(\"300x300\"));\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nif(columnType != null && level != null)\n{\n    if(!columnType.IsActive) columnType.Activate();\n    XYZ point = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0);\n    doc.Create.NewFamilyInstance(point, columnType, level, StructuralType.Column);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un tipo de pilar de 300x300 y un nivel para crear el elemento.\");\n}"}
{"prompt":"Create a 300x300mm structural column at coordinate (10,10,0).","completion":"FamilySymbol columnType = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().Cast<FamilySymbol>().FirstOrDefault(fs => fs.Name.Contains(\"300x300\"));\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nif(columnType != null && level != null)\n{\n    if(!columnType.IsActive) columnType.Activate();\n    XYZ point = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0);\n    doc.Create.NewFamilyInstance(point, columnType, level, StructuralType.Column);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A 300x300 column type and a level are required to create the element.\");\n}"}
{"prompt":"Alinea todos los muros seleccionados con el eje '1'.","completion":"UIDocument uidoc = new UIDocument(doc);\nGrid targetGrid = new FilteredElementCollector(doc).OfClass(typeof(Grid)).Cast<Grid>().FirstOrDefault(g => g.Name == \"1\");\nICollection<ElementId> selectedWallIds = uidoc.Selection.GetElementIds();\nif (targetGrid != null && selectedWallIds.Any())\n{\n    int movedCount = 0;\n    foreach(ElementId wallId in selectedWallIds)\n    {\n        Wall wall = doc.GetElement(wallId) as Wall;\n        if (wall != null)\n        {\n            doc.Create.NewAlignment(doc.ActiveView, new Reference(wall), new Reference(targetGrid));\n            movedCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{movedCount} muros alineados con el eje '1'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el eje '1' o no había muros seleccionados.\");\n}"}
{"prompt":"Align all selected walls with grid '1'.","completion":"UIDocument uidoc = new UIDocument(doc);\nGrid targetGrid = new FilteredElementCollector(doc).OfClass(typeof(Grid)).Cast<Grid>().FirstOrDefault(g => g.Name == \"1\");\nICollection<ElementId> selectedWallIds = uidoc.Selection.GetElementIds();\nif (targetGrid != null && selectedWallIds.Any())\n{\n    int movedCount = 0;\n    foreach(ElementId wallId in selectedWallIds)\n    {\n        Wall wall = doc.GetElement(wallId) as Wall;\n        if (wall != null)\n        {\n            doc.Create.NewAlignment(doc.ActiveView, new Reference(wall), new Reference(targetGrid));\n            movedCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{movedCount} walls aligned with grid '1'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Grid '1' not found or no walls were selected.\");\n}"}
{"prompt":"Aplica el material 'Hormigón' a todos los suelos del proyecto.","completion":"TaskDialog.Show(\"Acción Peligrosa\", \"Aplicar un material a todos los suelos modifica el TIPO de suelo, afectando a todos los ejemplares de ese tipo en el proyecto. Si es lo que deseas, pide 'Modifica el tipo de suelo para que use Hormigón'. Para cambiar solo un suelo, duplica primero su tipo.\");"}
{"prompt":"Apply the 'Concrete' material to all floors in the project.","completion":"TaskDialog.Show(\"Dangerous Action\", \"Applying a material to all floors modifies the floor TYPE, affecting all instances of that type in the project. If this is desired, ask 'Modify the floor type to use Concrete'. To change a single floor, duplicate its type first.\");"}
{"prompt":"Borra todos los grupos de anotación del modelo.","completion":"List<ElementId> annotationGroups = new FilteredElementCollector(doc).OfClass(typeof(Group)).Cast<Group>().Where(g => g.Category != null && g.Category.CategoryType == CategoryType.Annotation).Select(g => g.Id).ToList();\nif(annotationGroups.Any())\n{\n    int count = annotationGroups.Count;\n    doc.Delete(annotationGroups);\n    TaskDialog.Show(\"Resultado\", $\"{count} grupos de anotación eliminados.\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No se encontraron grupos de anotación para eliminar.\");\n}"}
{"prompt":"Delete all annotation groups from the model.","completion":"List<ElementId> annotationGroups = new FilteredElementCollector(doc).OfClass(typeof(Group)).Cast<Group>().Where(g => g.Category != null && g.Category.CategoryType == CategoryType.Annotation).Select(g => g.Id).ToList();\nif(annotationGroups.Any())\n{\n    int count = annotationGroups.Count;\n    doc.Delete(annotationGroups);\n    TaskDialog.Show(\"Result\", $\"{count} annotation groups were deleted.\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No annotation groups were found to delete.\");\n}"}
{"prompt":"Obtén la geometría sólida de un pilar seleccionado.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un pilar\");\nif (pickedRef != null)\n{\n    Element elem = doc.GetElement(pickedRef);\n    if(elem != null && (elem.Category.Id.IntegerValue == (int)BuiltInCategory.OST_StructuralColumns || elem.Category.Id.IntegerValue == (int)BuiltInCategory.OST_Columns))\n    {\n        Options opt = new Options() { ComputeReferences = true, DetailLevel = ViewDetailLevel.Fine };\n        GeometryElement geoElem = elem.get_Geometry(opt);\n        Solid solid = geoElem.OfType<Solid>().FirstOrDefault(s => s.Volume > 0);\n        if(solid != null) TaskDialog.Show(\"Geometría\", \"Se obtuvo el sólido del pilar.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no es un pilar.\");\n    }\n}"}
{"prompt":"Get the solid geometry of a selected column.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a column\");\nif (pickedRef != null)\n{\n    Element elem = doc.GetElement(pickedRef);\n    if(elem != null && (elem.Category.Id.IntegerValue == (int)BuiltInCategory.OST_StructuralColumns || elem.Category.Id.IntegerValue == (int)BuiltInCategory.OST_Columns))\n    {\n        Options opt = new Options() { ComputeReferences = true, DetailLevel = ViewDetailLevel.Fine };\n        GeometryElement geoElem = elem.get_Geometry(opt);\n        Solid solid = geoElem.OfType<Solid>().FirstOrDefault(s => s.Volume > 0);\n        if(solid != null) TaskDialog.Show(\"Geometry\", \"Retrieved the solid from the column.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element is not a column.\");\n    }\n}"}
{"prompt":"Crea una dimensión alineada entre dos muros paralelos.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference r1 = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona el primer muro\");\nif (r1 == null) return;\nReference r2 = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona el segundo muro\");\nif (r2 == null) return;\nWall w1 = doc.GetElement(r1) as Wall;\nWall w2 = doc.GetElement(r2) as Wall;\nif (w1 != null && w2 != null)\n{\n    Line l1 = (w1.Location as LocationCurve).Curve as Line;\n    Line l2 = (w2.Location as LocationCurve).Curve as Line;\n    if (l1 != null && l2 != null && (l1.Direction.IsAlmostEqualTo(l2.Direction) || l1.Direction.IsAlmostEqualTo(l2.Direction.Negate())))\n    {\n        ReferenceArray refs = new ReferenceArray();\n        refs.Append(r1);\n        refs.Append(r2);\n        Line dimLine = Line.CreateBound(l1.GetEndPoint(0) + l1.Direction.Normalize() * 2, l2.GetEndPoint(0) + l2.Direction.Normalize() * 2);\n        doc.Create.NewDimension(doc.ActiveView, dimLine, refs);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Los elementos seleccionados no son muros rectos y paralelos.\");\n    }\n}"}
{"prompt":"Create an aligned dimension between two parallel walls.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference r1 = uidoc.Selection.PickObject(ObjectType.Element, \"Select the first wall\");\nif (r1 == null) return;\nReference r2 = uidoc.Selection.PickObject(ObjectType.Element, \"Select the second wall\");\nif (r2 == null) return;\nWall w1 = doc.GetElement(r1) as Wall;\nWall w2 = doc.GetElement(r2) as Wall;\nif (w1 != null && w2 != null)\n{\n    Line l1 = (w1.Location as LocationCurve).Curve as Line;\n    Line l2 = (w2.Location as LocationCurve).Curve as Line;\n    if (l1 != null && l2 != null && (l1.Direction.IsAlmostEqualTo(l2.Direction) || l1.Direction.IsAlmostEqualTo(l2.Direction.Negate())))\n    {\n        ReferenceArray refs = new ReferenceArray();\n        refs.Append(r1);\n        refs.Append(r2);\n        Line dimLine = Line.CreateBound(l1.GetEndPoint(0) + l1.Direction.Normalize() * 2, l2.GetEndPoint(0) + l2.Direction.Normalize() * 2);\n        doc.Create.NewDimension(doc.ActiveView, dimLine, refs);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected elements are not straight, parallel walls.\");\n    }\n}"}
{"prompt":"Asigna todos los muros seleccionados para ser demolidos en la 'Fase de Demolición'.","completion":"Phase demoPhase = new FilteredElementCollector(doc).OfClass(typeof(Phase)).FirstOrDefault(p => p.Name.Contains(\"Demolición\") || p.Name.Contains(\"Demolition\")) as Phase;\nUIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(demoPhase != null && selectedIds.Any())\n{\n    int updatedCount = 0;\n    foreach(ElementId id in selectedIds)\n    {\n        Element elem = doc.GetElement(id);\n        if(elem is Wall)\n        {\n            elem.DemolishedPhaseId = demoPhase.Id;\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{updatedCount} muros asignados a la fase de demolición.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró una fase de demolición o no había muros seleccionados.\");\n}"}
{"prompt":"Assign all selected walls to be demolished in the 'Demolition Phase'.","completion":"Phase demoPhase = new FilteredElementCollector(doc).OfClass(typeof(Phase)).FirstOrDefault(p => p.Name.Contains(\"Demolition\")) as Phase;\nUIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(demoPhase != null && selectedIds.Any())\n{\n    int updatedCount = 0;\n    foreach(ElementId id in selectedIds)\n    {\n        Element elem = doc.GetElement(id);\n        if(elem is Wall)\n        {\n            elem.DemolishedPhaseId = demoPhase.Id;\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{updatedCount} walls assigned to the demolition phase.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A demolition phase was not found or no walls were selected.\");\n}"}
{"prompt":"Obtén el anfitrión de una luminaria seleccionada.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona una luminaria\");\nif (pickedRef != null)\n{\n    FamilyInstance fixture = doc.GetElement(pickedRef) as FamilyInstance;\n    if(fixture != null && fixture.Category.Id.IntegerValue == (int)BuiltInCategory.OST_LightingFixtures)\n    {\n        Element host = fixture.Host;\n        if (host != null) TaskDialog.Show(\"Anfitrión\", \"El anfitrión es: \" + host.Name);\n        else TaskDialog.Show(\"Anfitrión\", \"La luminaria no está alojada en ningún elemento (ej. está basada en nivel).\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no es una luminaria.\");\n    }\n}"}
{"prompt":"Get the host of a selected light fixture.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a light fixture\");\nif (pickedRef != null)\n{\n    FamilyInstance fixture = doc.GetElement(pickedRef) as FamilyInstance;\n    if(fixture != null && fixture.Category.Id.IntegerValue == (int)BuiltInCategory.OST_LightingFixtures)\n    {\n        Element host = fixture.Host;\n        if (host != null) TaskDialog.Show(\"Host\", \"The host is: \" + host.Name);\n        else TaskDialog.Show(\"Host\", \"The fixture is not hosted in any element (e.g. it is level-based).\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element is not a light fixture.\");\n    }\n}"}
{"prompt":"Crea un nuevo tipo de rejilla con color de línea azul.","completion":"string newTypeName = \"Eje Azul\";\nif (new FilteredElementCollector(doc).OfClass(typeof(GridType)).Any(gt => gt.Name == newTypeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de eje '{newTypeName}' ya existe.\");\n}\nelse\n{\n    GridType gridType = new FilteredElementCollector(doc).OfClass(typeof(GridType)).FirstOrDefault() as GridType;\n    if(gridType != null)\n    {\n        GridType newGridType = gridType.Duplicate(newTypeName) as GridType;\n        newGridType.get_Parameter(BuiltInParameter.LINE_COLOR).Set(new Color(0, 0, 255).GetElementId());\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró un tipo de eje para duplicar.\");\n    }\n}"}
{"prompt":"Create a new grid type with a blue line color.","completion":"string newTypeName = \"Blue Grid\";\nif (new FilteredElementCollector(doc).OfClass(typeof(GridType)).Any(gt => gt.Name == newTypeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Grid type '{newTypeName}' already exists.\");\n}\nelse\n{\n    GridType gridType = new FilteredElementCollector(doc).OfClass(typeof(GridType)).FirstOrDefault() as GridType;\n    if(gridType != null)\n    {\n        GridType newGridType = gridType.Duplicate(newTypeName) as GridType;\n        newGridType.get_Parameter(BuiltInParameter.LINE_COLOR).Set(new Color(0, 0, 255).GetElementId());\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No grid type found to duplicate.\");\n    }\n}"}
{"prompt":"Calcula el volumen total de hormigón en todos los pilares estructurales.","completion":"double totalVolume = 0.0;\nList<Element> columns = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsNotElementType().ToList();\nforeach(Element col in columns)\n{\n    Parameter volParam = col.get_Parameter(BuiltInParameter.HOST_VOLUME_COMPUTED);\n    if(volParam != null)\n    {\n        totalVolume += volParam.AsDouble();\n    }\n}\nTaskDialog.Show(\"Volumen de Hormigón\", $\"Volumen total en {columns.Count} pilares: {UnitUtils.ConvertFromInternalUnits(totalVolume, UnitTypeId.CubicMeters):F2} m³\");"}
{"prompt":"Calculate the total concrete volume in all structural columns.","completion":"double totalVolume = 0.0;\nList<Element> columns = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsNotElementType().ToList();\nforeach(Element col in columns)\n{\n    Parameter volParam = col.get_Parameter(BuiltInParameter.HOST_VOLUME_COMPUTED);\n    if(volParam != null)\n    {\n        totalVolume += volParam.AsDouble();\n    }\n}\nTaskDialog.Show(\"Concrete Volume\", $\"Total volume in {columns.Count} columns: {UnitUtils.ConvertFromInternalUnits(totalVolume, UnitTypeId.CubicMeters):F2} m³\");"}
{"prompt":"Aplica un desfase de 30cm desde el nivel a todos los suelos seleccionados.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    double offset = UnitUtils.ConvertToInternalUnits(30, UnitTypeId.Centimeters);\n    int updatedCount = 0;\n    foreach(ElementId id in selectedIds)\n    {\n        Floor floor = doc.GetElement(id) as Floor;\n        if(floor != null)\n        {\n            floor.get_Parameter(BuiltInParameter.FLOOR_HEIGHTABOVELEVEL_PARAM)?.Set(offset);\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{updatedCount} suelos actualizados.\");\n}"}
{"prompt":"Apply a 30cm offset from the level to all selected floors.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    double offset = UnitUtils.ConvertToInternalUnits(30, UnitTypeId.Centimeters);\n    int updatedCount = 0;\n    foreach(ElementId id in selectedIds)\n    {\n        Floor floor = doc.GetElement(id) as Floor;\n        if(floor != null)\n        {\n            floor.get_Parameter(BuiltInParameter.FLOOR_HEIGHTABOVELEVEL_PARAM)?.Set(offset);\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{updatedCount} floors were updated.\");\n}"}
{"prompt":"Crea una opción de diseño principal llamada 'Alternativa Fachada'.","completion":"string setName = \"Conjunto Fachada\";\nstring optionName = \"Alternativa Fachada\";\nDesignOptionSet optionSet = DesignOptionSet.GetDesignOptionSet(doc, setName) ?? DesignOptionSet.Create(doc, setName);\nDesignOption.Create(doc, optionName, optionSet.Id);"}
{"prompt":"Create a main design option named 'Facade Alternative'.","completion":"string setName = \"Facade Set\";\nstring optionName = \"Facade Alternative\";\nDesignOptionSet optionSet = DesignOptionSet.GetDesignOptionSet(doc, setName) ?? DesignOptionSet.Create(doc, setName);\nDesignOption.Create(doc, optionName, optionSet.Id);"}
{"prompt":"Crea una vista de leyenda para tipos de muro.","completion":"string legendName = \"Leyenda de Tipos de Muro\";\nif (new FilteredElementCollector(doc).OfClass(typeof(View)).Any(v => v.Name == legendName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"La vista de leyenda '{legendName}' ya existe.\");\n}\nelse\n{\n    ViewFamilyType legendVFT = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.Legend);\n    if (legendVFT != null)\n    {\n        ViewLegend legendView = ViewLegend.Create(doc, legendVFT.Id);\n        legendView.Name = legendName;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró el tipo de familia de vista de leyenda.\");\n    }\n}"}
{"prompt":"Create a legend view for wall types.","completion":"string legendName = \"Wall Type Legend\";\nif (new FilteredElementCollector(doc).OfClass(typeof(View)).Any(v => v.Name == legendName))\n{\n    TaskDialog.Show(\"Warning\", $\"Legend view '{legendName}' already exists.\");\n}\nelse\n{\n    ViewFamilyType legendVFT = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.Legend);\n    if (legendVFT != null)\n    {\n        ViewLegend legendView = ViewLegend.Create(doc, legendVFT.Id);\n        legendView.Name = legendName;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Legend View Family Type not found.\");\n    }\n}"}
{"prompt":"Rota la vista activa 45 grados.","completion":"View activeView = doc.ActiveView;\nif(activeView.CanModifyOrientation() && activeView.get_Parameter(BuiltInParameter.VIEWER_CROP_REGION_ROTATED) != null)\n{\n    Parameter rotationParam = activeView.get_Parameter(BuiltInParameter.VIEWER_CROP_REGION_ROTATED);\n    double currentRotation = rotationParam.AsDouble();\n    rotationParam.Set(currentRotation + (45 * Math.PI / 180.0));\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"La rotación no está permitida en esta vista.\");\n}"}
{"prompt":"Rotate the active view by 45 degrees.","completion":"View activeView = doc.ActiveView;\nif(activeView.CanModifyOrientation() && activeView.get_Parameter(BuiltInParameter.VIEWER_CROP_REGION_ROTATED) != null)\n{\n    Parameter rotationParam = activeView.get_Parameter(BuiltInParameter.VIEWER_CROP_REGION_ROTATED);\n    double currentRotation = rotationParam.AsDouble();\n    rotationParam.Set(currentRotation + (45 * Math.PI / 180.0));\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Rotation is not permitted in this view.\");\n}"}
{"prompt":"Crea una vista de detalle (callout) rectangular.","completion":"ViewPlan planView = doc.ActiveView as ViewPlan;\nif (planView != null)\n{\n    XYZ p1 = new XYZ(0,0,0);\n    XYZ p2 = new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0);\n    ElementId viewFamilyTypeId = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(vft => vft.ViewFamily == ViewFamily.Detail).Id;\n    ViewSection.CreateCallout(doc, planView.Id, viewFamilyTypeId, p1, p2);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"La vista activa debe ser una vista de planta para crear un callout.\");\n}"}
{"prompt":"Create a rectangular callout view.","completion":"ViewPlan planView = doc.ActiveView as ViewPlan;\nif (planView != null)\n{\n    XYZ p1 = new XYZ(0,0,0);\n    XYZ p2 = new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0);\n    ElementId viewFamilyTypeId = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(vft => vft.ViewFamily == ViewFamily.Detail).Id;\n    ViewSection.CreateCallout(doc, planView.Id, viewFamilyTypeId, p1, p2);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"The active view must be a plan view to create a callout.\");\n}"}
{"prompt":"Añade las luminarias seleccionadas al primer circuito eléctrico disponible.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedFixtures = uidoc.Selection.GetElementIds();\nElectricalSystem circuit = new FilteredElementCollector(doc).OfClass(typeof(ElectricalSystem)).FirstOrDefault() as ElectricalSystem;\nif(circuit != null && selectedFixtures.Any())\n{\n    circuit.Add(selectedFixtures);\n    TaskDialog.Show(\"Éxito\", $\"{selectedFixtures.Count} elementos añadidos al circuito '{circuit.Name}'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron circuitos o no había elementos seleccionados.\");\n}"}
{"prompt":"Add the selected light fixtures to the first available electrical circuit.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedFixtures = uidoc.Selection.GetElementIds();\nElectricalSystem circuit = new FilteredElementCollector(doc).OfClass(typeof(ElectricalSystem)).FirstOrDefault() as ElectricalSystem;\nif(circuit != null && selectedFixtures.Any())\n{\n    circuit.Add(selectedFixtures);\n    TaskDialog.Show(\"Success\", $\"{selectedFixtures.Count} elements added to circuit '{circuit.Name}'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No circuits were found or no elements were selected.\");\n}"}
{"prompt":"Resuelve la primera advertencia del proyecto eliminando los elementos.","completion":"IList<FailureMessage> warnings = doc.GetWarnings();\nif(warnings.Any())\n{\n    FailureMessage firstWarning = warnings.First();\n    ICollection<ElementId> failingElements = firstWarning.GetFailingElements();\n    if(failingElements.Any())\n    {\n        doc.Delete(failingElements);\n        TaskDialog.Show(\"Advertencia Resuelta\", \"Se eliminaron los elementos de la primera advertencia.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", \"La primera advertencia no tenía elementos asociados para eliminar.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"El proyecto no tiene advertencias.\");\n}"}
{"prompt":"Resolve the first project warning by deleting the elements.","completion":"IList<FailureMessage> warnings = doc.GetWarnings();\nif(warnings.Any())\n{\n    FailureMessage firstWarning = warnings.First();\n    ICollection<ElementId> failingElements = firstWarning.GetFailingElements();\n    if(failingElements.Any())\n    {\n        doc.Delete(failingElements);\n        TaskDialog.Show(\"Warning Resolved\", \"The elements from the first warning were deleted.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", \"The first warning had no associated elements to delete.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"The project has no warnings.\");\n}"}
{"prompt":"Crea una nueva hoja A0 y coloca la vista 'Vista 3D General' en ella.","completion":"string sheetNumber = \"G-001\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewSheet)).Cast<ViewSheet>().Any(s => s.SheetNumber == sheetNumber))\n{\n    TaskDialog.Show(\"Advertencia\", $\"Ya existe una hoja con el número '{sheetNumber}'.\");\n}\nelse\n{\n    FamilySymbol titleBlock = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_TitleBlocks).WhereElementIsElementType().FirstOrDefault(tb => tb.Name.Contains(\"A0\")) as FamilySymbol;\n    View viewToPlace = new FilteredElementCollector(doc).OfClass(typeof(View3D)).FirstOrDefault(v => v.Name == \"Vista 3D General\") as View;\n    if (titleBlock != null && viewToPlace != null)\n    {\n        ViewSheet newSheet = ViewSheet.Create(doc, titleBlock.Id);\n        newSheet.Name = \"Perspectiva General\";\n        newSheet.SheetNumber = sheetNumber;\n        if (Viewport.CanAddViewToSheet(doc, newSheet.Id, viewToPlace.Id))\n        {\n            BoundingBoxUV sheetBox = newSheet.Outline;\n            XYZ centerPoint = (sheetBox.Min + sheetBox.Max) / 2;\n            Viewport.Create(doc, newSheet.Id, viewToPlace.Id, centerPoint);\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró un cajetín A0 o la vista 'Vista 3D General'.\");\n    }\n}"}
{"prompt":"Create a new A0 sheet and place the 'General 3D View' on it.","completion":"string sheetNumber = \"G-001\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewSheet)).Cast<ViewSheet>().Any(s => s.SheetNumber == sheetNumber))\n{\n    TaskDialog.Show(\"Warning\", $\"A sheet with the number '{sheetNumber}' already exists.\");\n}\nelse\n{\n    FamilySymbol titleBlock = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_TitleBlocks).WhereElementIsElementType().FirstOrDefault(tb => tb.Name.Contains(\"A0\")) as FamilySymbol;\n    View viewToPlace = new FilteredElementCollector(doc).OfClass(typeof(View3D)).FirstOrDefault(v => v.Name == \"General 3D View\") as View;\n    if (titleBlock != null && viewToPlace != null)\n    {\n        ViewSheet newSheet = ViewSheet.Create(doc, titleBlock.Id);\n        newSheet.Name = \"General Perspective\";\n        newSheet.SheetNumber = sheetNumber;\n        if (Viewport.CanAddViewToSheet(doc, newSheet.Id, viewToPlace.Id))\n        {\n            BoundingBoxUV sheetBox = newSheet.Outline;\n            XYZ centerPoint = (sheetBox.Min + sheetBox.Max) / 2;\n            Viewport.Create(doc, newSheet.Id, viewToPlace.Id, centerPoint);\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"A0 title block or 'General 3D View' not found.\");\n    }\n}"}

{"prompt":"Cambia el grosor de la capa núcleo de un tipo de muro a 200mm.","completion":"WallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\nif(wallType != null)\n{\n    CompoundStructure cs = wallType.GetCompoundStructure();\n    if (cs != null)\n    {\n        int coreIndex = cs.GetFirstCoreLayerIndex();\n        if(coreIndex != -1) \n        {\n            cs.SetLayerWidth(coreIndex, UnitUtils.ConvertToInternalUnits(200, UnitTypeId.Millimeters));\n            wallType.SetCompoundStructure(cs);\n            TaskDialog.Show(\"Éxito\", $\"La capa núcleo del tipo '{wallType.Name}' ha sido modificada.\");\n        }\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron tipos de muro para modificar.\");\n}"}
{"prompt":"Change the core layer thickness of a wall type to 200mm.","completion":"WallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\nif(wallType != null)\n{\n    CompoundStructure cs = wallType.GetCompoundStructure();\n    if (cs != null)\n    {\n        int coreIndex = cs.GetFirstCoreLayerIndex();\n        if(coreIndex != -1) \n        {\n            cs.SetLayerWidth(coreIndex, UnitUtils.ConvertToInternalUnits(200, UnitTypeId.Millimeters));\n            wallType.SetCompoundStructure(cs);\n            TaskDialog.Show(\"Success\", $\"The core layer of type '{wallType.Name}' has been modified.\");\n        }\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No wall types were found to modify.\");\n}"}
{"prompt":"Obtén todos los muros de un modelo de Revit vinculado.","completion":"RevitLinkInstance linkInstance = new FilteredElementCollector(doc).OfClass(typeof(RevitLinkInstance)).FirstOrDefault() as RevitLinkInstance;\nif (linkInstance != null)\n{\n    Document linkDoc = linkInstance.GetLinkDocument();\n    if (linkDoc != null)\n    {\n        List<Wall> linkedWalls = new FilteredElementCollector(linkDoc).OfClass(typeof(Wall)).WhereElementIsNotElementType().Cast<Wall>().ToList();\n        TaskDialog.Show(\"Resultado\", $\"Se encontraron {linkedWalls.Count} muros en el vínculo '{linkInstance.Name}'.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron vínculos de Revit en el proyecto.\");\n}"}
{"prompt":"Get all walls from a linked Revit model.","completion":"RevitLinkInstance linkInstance = new FilteredElementCollector(doc).OfClass(typeof(RevitLinkInstance)).FirstOrDefault() as RevitLinkInstance;\nif (linkInstance != null)\n{\n    Document linkDoc = linkInstance.GetLinkDocument();\n    if (linkDoc != null)\n    {\n        List<Wall> linkedWalls = new FilteredElementCollector(linkDoc).OfClass(typeof(Wall)).WhereElementIsNotElementType().Cast<Wall>().ToList();\n        TaskDialog.Show(\"Result\", $\"Found {linkedWalls.Count} walls in the link '{linkInstance.Name}'.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No Revit links were found in the project.\");\n}"}
{"prompt":"Aplica un color de relleno sólido rojo a todos los muros en la vista activa.","completion":"View activeView = doc.ActiveView;\nFillPatternElement solidFill = new FilteredElementCollector(doc).OfClass(typeof(FillPatternElement)).FirstOrDefault(p => p.GetFillPattern().IsSolidFill) as FillPatternElement;\nif(solidFill != null)\n{\n    OverrideGraphicSettings ogs = new OverrideGraphicSettings();\n    ogs.SetSurfaceForegroundPatternId(solidFill.Id);\n    ogs.SetSurfaceForegroundPatternColor(new Color(255, 0, 0));\n    activeView.SetCategoryOverrides(new ElementId(BuiltInCategory.OST_Walls), ogs);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró un patrón de relleno sólido en el proyecto.\");\n}"}
{"prompt":"Apply a red solid fill color to all walls in the active view.","completion":"View activeView = doc.ActiveView;\nFillPatternElement solidFill = new FilteredElementCollector(doc).OfClass(typeof(FillPatternElement)).FirstOrDefault(p => p.GetFillPattern().IsSolidFill) as FillPatternElement;\nif(solidFill != null)\n{\n    OverrideGraphicSettings ogs = new OverrideGraphicSettings();\n    ogs.SetSurfaceForegroundPatternId(solidFill.Id);\n    ogs.SetSurfaceForegroundPatternColor(new Color(255, 0, 0));\n    activeView.SetCategoryOverrides(new ElementId(BuiltInCategory.OST_Walls), ogs);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A solid fill pattern was not found in the project.\");\n}"}
{"prompt":"Exporta todos los elementos con la marca 'Revisar' a un archivo de texto.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"review_elements.txt\");\nParameterValueProvider pvp = new ParameterValueProvider(new ElementId(BuiltInParameter.ALL_MODEL_MARK));\nFilterStringRuleEvaluator evaluator = new FilterStringEquals();\nFilterRule rule = new FilterStringRule(pvp, evaluator, \"Revisar\", false);\nList<Element> elementsToReview = new FilteredElementCollector(doc).WherePasses(new ElementParameterFilter(rule)).ToList();\nList<string> lines = new List<string>();\nforeach(Element e in elementsToReview) \n{\n    lines.Add($\"{e.Id} - {e.Name}\");\n}\nSystem.IO.File.WriteAllLines(filePath, lines);\nTaskDialog.Show(\"Exportación Completa\", $\"{elementsToReview.Count} elementos para revisar exportados a: {filePath}\");"}
{"prompt":"Export all elements with the 'Review' mark to a text file.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"review_elements.txt\");\nParameterValueProvider pvp = new ParameterValueProvider(new ElementId(BuiltInParameter.ALL_MODEL_MARK));\nFilterStringRuleEvaluator evaluator = new FilterStringEquals();\nFilterRule rule = new FilterStringRule(pvp, evaluator, \"Review\", false);\nList<Element> elementsToReview = new FilteredElementCollector(doc).WherePasses(new ElementParameterFilter(rule)).ToList();\nList<string> lines = new List<string>();\nforeach(Element e in elementsToReview) \n{\n    lines.Add($\"{e.Id} - {e.Name}\");\n}\nSystem.IO.File.WriteAllLines(filePath, lines);\nTaskDialog.Show(\"Export Complete\", $\"{elementsToReview.Count} elements to review exported to: {filePath}\");"}
{"prompt":"Crea un nuevo sistema de tuberías de agua fría.","completion":"string systemName = \"Nuevo Sistema de Agua Fría\";\nPipingSystemType chilledWaterSystemType = new FilteredElementCollector(doc).OfClass(typeof(PipingSystemType)).Cast<PipingSystemType>().FirstOrDefault(s => s.SystemClassification == MEPSystemClassification.ChilledWater);\nif (new FilteredElementCollector(doc).OfClass(typeof(PipingSystem)).Any(s => s.Name == systemName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El sistema de tuberías '{systemName}' ya existe.\");\n}\nelse if(chilledWaterSystemType != null)\n{\n    PipingSystem.Create(doc, chilledWaterSystemType.Id, systemName);\n    TaskDialog.Show(\"Éxito\", $\"Sistema '{systemName}' creado.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró un tipo de sistema de agua fría en el proyecto.\");\n}"}
{"prompt":"Create a new chilled water piping system.","completion":"string systemName = \"New Chilled Water System\";\nPipingSystemType chilledWaterSystemType = new FilteredElementCollector(doc).OfClass(typeof(PipingSystemType)).Cast<PipingSystemType>().FirstOrDefault(s => s.SystemClassification == MEPSystemClassification.ChilledWater);\nif (new FilteredElementCollector(doc).OfClass(typeof(PipingSystem)).Any(s => s.Name == systemName))\n{\n    TaskDialog.Show(\"Warning\", $\"Piping system '{systemName}' already exists.\");\n}\nelse if(chilledWaterSystemType != null)\n{\n    PipingSystem.Create(doc, chilledWaterSystemType.Id, systemName);\n    TaskDialog.Show(\"Success\", $\"System '{systemName}' created.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A chilled water system type was not found in the project.\");\n}"}
{"prompt":"Añade una etiqueta de tipo a la primera viga que encuentres.","completion":"FamilyInstance beam = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsNotElementType().FirstOrDefault() as FamilyInstance;\nif(beam != null)\n{\n    LocationCurve lc = beam.Location as LocationCurve;\n    if (lc != null)\n    {\n        IndependentTag.Create(doc, doc.ActiveView.Id, new Reference(beam), false, TagMode.TM_ADDBY_CATEGORY, TagOrientation.Horizontal, lc.Curve.Evaluate(0.5, true));\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron vigas para etiquetar.\");\n}"}
{"prompt":"Add a type tag to the first beam found.","completion":"FamilyInstance beam = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsNotElementType().FirstOrDefault() as FamilyInstance;\nif(beam != null)\n{\n    LocationCurve lc = beam.Location as LocationCurve;\n    if (lc != null)\n    {\n        IndependentTag.Create(doc, doc.ActiveView.Id, new Reference(beam), false, TagMode.TM_ADDBY_CATEGORY, TagOrientation.Horizontal, lc.Curve.Evaluate(0.5, true));\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No beams were found to tag.\");\n}"}
{"prompt":"Obtén el área de una cara de muro seleccionada.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedFaceRef = uidoc.Selection.PickObject(ObjectType.Face, \"Selecciona una cara de muro\");\nif (pickedFaceRef != null)\n{\n    Element elem = doc.GetElement(pickedFaceRef);\n    if (elem is Wall)\n    {\n        Face face = elem.GetGeometryObjectFromReference(pickedFaceRef) as Face;\n        if(face != null)\n        {\n            double area = face.Area;\n            TaskDialog.Show(\"Área de Cara\", $\"El área es: {UnitUtils.ConvertFromInternalUnits(area, UnitTypeId.SquareMeters):F2} m²\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"La cara seleccionada no pertenece a un muro.\");\n    }\n}"}
{"prompt":"Get the area of a selected wall face.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedFaceRef = uidoc.Selection.PickObject(ObjectType.Face, \"Select a wall face\");\nif (pickedFaceRef != null)\n{\n    Element elem = doc.GetElement(pickedFaceRef);\n    if (elem is Wall)\n    {\n        Face face = elem.GetGeometryObjectFromReference(pickedFaceRef) as Face;\n        if(face != null)\n        {\n            double area = face.Area;\n            TaskDialog.Show(\"Face Area\", $\"The area is: {UnitUtils.ConvertFromInternalUnits(area, UnitTypeId.SquareMeters):F2} m²\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected face does not belong to a wall.\");\n    }\n}"}
{"prompt":"Crea una masa de barrido (sweep) a lo largo de una línea.","completion":"TaskDialog.Show(\"Acción no soportada\", \"La creación de masas conceptuales es un modo de edición especial que no se puede ejecutar directamente con este agente. Se recomienda usar las herramientas estándar de Revit para modelar masas.\");"}
{"prompt":"Create a sweep mass along a line.","completion":"TaskDialog.Show(\"Unsupported Action\", \"Creating conceptual masses is a special editing mode that cannot be executed directly with this agent. It is recommended to use standard Revit tools to model masses.\");"}
{"prompt":"Etiqueta todas las ventanas en la vista activa por categoría.","completion":"List<FamilyInstance> windows = new FilteredElementCollector(doc, doc.ActiveView.Id).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().Cast<FamilyInstance>().ToList();\nint taggedCount = 0;\nforeach(FamilyInstance window in windows)\n{\n    LocationPoint loc = window.Location as LocationPoint;\n    if(loc != null) \n    {\n        IndependentTag.Create(doc, doc.ActiveView.Id, new Reference(window), false, TagMode.TM_ADDBY_CATEGORY, TagOrientation.Horizontal, loc.Point);\n        taggedCount++;\n    }\n}\nTaskDialog.Show(\"Resultado\", $\"{taggedCount} ventanas han sido etiquetadas en la vista actual.\");"}
{"prompt":"Tag all windows in the active view by category.","completion":"List<FamilyInstance> windows = new FilteredElementCollector(doc, doc.ActiveView.Id).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().Cast<FamilyInstance>().ToList();\nint taggedCount = 0;\nforeach(FamilyInstance window in windows)\n{\n    LocationPoint loc = window.Location as LocationPoint;\n    if(loc != null) \n    {\n        IndependentTag.Create(doc, doc.ActiveView.Id, new Reference(window), false, TagMode.TM_ADDBY_CATEGORY, TagOrientation.Horizontal, loc.Point);\n        taggedCount++;\n    }\n}\nTaskDialog.Show(\"Result\", $\"{taggedCount} windows have been tagged in the current view.\");"}
{"prompt":"Elimina todos los elementos seleccionados.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    int count = selectedIds.Count;\n    doc.Delete(selectedIds);\n    TaskDialog.Show(\"Éxito\", $\"{count} elementos han sido eliminados.\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No había elementos seleccionados para eliminar.\");\n}"}
{"prompt":"Delete all selected elements.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    int count = selectedIds.Count;\n    doc.Delete(selectedIds);\n    TaskDialog.Show(\"Success\", $\"{count} elements have been deleted.\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No elements were selected to delete.\");\n}"}
{"prompt":"Añade montantes a todas las líneas de rejilla de un muro cortina seleccionado.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un muro cortina\");\nif (pickedRef != null)\n{\n    Wall curtainWall = doc.GetElement(pickedRef) as Wall;\n    MullionType mullionType = new FilteredElementCollector(doc).OfClass(typeof(MullionType)).FirstOrDefault() as MullionType;\n    if (curtainWall != null && curtainWall.CurtainGrid != null && mullionType != null)\n    {\n        CurtainGrid grid = curtainWall.CurtainGrid;\n        foreach (ElementId gridLineId in grid.GetVGridLineIds()) \n        {\n            CurtainGridLine line = doc.GetElement(gridLineId) as CurtainGridLine;\n            if(line != null && !line.MullionOnLine) line.AddMullions(mullionType, false);\n        }\n        foreach (ElementId gridLineId in grid.GetUGridLineIds()) \n        {\n            CurtainGridLine line = doc.GetElement(gridLineId) as CurtainGridLine;\n            if(line != null && !line.MullionOnLine) line.AddMullions(mullionType, false);\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no es un muro cortina válido o no hay tipos de montante en el proyecto.\");\n    }\n}"}
{"prompt":"Add mullions to all grid lines of a selected curtain wall.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a curtain wall\");\nif (pickedRef != null)\n{\n    Wall curtainWall = doc.GetElement(pickedRef) as Wall;\n    MullionType mullionType = new FilteredElementCollector(doc).OfClass(typeof(MullionType)).FirstOrDefault() as MullionType;\n    if (curtainWall != null && curtainWall.CurtainGrid != null && mullionType != null)\n    {\n        CurtainGrid grid = curtainWall.CurtainGrid;\n        foreach (ElementId gridLineId in grid.GetVGridLineIds()) \n        {\n            CurtainGridLine line = doc.GetElement(gridLineId) as CurtainGridLine;\n            if(line != null && !line.MullionOnLine) line.AddMullions(mullionType, false);\n        }\n        foreach (ElementId gridLineId in grid.GetUGridLineIds()) \n        {\n            CurtainGridLine line = doc.GetElement(gridLineId) as CurtainGridLine;\n            if(line != null && !line.MullionOnLine) line.AddMullions(mullionType, false);\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element is not a valid curtain wall or no mullion types exist in the project.\");\n    }\n}"}
{"prompt":"Rota un elemento seleccionado 90 grados sobre su eje Z.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un elemento para rotar\");\nif (pickedRef != null)\n{\n    Element elem = doc.GetElement(pickedRef.ElementId);\n    LocationPoint lp = elem.Location as LocationPoint;\n    if (lp != null)\n    {\n        Line axis = Line.CreateBound(lp.Point, lp.Point + XYZ.BasisZ);\n        ElementTransformUtils.RotateElement(doc, elem.Id, Math.PI / 2.0);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no tiene un punto de ubicación para rotar (ej. un muro).\");\n    }\n}"}
{"prompt":"Rotate a selected element 90 degrees around its Z-axis.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select an element to rotate\");\nif (pickedRef != null)\n{\n    Element elem = doc.GetElement(pickedRef.ElementId);\n    LocationPoint lp = elem.Location as LocationPoint;\n    if (lp != null)\n    {\n        Line axis = Line.CreateBound(lp.Point, lp.Point + XYZ.BasisZ);\n        ElementTransformUtils.RotateElement(doc, elem.Id, Math.PI / 2.0);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element does not have a location point to rotate around (e.g. a wall).\");\n    }\n}"}
{"prompt":"Crea un sistema de vigas en un forjado seleccionado.","completion":"TaskDialog.Show(\"Acción en Múltiples Pasos\", \"La creación de un sistema de vigas requiere un contorno. Por favor, dibuja o selecciona las líneas que definen el contorno del sistema de vigas y luego pide 'Crear sistema de vigas a partir de la selección'.\");"}
{"prompt":"Create a beam system on a selected floor slab.","completion":"TaskDialog.Show(\"Multi-Step Action\", \"Creating a beam system requires a boundary. Please draw or select the lines that define the beam system boundary, and then ask 'Create beam system from selection'.\");"}
{"prompt":"Exporta una lista de todas las advertencias del proyecto a un archivo de texto en el escritorio.","completion":"string desktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);\nstring filePath = System.IO.Path.Combine(desktopPath, \"RevitWarnings.txt\");\nIList<FailureMessage> warnings = doc.GetWarnings();\nif (warnings.Any())\n{\n    List<string> warningDescriptions = warnings.Select(w => w.GetDescriptionText()).ToList();\n    System.IO.File.WriteAllLines(filePath, warningDescriptions);\n    TaskDialog.Show(\"Exportación Completa\", $\"{warnings.Count} advertencias exportadas a: {filePath}\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"El proyecto no tiene advertencias.\");\n}"}
{"prompt":"Export a list of all project warnings to a text file on the desktop.","completion":"string desktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);\nstring filePath = System.IO.Path.Combine(desktopPath, \"RevitWarnings.txt\");\nIList<FailureMessage> warnings = doc.GetWarnings();\nif (warnings.Any())\n{\n    List<string> warningDescriptions = warnings.Select(w => w.GetDescriptionText()).ToList();\n    System.IO.File.WriteAllLines(filePath, warningDescriptions);\n    TaskDialog.Show(\"Export Complete\", $\"{warnings.Count} warnings exported to: {filePath}\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"The project has no warnings.\");\n}"}
{"prompt":"Crea una vista de borrador (drafting view) llamada 'Detalles Típicos'.","completion":"string viewName = \"Detalles Típicos\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewDrafting)).Any(v => v.Name == viewName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"La vista de borrador '{viewName}' ya existe.\");\n}\nelse\n{\n    ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.Drafting);\n    if(vft != null)\n    {\n        ViewDrafting draftingView = ViewDrafting.Create(doc, vft.Id);\n        draftingView.Name = viewName;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró el tipo de familia de vista de borrador.\");\n    }\n}"}
{"prompt":"Create a drafting view named 'Typical Details'.","completion":"string viewName = \"Typical Details\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewDrafting)).Any(v => v.Name == viewName))\n{\n    TaskDialog.Show(\"Warning\", $\"Drafting view '{viewName}' already exists.\");\n}\nelse\n{\n    ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.Drafting);\n    if(vft != null)\n    {\n        ViewDrafting draftingView = ViewDrafting.Create(doc, vft.Id);\n        draftingView.Name = viewName;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Drafting View Family Type not found.\");\n    }\n}"}
{"prompt":"Muestra un diálogo para que el usuario introduzca un texto.","completion":"TaskDialog.Show(\"Funcionalidad no Soportada\", \"La API de Revit no provee una forma nativa de mostrar un cuadro de diálogo para que el usuario introduzca texto directamente. Se necesitan interfaces de usuario personalizadas (WPF o Windows Forms) para esta funcionalidad.\");"}
{"prompt":"Show a dialog for the user to input text.","completion":"TaskDialog.Show(\"Unsupported Functionality\", \"The Revit API does not provide a native way to show a dialog box for user text input. Custom user interfaces (WPF or Windows Forms) are required for this functionality.\");"}
{"prompt":"Cambia el tipo de todas las columnas seleccionadas a 'Columna de Hormigón 450x450'.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nFamilySymbol targetType = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().Cast<FamilySymbol>().FirstOrDefault(s => s.Name == \"Columna de Hormigón 450x450\");\nif(targetType != null && selectedIds.Any())\n{\n    int updatedCount = 0;\n    foreach(ElementId id in selectedIds)\n    {\n        FamilyInstance fi = doc.GetElement(id) as FamilyInstance;\n        if(fi != null && fi.Category.Id.IntegerValue == (int)BuiltInCategory.OST_StructuralColumns)\n        {\n            fi.Symbol = targetType;\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{updatedCount} columnas cambiadas de tipo.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el tipo de columna de destino o no había columnas seleccionadas.\");\n}"}
{"prompt":"Change the type of all selected columns to 'Concrete Column 450x450'.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nFamilySymbol targetType = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().Cast<FamilySymbol>().FirstOrDefault(s => s.Name == \"Concrete Column 450x450\");\nif(targetType != null && selectedIds.Any())\n{\n    int updatedCount = 0;\n    foreach(ElementId id in selectedIds)\n    {\n        FamilyInstance fi = doc.GetElement(id) as FamilyInstance;\n        if(fi != null && fi.Category.Id.IntegerValue == (int)BuiltInCategory.OST_StructuralColumns)\n        {\n            fi.Symbol = targetType;\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{updatedCount} columns had their type changed.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Target column type not found or no columns were selected.\");\n}"}
{"prompt":"Crea un suelo siguiendo el contorno de una habitación seleccionada.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference roomRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona una habitación\");\nif (roomRef != null)\n{\n    Room room = doc.GetElement(roomRef) as Room;\n    if(room != null)\n    {\n        FloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\n        if (floorType != null)\n        {\n            IList<IList<BoundarySegment>> segments = room.GetBoundarySegments(new SpatialElementBoundaryOptions());\n            CurveLoop profile = new CurveLoop();\n            foreach(BoundarySegment seg in segments.First()) \n            {\n                profile.Append(seg.GetCurve());\n            }\n            Floor.Create(doc, new List<CurveLoop>{profile}, floorType.Id, room.LevelId);\n        }\n        else\n        {\n            TaskDialog.Show(\"Error\", \"No se encontraron tipos de suelo en el proyecto.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no es una habitación.\");\n    }\n}"}
{"prompt":"Create a floor following the boundary of a selected room.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference roomRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a room\");\nif (roomRef != null)\n{\n    Room room = doc.GetElement(roomRef) as Room;\n    if(room != null)\n    {\n        FloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\n        if (floorType != null)\n        {\n            IList<IList<BoundarySegment>> segments = room.GetBoundarySegments(new SpatialElementBoundaryOptions());\n            CurveLoop profile = new CurveLoop();\n            foreach(BoundarySegment seg in segments.First()) \n            {\n                profile.Append(seg.GetCurve());\n            }\n            Floor.Create(doc, new List<CurveLoop>{profile}, floorType.Id, room.LevelId);\n        }\n        else\n        {\n            TaskDialog.Show(\"Error\", \"No floor types found in the project.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element is not a room.\");\n    }\n}"}
{"prompt":"Encuentra todas las familias que contienen 'Genérico' en su nombre.","completion":"List<Family> genericFamilies = new FilteredElementCollector(doc).OfClass(typeof(Family)).Cast<Family>().Where(f => f.Name.Contains(\"Genérico\") || f.Name.Contains(\"Generic\")).ToList();\nTaskDialog.Show(\"Resultado\", $\"Se encontraron {genericFamilies.Count} familias que contienen 'Genérico' en su nombre.\");"}
{"prompt":"Find all families containing 'Generic' in their name.","completion":"List<Family> genericFamilies = new FilteredElementCollector(doc).OfClass(typeof(Family)).Cast<Family>().Where(f => f.Name.Contains(\"Generic\")).ToList();\nTaskDialog.Show(\"Result\", $\"Found {genericFamilies.Count} families containing 'Generic' in their name.\");"}
{"prompt":"Aplica un desfase de -10cm a todos los muros seleccionados desde su línea de ubicación.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    double offset = UnitUtils.ConvertToInternalUnits(-10, UnitTypeId.Centimeters);\n    int updatedCount = 0;\n    foreach(ElementId id in selectedIds)\n    {\n        Wall wall = doc.GetElement(id) as Wall;\n        if(wall != null)\n        {\n            wall.get_Parameter(BuiltInParameter.WALL_BASE_OFFSET).Set(offset);\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{updatedCount} muros desfasados.\");\n}"}
{"prompt":"Apply a -10cm offset to all selected walls from their location line.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    double offset = UnitUtils.ConvertToInternalUnits(-10, UnitTypeId.Centimeters);\n    int updatedCount = 0;\n    foreach(ElementId id in selectedIds)\n    {\n        Wall wall = doc.GetElement(id) as Wall;\n        if(wall != null)\n        {\n            wall.get_Parameter(BuiltInParameter.WALL_BASE_OFFSET).Set(offset);\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{updatedCount} walls were offset.\");\n}"}
{"prompt":"Duplica la vista activa con detalles.","completion":"View activeView = doc.ActiveView;\nElementId newViewId = activeView.Duplicate(ViewDuplicateOption.WithDetailing);\nif (newViewId != ElementId.InvalidElementId)\n{\n    View newView = doc.GetElement(newViewId) as View;\n    if(newView != null) TaskDialog.Show(\"Éxito\", $\"Vista '{activeView.Name}' duplicada como '{newView.Name}'.\");\n}"}
{"prompt":"Duplicate the active view with detailing.","completion":"View activeView = doc.ActiveView;\nElementId newViewId = activeView.Duplicate(ViewDuplicateOption.WithDetailing);\nif (newViewId != ElementId.InvalidElementId)\n{\n    View newView = doc.GetElement(newViewId) as View;\n    if(newView != null) TaskDialog.Show(\"Success\", $\"View '{activeView.Name}' duplicated as '{newView.Name}'.\");\n}"}
{"prompt":"Establece la escala de la vista activa a 1:50.","completion":"View activeView = doc.ActiveView;\nif(activeView.CanModifyViewScale())\n{\n    activeView.Scale = 50;\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"La escala de esta vista está controlada por una plantilla de vista.\");\n}"}
{"prompt":"Set the active view's scale to 1:50.","completion":"View activeView = doc.ActiveView;\nif(activeView.CanModifyViewScale())\n{\n    activeView.Scale = 50;\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"The scale of this view is controlled by a view template.\");\n}"}
{"prompt":"Crea un nuevo tipo de suelo 'Suelo Genérico 30cm'.","completion":"string newTypeName = \"Suelo Genérico 30cm\";\nif (new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Any(ft => ft.Name == newTypeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de suelo '{newTypeName}' ya existe.\");\n}\nelse\n{\n    FloorType floorTypeToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\n    if(floorTypeToDuplicate != null)\n    {\n        FloorType newType = floorTypeToDuplicate.Duplicate(newTypeName) as FloorType;\n        CompoundStructure cs = newType.GetCompoundStructure();\n        if(cs.GetLayerCount() > 0) cs.SetLayerWidth(cs.GetFirstCoreLayerIndex(), UnitUtils.ConvertToInternalUnits(30, UnitTypeId.Centimeters));\n        newType.SetCompoundStructure(cs);\n        TaskDialog.Show(\"Éxito\", $\"Tipo de suelo '{newTypeName}' creado.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró un tipo de suelo para duplicar.\");\n    }\n}"}
{"prompt":"Create a new floor type 'Generic Floor 30cm'.","completion":"string newTypeName = \"Generic Floor 30cm\";\nif (new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Any(ft => ft.Name == newTypeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Floor type '{newTypeName}' already exists.\");\n}\nelse\n{\n    FloorType floorTypeToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\n    if(floorTypeToDuplicate != null)\n    {\n        FloorType newType = floorTypeToDuplicate.Duplicate(newTypeName) as FloorType;\n        CompoundStructure cs = newType.GetCompoundStructure();\n        if(cs.GetLayerCount() > 0) cs.SetLayerWidth(cs.GetFirstCoreLayerIndex(), UnitUtils.ConvertToInternalUnits(30, UnitTypeId.Centimeters));\n        newType.SetCompoundStructure(cs);\n        TaskDialog.Show(\"Success\", $\"Floor type '{newTypeName}' created.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No floor type found to duplicate.\");\n    }\n}"}
{"prompt":"Haz que todos los muros seleccionados sean estructurales.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nint updatedCount = 0;\nif (selectedIds.Any())\n{\n    foreach(ElementId id in selectedIds)\n    {\n        Wall wall = doc.GetElement(id) as Wall;\n        if(wall != null) \n        {\n            wall.get_Parameter(BuiltInParameter.WALL_STRUCTURAL_SIGNIFICANT).Set(1);\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{updatedCount} muros ahora son estructurales.\");\n}"}
{"prompt":"Make all selected walls structural.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nint updatedCount = 0;\nif (selectedIds.Any())\n{\n    foreach(ElementId id in selectedIds)\n    {\n        Wall wall = doc.GetElement(id) as Wall;\n        if(wall != null) \n        {\n            wall.get_Parameter(BuiltInParameter.WALL_STRUCTURAL_SIGNIFICANT).Set(1);\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{updatedCount} walls are now structural.\");\n}"}

{"prompt":"Crea un nuevo tipo de muro con una capa de acabado de 2cm.","completion":"TaskDialog.Show(\"Acción Peligrosa\", \"Crear una capa desde cero usando 'SetLayers' borraría todas las capas existentes del tipo de muro. Es más seguro duplicar un tipo existente y modificar o insertar capas. Por favor, especifique un tipo de muro para duplicar.\");"}
{"prompt":"Create a new wall type with a 2cm finish layer.","completion":"TaskDialog.Show(\"Dangerous Action\", \"Creating a layer from scratch using 'SetLayers' would delete all existing layers from the wall type. It is safer to duplicate an existing type and modify or insert layers. Please specify a wall type to duplicate.\");"}
{"prompt":"Obtén la longitud total de todos los muros del proyecto.","completion":"double totalLength = 0.0;\nList<Wall> walls = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WhereElementIsNotElementType().Cast<Wall>().ToList();\nforeach (Wall wall in walls)\n{\n    totalLength += wall.get_Parameter(BuiltInParameter.CURVE_ELEM_LENGTH).AsDouble();\n}\nTaskDialog.Show(\"Longitud Total de Muros\", $\"Se encontraron {walls.Count} muros.\\nLongitud total: {UnitUtils.ConvertFromInternalUnits(totalLength, UnitTypeId.Meters):F2} m\");"}
{"prompt":"Get the total length of all walls in the project.","completion":"double totalLength = 0.0;\nList<Wall> walls = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WhereElementIsNotElementType().Cast<Wall>().ToList();\nforeach (Wall wall in walls)\n{\n    totalLength += wall.get_Parameter(BuiltInParameter.CURVE_ELEM_LENGTH).AsDouble();\n}\nTaskDialog.Show(\"Total Wall Length\", $\"Found {walls.Count} walls.\\nTotal length: {UnitUtils.ConvertFromInternalUnits(totalLength, UnitTypeId.Meters):F2} m\");"}
{"prompt":"Crea un filtro de vista que muestre solo las puertas con resistencia al fuego.","completion":"string filterName = \"Filtro Puertas RF\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ParameterFilterElement)).Any(f => f.Name == filterName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El filtro '{filterName}' ya existe.\");\n}\nelse\n{\n    ElementId fireRatingParamId = new ElementId(BuiltInParameter.FIRE_RATING);\n    FilterRule rule = ParameterFilterRuleFactory.CreateHasValueRule(fireRatingParamId);\n    ElementFilter filter = new ElementParameterFilter(rule);\n    ParameterFilterElement pfe = ParameterFilterElement.Create(doc, filterName, new List<ElementId>{new ElementId(BuiltInCategory.OST_Doors)}, filter);\n    doc.ActiveView.AddFilter(pfe.Id);\n}"}
{"prompt":"Create a view filter that shows only fire-rated doors.","completion":"string filterName = \"Fire Rated Doors Filter\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ParameterFilterElement)).Any(f => f.Name == filterName))\n{\n    TaskDialog.Show(\"Warning\", $\"Filter '{filterName}' already exists.\");\n}\nelse\n{\n    ElementId fireRatingParamId = new ElementId(BuiltInParameter.FIRE_RATING);\n    FilterRule rule = ParameterFilterRuleFactory.CreateHasValueRule(fireRatingParamId);\n    ElementFilter filter = new ElementParameterFilter(rule);\n    ParameterFilterElement pfe = ParameterFilterElement.Create(doc, filterName, new List<ElementId>{new ElementId(BuiltInCategory.OST_Doors)}, filter);\n    doc.ActiveView.AddFilter(pfe.Id);\n}"}
{"prompt":"Añade un refuerzo de área a una losa seleccionada.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference floorRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona una losa\");\nif (floorRef != null)\n{\n    Floor floor = doc.GetElement(floorRef) as Floor;\n    AreaReinforcementType reinforcementType = new FilteredElementCollector(doc).OfClass(typeof(AreaReinforcementType)).FirstOrDefault() as AreaReinforcementType;\n    if(floor != null && reinforcementType != null)\n    {\n        IList<Curve> profile = floor.GetBoundary(false).First();\n        AreaReinforcement.Create(doc, floor, profile, reinforcementType.Id);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no es una losa o no hay tipos de refuerzo de área.\");\n    }\n}"}
{"prompt":"Add area reinforcement to a selected slab.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference floorRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a slab\");\nif (floorRef != null)\n{\n    Floor floor = doc.GetElement(floorRef) as Floor;\n    AreaReinforcementType reinforcementType = new FilteredElementCollector(doc).OfClass(typeof(AreaReinforcementType)).FirstOrDefault() as AreaReinforcementType;\n    if(floor != null && reinforcementType != null)\n    {\n        IList<Curve> profile = floor.GetBoundary(false).First();\n        AreaReinforcement.Create(doc, floor, profile, reinforcementType.Id);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element is not a slab or no area reinforcement types exist.\");\n    }\n}"}
{"prompt":"Rota el norte real 15 grados en sentido antihorario.","completion":"BasePoint surveyPoint = new FilteredElementCollector(doc).OfClass(typeof(BasePoint)).Cast<BasePoint>().FirstOrDefault(bp => bp.IsSurveyPoint);\nif (surveyPoint != null)\n{\n    double angle = 15 * Math.PI / 180.0; // Positivo para antihorario\n    Line axis = Line.CreateBound(XYZ.Zero, XYZ.BasisZ);\n    ElementTransformUtils.RotateElement(doc, surveyPoint.Id, axis, angle);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el Punto de Levantamiento (Survey Point).\");\n}"}
{"prompt":"Rotate True North 15 degrees counter-clockwise.","completion":"BasePoint surveyPoint = new FilteredElementCollector(doc).OfClass(typeof(BasePoint)).Cast<BasePoint>().FirstOrDefault(bp => bp.IsSurveyPoint);\nif (surveyPoint != null)\n{\n    double angle = 15 * Math.PI / 180.0; // Positive for counter-clockwise\n    Line axis = Line.CreateBound(XYZ.Zero, XYZ.BasisZ);\n    ElementTransformUtils.RotateElement(doc, surveyPoint.Id, axis, angle);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Survey Point not found.\");\n}"}
{"prompt":"Coloca una etiqueta de material en una cara de muro.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference faceRef = uidoc.Selection.PickObject(ObjectType.Face, \"Selecciona una cara para etiquetar\");\nif (faceRef != null)\n{\n    XYZ point = uidoc.Selection.PickPoint(\"Selecciona la ubicación de la etiqueta\");\n    MaterialTag.Create(doc, doc.ActiveView.Id, faceRef, point, TagOrientation.Horizontal);\n}"}
{"prompt":"Place a material tag on a wall face.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference faceRef = uidoc.Selection.PickObject(ObjectType.Face, \"Select a face to tag\");\nif (faceRef != null)\n{\n    XYZ point = uidoc.Selection.PickPoint(\"Select the tag location\");\n    MaterialTag.Create(doc, doc.ActiveView.Id, faceRef, point, TagOrientation.Horizontal);\n}"}
{"prompt":"Crea un grupo de detalles con los elementos de detalle seleccionados.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    List<ElementId> detailIds = selectedIds.Where(id => doc.GetElement(id).Category.CategoryType == CategoryType.Annotation).ToList();\n    if(detailIds.Any())\n    {\n        Group group = doc.Create.NewGroup(detailIds);\n        group.Name = \"Detalle Típico 1\";\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", \"La selección no contenía elementos de detalle.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No había elementos seleccionados.\");\n}"}
{"prompt":"Create a detail group with the selected detail items.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    List<ElementId> detailIds = selectedIds.Where(id => doc.GetElement(id).Category.CategoryType == CategoryType.Annotation).ToList();\n    if(detailIds.Any())\n    {\n        Group group = doc.Create.NewGroup(detailIds);\n        group.Name = \"Typical Detail 1\";\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", \"The selection did not contain any detail items.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No elements were selected.\");\n}"}
{"prompt":"Encuentra todas las vistas de sección en el proyecto.","completion":"List<ViewSection> sectionViews = new FilteredElementCollector(doc).OfClass(typeof(ViewSection)).Cast<ViewSection>().ToList();\nTaskDialog.Show(\"Resultado\", $\"Se encontraron {sectionViews.Count} vistas de sección en el proyecto.\");"}
{"prompt":"Find all section views in the project.","completion":"List<ViewSection> sectionViews = new FilteredElementCollector(doc).OfClass(typeof(ViewSection)).Cast<ViewSection>().ToList();\nTaskDialog.Show(\"Result\", $\"Found {sectionViews.Count} section views in the project.\");"}
{"prompt":"Cambia el nombre de todas las familias cargadas que contengan 'Métrica' a 'Imperial'.","completion":"List<Family> familiesToRename = new FilteredElementCollector(doc).OfClass(typeof(Family)).Cast<Family>().Where(f => f.Name.Contains(\"Métrica\")).ToList();\nint renamedCount = 0;\nforeach(Family fam in familiesToRename)\n{\n    try\n    {\n        fam.Name = fam.Name.Replace(\"Métrica\", \"Imperial\");\n        renamedCount++;\n    }\n    catch {}\n}\nTaskDialog.Show(\"Resultado\", $\"{renamedCount} familias renombradas.\");"}
{"prompt":"Rename all loaded families containing 'Metric' to 'Imperial'.","completion":"List<Family> familiesToRename = new FilteredElementCollector(doc).OfClass(typeof(Family)).Cast<Family>().Where(f => f.Name.Contains(\"Metric\")).ToList();\nint renamedCount = 0;\nforeach(Family fam in familiesToRename)\n{\n    try\n    {\n        fam.Name = fam.Name.Replace(\"Metric\", \"Imperial\");\n        renamedCount++;\n    }\n    catch {}\n}\nTaskDialog.Show(\"Result\", $\"{renamedCount} families renamed.\");"}
{"prompt":"Crea una nueva tabla de planificación para ventanas que incluya Marca de Tipo, Ancho y Alto.","completion":"string scheduleName = \"Tabla de Ventanas\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Any(v => v.Name == scheduleName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"La tabla de planificación '{scheduleName}' ya existe.\");\n}\nelse\n{\n    ViewSchedule schedule = ViewSchedule.CreateSchedule(doc, new ElementId(BuiltInCategory.OST_Windows));\n    schedule.Name = scheduleName;\n    ScheduleDefinition def = schedule.Definition;\n    SchedulableField typeMarkField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.ALL_MODEL_TYPE_MARK);\n    SchedulableField widthField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.FAMILY_WIDTH_PARAM);\n    SchedulableField heightField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.FAMILY_HEIGHT_PARAM);\n    if(typeMarkField != null) def.AddField(typeMarkField);\n    if(widthField != null) def.AddField(widthField);\n    if(heightField != null) def.AddField(heightField);\n}"}
{"prompt":"Create a new window schedule that includes Type Mark, Width, and Height.","completion":"string scheduleName = \"Window Schedule\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Any(v => v.Name == scheduleName))\n{\n    TaskDialog.Show(\"Warning\", $\"Schedule '{scheduleName}' already exists.\");\n}\nelse\n{\n    ViewSchedule schedule = ViewSchedule.CreateSchedule(doc, new ElementId(BuiltInCategory.OST_Windows));\n    schedule.Name = scheduleName;\n    ScheduleDefinition def = schedule.Definition;\n    SchedulableField typeMarkField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.ALL_MODEL_TYPE_MARK);\n    SchedulableField widthField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.FAMILY_WIDTH_PARAM);\n    SchedulableField heightField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.FAMILY_HEIGHT_PARAM);\n    if(typeMarkField != null) def.AddField(typeMarkField);\n    if(widthField != null) def.AddField(widthField);\n    if(heightField != null) def.AddField(heightField);\n}"}
{"prompt":"Desoculta todos los elementos en la vista activa.","completion":"ElementIsHiddenFilter filter = new ElementIsHiddenFilter(false);\nList<ElementId> hiddenIds = new FilteredElementCollector(doc, doc.ActiveView.Id).WherePasses(filter).ToElementIds().ToList();\nif (hiddenIds.Any())\n{\n    doc.ActiveView.UnhideElements(hiddenIds);\n    TaskDialog.Show(\"Éxito\", $\"{hiddenIds.Count} elementos han sido mostrados.\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No había elementos ocultos en la vista.\");\n}"}
{"prompt":"Unhide all elements in the active view.","completion":"ElementIsHiddenFilter filter = new ElementIsHiddenFilter(false);\nList<ElementId> hiddenIds = new FilteredElementCollector(doc, doc.ActiveView.Id).WherePasses(filter).ToElementIds().ToList();\nif (hiddenIds.Any())\n{\n    doc.ActiveView.UnhideElements(hiddenIds);\n    TaskDialog.Show(\"Success\", $\"{hiddenIds.Count} elements have been unhidden.\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"There were no hidden elements in the view.\");\n}"}
{"prompt":"Crea un refuerzo de trayectoria en una viga seleccionada.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference beamRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona una viga\");\nif (beamRef != null)\n{\n    FamilyInstance beam = doc.GetElement(beamRef) as FamilyInstance;\n    PathReinforcementType pathType = new FilteredElementCollector(doc).OfClass(typeof(PathReinforcementType)).FirstOrDefault() as PathReinforcementType;\n    if(beam != null && pathType != null)\n    {\n        LocationCurve lc = beam.Location as LocationCurve;\n        PathReinforcement.Create(doc, beam, new List<Curve>{lc.Curve}, false, pathType.Id, 0, 0);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no es una viga o no hay tipos de refuerzo de trayectoria.\");\n    }\n}"}
{"prompt":"Create path reinforcement on a selected beam.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference beamRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a beam\");\nif (beamRef != null)\n{\n    FamilyInstance beam = doc.GetElement(beamRef) as FamilyInstance;\n    PathReinforcementType pathType = new FilteredElementCollector(doc).OfClass(typeof(PathReinforcementType)).FirstOrDefault() as PathReinforcementType;\n    if(beam != null && pathType != null)\n    {\n        LocationCurve lc = beam.Location as LocationCurve;\n        PathReinforcement.Create(doc, beam, new List<Curve>{lc.Curve}, false, pathType.Id, 0, 0);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element is not a beam or no path reinforcement types exist.\");\n    }\n}"}
{"prompt":"Crea un ensamblaje a partir de los elementos seleccionados.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif (selectedIds.Count > 1)\n{\n    AssemblyInstance assemblyInstance = AssemblyInstance.Create(doc, selectedIds, new ElementId(BuiltInCategory.OST_Assemblies));\n    assemblyInstance.Name = \"Nuevo Ensamblaje\";\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita seleccionar más de un elemento para crear un ensamblaje.\");\n}"}
{"prompt":"Create an assembly from the selected elements.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif (selectedIds.Count > 1)\n{\n    AssemblyInstance assemblyInstance = AssemblyInstance.Create(doc, selectedIds, new ElementId(BuiltInCategory.OST_Assemblies));\n    assemblyInstance.Name = \"New Assembly\";\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"More than one element must be selected to create an assembly.\");\n}"}
{"prompt":"Añade un punto de referencia en las coordenadas (1,2,3) dentro del editor de familias.","completion":"if(doc.IsFamilyDocument)\n{\n    doc.FamilyCreate.NewReferencePoint(new XYZ(1,2,3));\n}\nelse\n{\n    TaskDialog.Show(\"Error de Contexto\", \"Este comando solo funciona dentro del Editor de Familias.\");\n}"}
{"prompt":"Add a reference point at coordinates (1,2,3) inside the family editor.","completion":"if(doc.IsFamilyDocument)\n{\n    doc.FamilyCreate.NewReferencePoint(new XYZ(1,2,3));\n}\nelse\n{\n    TaskDialog.Show(\"Context Error\", \"This command only works inside the Family Editor.\");\n}"}
{"prompt":"Crea un esquema de área llamado 'Zonas de Alquiler'.","completion":"string schemeName = \"Zonas de Alquiler\";\nif (new FilteredElementCollector(doc).OfClass(typeof(AreaScheme)).Any(s => s.Name == schemeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El esquema de área '{schemeName}' ya existe.\");\n}\nelse\n{\n    AreaScheme.Create(doc, schemeName);\n    TaskDialog.Show(\"Éxito\", $\"Esquema de área '{schemeName}' creado.\");\n}"}
{"prompt":"Create an area scheme named 'Lease Zones'.","completion":"string schemeName = \"Lease Zones\";\nif (new FilteredElementCollector(doc).OfClass(typeof(AreaScheme)).Any(s => s.Name == schemeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Area scheme '{schemeName}' already exists.\");\n}\nelse\n{\n    AreaScheme.Create(doc, schemeName);\n    TaskDialog.Show(\"Success\", $\"Area scheme '{schemeName}' created.\");\n}"}
{"prompt":"Duplica la vista de planta 'Nivel 2' y conviértela en una plantilla de vista.","completion":"ViewPlan viewToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).FirstOrDefault(v => v.Name == \"Nivel 2\") as ViewPlan;\nstring templateName = \"Plantilla Nivel 2\";\nif(viewToDuplicate != null)\n{\n    if (new FilteredElementCollector(doc).OfClass(typeof(View)).Any(v => v.Name == templateName))\n    {\n        TaskDialog.Show(\"Advertencia\", $\"La plantilla '{templateName}' ya existe.\");\n    }\n    else\n    {\n        ElementId newViewId = viewToDuplicate.Duplicate(ViewDuplicateOption.Duplicate);\n        View newView = doc.GetElement(newViewId);\n        if(newView.CanBeTemplate())\n        {\n            newView.IsTemplate = true;\n            newView.Name = templateName;\n        }\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró la vista 'Nivel 2' para duplicar.\");\n}"}
{"prompt":"Duplicate the 'Level 2' plan view and make it a view template.","completion":"ViewPlan viewToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).FirstOrDefault(v => v.Name == \"Level 2\") as ViewPlan;\nstring templateName = \"Level 2 Template\";\nif(viewToDuplicate != null)\n{\n    if (new FilteredElementCollector(doc).OfClass(typeof(View)).Any(v => v.Name == templateName))\n    {\n        TaskDialog.Show(\"Warning\", $\"Template '{templateName}' already exists.\");\n    }\n    else\n    {\n        ElementId newViewId = viewToDuplicate.Duplicate(ViewDuplicateOption.Duplicate);\n        View newView = doc.GetElement(newViewId);\n        if(newView.CanBeTemplate())\n        {\n            newView.IsTemplate = true;\n            newView.Name = templateName;\n        }\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"View 'Level 2' not found to duplicate.\");\n}"}
{"prompt":"Crea una vista 3D con la caja de sección activada.","completion":"string viewName = \"Vista 3D con Caja de Sección\";\nif (new FilteredElementCollector(doc).OfClass(typeof(View3D)).Any(v => v.Name == viewName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"La vista '{viewName}' ya existe.\");\n}\nelse\n{\n    ViewFamilyType vft3D = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.ThreeDimensional);\n    if(vft3D != null)\n    {\n        View3D view3d = View3D.CreateIsometric(doc, vft3D.Id);\n        view3d.Name = viewName;\n        view3d.IsSectionBoxActive = true;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró el tipo de familia de vista 3D.\");\n    }\n}"}
{"prompt":"Create a 3D view with the section box enabled.","completion":"string viewName = \"3D View with Section Box\";\nif (new FilteredElementCollector(doc).OfClass(typeof(View3D)).Any(v => v.Name == viewName))\n{\n    TaskDialog.Show(\"Warning\", $\"View '{viewName}' already exists.\");\n}\nelse\n{\n    ViewFamilyType vft3D = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.ThreeDimensional);\n    if(vft3D != null)\n    {\n        View3D view3d = View3D.CreateIsometric(doc, vft3D.Id);\n        view3d.Name = viewName;\n        view3d.IsSectionBoxActive = true;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"3D View Family Type not found.\");\n    }\n}"}
{"prompt":"Importa un archivo CAD llamado 'BasePlan.dwg' en la vista actual.","completion":"string filePath = \"C:/CAD/BasePlan.dwg\";\nif(System.IO.File.Exists(filePath))\n{\n    DWGImportOptions options = new DWGImportOptions();\n    options.Placement = ImportPlacement.Origin;\n    ElementId importId;\n    doc.Import(filePath, options, doc.ActiveView, out importId);\n    if(importId != ElementId.InvalidElementId) TaskDialog.Show(\"Éxito\", \"Archivo DWG importado.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"Archivo no encontrado en: {filePath}\");\n}"}
{"prompt":"Import a CAD file named 'BasePlan.dwg' into the current view.","completion":"string filePath = \"C:/CAD/BasePlan.dwg\";\nif(System.IO.File.Exists(filePath))\n{\n    DWGImportOptions options = new DWGImportOptions();\n    options.Placement = ImportPlacement.Origin;\n    ElementId importId;\n    doc.Import(filePath, options, doc.ActiveView, out importId);\n    if(importId != ElementId.InvalidElementId) TaskDialog.Show(\"Success\", \"DWG file imported.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"File not found at: {filePath}\");\n}"}
{"prompt":"Mueve el punto base del proyecto 100 metros hacia el norte.","completion":"BasePoint projectBasePoint = new FilteredElementCollector(doc).OfClass(typeof(BasePoint)).Cast<BasePoint>().FirstOrDefault(bp => !bp.IsSurveyPoint);\nif(projectBasePoint != null)\n{\n    XYZ translation = new XYZ(0, UnitUtils.ConvertToInternalUnits(100, UnitTypeId.Meters), 0);\n    ElementTransformUtils.MoveElement(doc, projectBasePoint.Id, translation);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el Punto Base del Proyecto.\");\n}"}
{"prompt":"Move the project base point 100 meters to the north.","completion":"BasePoint projectBasePoint = new FilteredElementCollector(doc).OfClass(typeof(BasePoint)).Cast<BasePoint>().FirstOrDefault(bp => !bp.IsSurveyPoint);\nif(projectBasePoint != null)\n{\n    XYZ translation = new XYZ(0, UnitUtils.ConvertToInternalUnits(100, UnitTypeId.Meters), 0);\n    ElementTransformUtils.MoveElement(doc, projectBasePoint.Id, translation);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Project Base Point not found.\");\n}"}
{"prompt":"Encuentra todos los muros con el comentario 'Revisar'.","completion":"ElementId commentParamId = new ElementId(BuiltInParameter.ALL_MODEL_INSTANCE_COMMENTS);\nParameterValueProvider pvp = new ParameterValueProvider(commentParamId);\nFilterStringRuleEvaluator evaluator = new FilterStringContains();\nFilterRule rule = new FilterStringRule(pvp, evaluator, \"Revisar\", false);\nElementFilter filter = new ElementParameterFilter(rule);\nList<Element> wallsToReview = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WherePasses(filter).ToList();\nTaskDialog.Show(\"Resultado\", $\"Se encontraron {wallsToReview.Count} muros con el comentario 'Revisar'.\");\nif (wallsToReview.Any()) new UIDocument(doc).Selection.SetElementIds(wallsToReview.Select(e => e.Id).ToList());"}
{"prompt":"Find all walls with the comment 'Review'.","completion":"ElementId commentParamId = new ElementId(BuiltInParameter.ALL_MODEL_INSTANCE_COMMENTS);\nParameterValueProvider pvp = new ParameterValueProvider(commentParamId);\nFilterStringRuleEvaluator evaluator = new FilterStringContains();\nFilterRule rule = new FilterStringRule(pvp, evaluator, \"Review\", false);\nElementFilter filter = new ElementParameterFilter(rule);\nList<Element> wallsToReview = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WherePasses(filter).ToList();\nTaskDialog.Show(\"Result\", $\"Found {wallsToReview.Count} walls with the comment 'Review'.\");\nif (wallsToReview.Any()) new UIDocument(doc).Selection.SetElementIds(wallsToReview.Select(e => e.Id).ToList());"}
{"prompt":"Crea un espacio MEP para cada habitación en el Nivel 1.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nif(level1 != null)\n{\n    List<Room> roomsOnLevel1 = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).Where(r => r.LevelId == level1.Id).Cast<Room>().ToList();\n    int createdCount = 0;\n    foreach(Room room in roomsOnLevel1)\n    {\n        MEPSpace space = MEPSpace.Create(doc, room, null);\n        if (space != null) createdCount++;\n    }\n    TaskDialog.Show(\"Resultado\", $\"Se crearon {createdCount} espacios MEP en el Nivel 1.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el 'Nivel 1'.\");\n}"}
{"prompt":"Create an MEP space for each room on Level 1.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nif(level1 != null)\n{\n    List<Room> roomsOnLevel1 = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).Where(r => r.LevelId == level1.Id).Cast<Room>().ToList();\n    int createdCount = 0;\n    foreach(Room room in roomsOnLevel1)\n    {\n        MEPSpace space = MEPSpace.Create(doc, room, null);\n        if (space != null) createdCount++;\n    }\n    TaskDialog.Show(\"Result\", $\"Created {createdCount} MEP spaces on Level 1.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Level 1' not found.\");\n}"}
{"prompt":"Crea un DirectShape esférico con un radio de 5 metros.","completion":"double radius = UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters);\nBRepBuilder brepBuilder = new BRepBuilder(BRepType.Solid);\nList<GeometryObject> solids = new List<GeometryObject>();\n// Crear una esfera como un conjunto de caras\nFrame frame = new Frame(XYZ.Zero, XYZ.BasisX, XYZ.BasisY, XYZ.BasisZ);\nArc arc = Arc.Create(frame.Origin, radius, 0, Math.PI, frame.XVec, frame.YVec);\nLine line = Line.CreateBound(arc.GetEndPoint(1), arc.GetEndPoint(0));\nCurveLoop profile = CurveLoop.Create(new List<Curve> { arc, line });\nSolid sphere = GeometryCreationUtilities.CreateRevolvedGeometry(frame, new List<CurveLoop> { profile }, 0, 2 * Math.PI);\nsolids.Add(sphere);\nif (solids.Any())\n{\n    DirectShape ds = DirectShape.CreateElement(doc, new ElementId(BuiltInCategory.OST_GenericModel));\n    ds.SetShape(solids);\n    ds.Name = \"Esfera DirectShape\";\n}"}
{"prompt":"Create a spherical DirectShape with a 5-meter radius.","completion":"double radius = UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters);\nList<GeometryObject> solids = new List<GeometryObject>();\n// Create a sphere as a revolved solid\nFrame frame = new Frame(XYZ.Zero, XYZ.BasisX, XYZ.BasisY, XYZ.BasisZ);\nArc arc = Arc.Create(frame.Origin, radius, 0, Math.PI, frame.XVec, frame.YVec);\nLine line = Line.CreateBound(arc.GetEndPoint(1), arc.GetEndPoint(0));\nCurveLoop profile = CurveLoop.Create(new List<Curve> { arc, line });\nSolid sphere = GeometryCreationUtilities.CreateRevolvedGeometry(frame, new List<CurveLoop> { profile }, 0, 2 * Math.PI);\nsolids.Add(sphere);\nif (solids.Any())\n{\n    DirectShape ds = DirectShape.CreateElement(doc, new ElementId(BuiltInCategory.OST_GenericModel));\n    ds.SetShape(solids);\n    ds.Name = \"Sphere DirectShape\";\n}"}
{"prompt":"Asigna el material 'Acero' a la primera capa de un tipo de muro.","completion":"WallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault(wt => wt.GetCompoundStructure() != null) as WallType;\nMaterial steel = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name.Contains(\"Steel\") || m.Name.Contains(\"Acero\")) as Material;\nif(wallType != null && steel != null)\n{\n    CompoundStructure cs = wallType.GetCompoundStructure();\n    if(cs.GetLayerCount() > 0)\n    {\n        cs.SetMaterialId(0, steel.Id);\n        wallType.SetCompoundStructure(cs);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró un tipo de muro con capas o el material 'Acero'.\");\n}"}
{"prompt":"Assign the 'Steel' material to the first layer of a wall type.","completion":"WallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault(wt => wt.GetCompoundStructure() != null) as WallType;\nMaterial steel = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name.Contains(\"Steel\")) as Material;\nif(wallType != null && steel != null)\n{\n    CompoundStructure cs = wallType.GetCompoundStructure();\n    if(cs.GetLayerCount() > 0)\n    {\n        cs.SetMaterialId(0, steel.Id);\n        wallType.SetCompoundStructure(cs);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A wall type with layers or the 'Steel' material was not found.\");\n}"}
{"prompt":"Cambia el nombre de la vista activa a 'Vista de Trabajo'.","completion":"string newName = \"Vista de Trabajo\";\nif (new FilteredElementCollector(doc).OfClass(typeof(View)).Any(v => v.Name == newName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"Ya existe una vista con el nombre '{newName}'.\");\n}\nelse\n{\n    doc.ActiveView.Name = newName;\n}"}
{"prompt":"Rename the active view to 'Working View'.","completion":"string newName = \"Working View\";\nif (new FilteredElementCollector(doc).OfClass(typeof(View)).Any(v => v.Name == newName))\n{\n    TaskDialog.Show(\"Warning\", $\"A view named '{newName}' already exists.\");\n}\nelse\n{\n    doc.ActiveView.Name = newName;\n}"}
{"prompt":"Crea una vista 3D orientada desde el sureste.","completion":"string viewName = \"Vista 3D Sureste\";\nif (new FilteredElementCollector(doc).OfClass(typeof(View3D)).Any(v => v.Name == viewName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"La vista '{viewName}' ya existe.\");\n}\nelse\n{\n    ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.ThreeDimensional);\n    if(vft != null)\n    {\n        View3D view3d = View3D.CreateIsometric(doc, vft.Id);\n        XYZ eye = new XYZ(1, -1, 1);\n        XYZ up = new XYZ(0, 0, 1);\n        XYZ forward = new XYZ(-1, 1, -1);\n        view3d.SetOrientation(new ViewOrientation3D(eye, up, forward));\n        view3d.Name = viewName;\n    }\n}"}
{"prompt":"Create a 3D view oriented from the southeast.","completion":"string viewName = \"3D View Southeast\";\nif (new FilteredElementCollector(doc).OfClass(typeof(View3D)).Any(v => v.Name == viewName))\n{\n    TaskDialog.Show(\"Warning\", $\"View '{viewName}' already exists.\");\n}\nelse\n{\n    ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.ThreeDimensional);\n    if(vft != null)\n    {\n        View3D view3d = View3D.CreateIsometric(doc, vft.Id);\n        XYZ eye = new XYZ(1, -1, 1);\n        XYZ up = new XYZ(0, 0, 1);\n        XYZ forward = new XYZ(-1, 1, -1);\n        view3d.SetOrientation(new ViewOrientation3D(eye, up, forward));\n        view3d.Name = viewName;\n    }\n}"}

{"prompt":"Encuentra todas las familias de anotación y cuenta cuántas hay.","completion":"List<Family> annotationFamilies = new FilteredElementCollector(doc).OfClass(typeof(Family)).Cast<Family>().Where(f => f.FamilyCategory != null && f.FamilyCategory.CategoryType == CategoryType.Annotation).ToList();\nTaskDialog.Show(\"Conteo\", $\"Hay {annotationFamilies.Count} familias de anotación en el proyecto.\");"}
{"prompt":"Find all annotation families and count how many there are.","completion":"List<Family> annotationFamilies = new FilteredElementCollector(doc).OfClass(typeof(Family)).Cast<Family>().Where(f => f.FamilyCategory != null && f.FamilyCategory.CategoryType == CategoryType.Annotation).ToList();\nTaskDialog.Show(\"Count\", $\"There are {annotationFamilies.Count} annotation families in the project.\");"}
{"prompt":"Ajusta todas las ventanas para que la altura del antepecho sea 1 metro.","completion":"double sillHeight = UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters);\nList<FamilyInstance> windows = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().Cast<FamilyInstance>().ToList();\nint updatedCount = 0;\nforeach(FamilyInstance window in windows)\n{\n    Parameter sillHeightParam = window.get_Parameter(BuiltInParameter.INSTANCE_SILL_HEIGHT_PARAM);\n    if(sillHeightParam != null && !sillHeightParam.IsReadOnly)\n    {\n        sillHeightParam.Set(sillHeight);\n        updatedCount++;\n    }\n}\nTaskDialog.Show(\"Resultado\", $\"{updatedCount} ventanas actualizadas a una altura de antepecho de 1m.\");"}
{"prompt":"Set the sill height of all windows to 1 meter.","completion":"double sillHeight = UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters);\nList<FamilyInstance> windows = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().Cast<FamilyInstance>().ToList();\nint updatedCount = 0;\nforeach(FamilyInstance window in windows)\n{\n    Parameter sillHeightParam = window.get_Parameter(BuiltInParameter.INSTANCE_SILL_HEIGHT_PARAM);\n    if(sillHeightParam != null && !sillHeightParam.IsReadOnly)\n    {\n        sillHeightParam.Set(sillHeight);\n        updatedCount++;\n    }\n}\nTaskDialog.Show(\"Result\", $\"{updatedCount} windows were updated to a 1m sill height.\");"}
{"prompt":"Crea un nuevo tipo de puerta llamado 'Puerta RF-90' y establece su resistencia al fuego a '90 min'.","completion":"string newTypeName = \"Puerta RF-90\";\nif (new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().Any(t => t.Name == newTypeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de puerta '{newTypeName}' ya existe.\");\n}\nelse\n{\n    FamilySymbol doorTypeToDuplicate = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\n    if (doorTypeToDuplicate != null)\n    {\n        FamilySymbol newDoorType = doorTypeToDuplicate.Duplicate(newTypeName) as FamilySymbol;\n        Parameter fireRatingParam = newDoorType.get_Parameter(BuiltInParameter.FIRE_RATING);\n        if (fireRatingParam != null && !fireRatingParam.IsReadOnly) fireRatingParam.Set(\"90 min\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontraron tipos de puerta para duplicar.\");\n    }\n}"}
{"prompt":"Create a new door type named 'FR-90 Door' and set its fire rating to '90 min'.","completion":"string newTypeName = \"FR-90 Door\";\nif (new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().Any(t => t.Name == newTypeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Door type '{newTypeName}' already exists.\");\n}\nelse\n{\n    FamilySymbol doorTypeToDuplicate = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\n    if (doorTypeToDuplicate != null)\n    {\n        FamilySymbol newDoorType = doorTypeToDuplicate.Duplicate(newTypeName) as FamilySymbol;\n        Parameter fireRatingParam = newDoorType.get_Parameter(BuiltInParameter.FIRE_RATING);\n        if (fireRatingParam != null && !fireRatingParam.IsReadOnly) fireRatingParam.Set(\"90 min\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No door types found to duplicate.\");\n    }\n}"}
{"prompt":"Copia todos los elementos del Nivel 1 al Nivel 2.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nLevel level2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 2\") as Level;\nif (level1 != null && level2 != null)\n{\n    ICollection<ElementId> elementsToCopy = new FilteredElementCollector(doc, level1.Id).WhereElementIsNotElementType().ToElementIds();\n    if(elementsToCopy.Any())\n    {\n        double elevationDiff = level2.ProjectElevation - level1.ProjectElevation;\n        XYZ translation = new XYZ(0, 0, elevationDiff);\n        ElementTransformUtils.CopyElements(doc, elementsToCopy, translation);\n        TaskDialog.Show(\"Éxito\", $\"{elementsToCopy.Count} elementos copiados del '{level1.Name}' al '{level2.Name}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", \"No se encontraron elementos en el Nivel 1 para copiar.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron los niveles 'Nivel 1' o 'Nivel 2'.\");\n}"}
{"prompt":"Copy all elements from Level 1 to Level 2.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nLevel level2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 2\") as Level;\nif (level1 != null && level2 != null)\n{\n    ICollection<ElementId> elementsToCopy = new FilteredElementCollector(doc, level1.Id).WhereElementIsNotElementType().ToElementIds();\n    if(elementsToCopy.Any())\n    {\n        double elevationDiff = level2.ProjectElevation - level1.ProjectElevation;\n        XYZ translation = new XYZ(0, 0, elevationDiff);\n        ElementTransformUtils.CopyElements(doc, elementsToCopy, translation);\n        TaskDialog.Show(\"Success\", $\"{elementsToCopy.Count} elements copied from '{level1.Name}' to '{level2.Name}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", \"No elements were found on Level 1 to copy.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Level 1' or 'Level 2' not found.\");\n}"}
{"prompt":"Crea un nuevo tipo de texto de 5mm de color verde.","completion":"string newTypeName = \"5mm Verde\";\nif (new FilteredElementCollector(doc).OfClass(typeof(TextNoteType)).Any(t => t.Name == newTypeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de texto '{newTypeName}' ya existe.\");\n}\nelse\n{\n    TextNoteType defaultType = new FilteredElementCollector(doc).OfClass(typeof(TextNoteType)).FirstOrDefault() as TextNoteType;\n    if (defaultType != null)\n    {\n        TextNoteType newType = defaultType.Duplicate(newTypeName) as TextNoteType;\n        newType.get_Parameter(BuiltInParameter.TEXT_SIZE).Set(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Millimeters));\n        newType.get_Parameter(BuiltInParameter.LINE_COLOR).Set(new Color(0,255,0).GetElementId());\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró un tipo de texto por defecto para duplicar.\");\n    }\n}"}
{"prompt":"Create a new 5mm text type in green color.","completion":"string newTypeName = \"5mm Green\";\nif (new FilteredElementCollector(doc).OfClass(typeof(TextNoteType)).Any(t => t.Name == newTypeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Text type '{newTypeName}' already exists.\");\n}\nelse\n{\n    TextNoteType defaultType = new FilteredElementCollector(doc).OfClass(typeof(TextNoteType)).FirstOrDefault() as TextNoteType;\n    if (defaultType != null)\n    {\n        TextNoteType newType = defaultType.Duplicate(newTypeName) as TextNoteType;\n        newType.get_Parameter(BuiltInParameter.TEXT_SIZE).Set(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Millimeters));\n        newType.get_Parameter(BuiltInParameter.LINE_COLOR).Set(new Color(0,255,0).GetElementId());\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No default text type was found to duplicate.\");\n    }\n}"}
{"prompt":"Encuentra todos los muros con más de 4 metros de altura.","completion":"double heightThreshold = UnitUtils.ConvertToInternalUnits(4, UnitTypeId.Meters);\nParameterValueProvider pvp = new ParameterValueProvider(new ElementId(BuiltInParameter.WALL_USER_HEIGHT_PARAM));\nFilterRule rule = new FilterDoubleRule(pvp, new FilterNumericGreater(), heightThreshold, 1e-6);\nList<Element> tallWalls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WherePasses(new ElementParameterFilter(rule)).ToList();\nTaskDialog.Show(\"Resultado\", $\"Se encontraron {tallWalls.Count} muros con más de 4 metros de altura.\");\nif (tallWalls.Any()) new UIDocument(doc).Selection.SetElementIds(tallWalls.Select(e => e.Id).ToList());"}
{"prompt":"Find all walls taller than 4 meters.","completion":"double heightThreshold = UnitUtils.ConvertToInternalUnits(4, UnitTypeId.Meters);\nParameterValueProvider pvp = new ParameterValueProvider(new ElementId(BuiltInParameter.WALL_USER_HEIGHT_PARAM));\nFilterRule rule = new FilterDoubleRule(pvp, new FilterNumericGreater(), heightThreshold, 1e-6);\nList<Element> tallWalls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WherePasses(new ElementParameterFilter(rule)).ToList();\nTaskDialog.Show(\"Result\", $\"Found {tallWalls.Count} walls taller than 4 meters.\");\nif (tallWalls.Any()) new UIDocument(doc).Selection.SetElementIds(tallWalls.Select(e => e.Id).ToList());"}
{"prompt":"Aplica un desfase de -10cm a todos los muros seleccionados desde su línea de ubicación.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    double offset = UnitUtils.ConvertToInternalUnits(-10, UnitTypeId.Centimeters);\n    int updatedCount = 0;\n    foreach(ElementId id in selectedIds)\n    {\n        Wall wall = doc.GetElement(id) as Wall;\n        if(wall != null)\n        {\n            wall.get_Parameter(BuiltInParameter.WALL_BASE_OFFSET).Set(offset);\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{updatedCount} muros desfasados.\");\n}"}
{"prompt":"Apply a -10cm offset to all selected walls from their location line.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    double offset = UnitUtils.ConvertToInternalUnits(-10, UnitTypeId.Centimeters);\n    int updatedCount = 0;\n    foreach(ElementId id in selectedIds)\n    {\n        Wall wall = doc.GetElement(id) as Wall;\n        if(wall != null)\n        {\n            wall.get_Parameter(BuiltInParameter.WALL_BASE_OFFSET).Set(offset);\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{updatedCount} walls were offset.\");\n}"}
{"prompt":"Duplica la vista activa con detalles.","completion":"View activeView = doc.ActiveView;\nElementId newViewId = activeView.Duplicate(ViewDuplicateOption.WithDetailing);\nif (newViewId != ElementId.InvalidElementId)\n{\n    View newView = doc.GetElement(newViewId) as View;\n    if(newView != null) TaskDialog.Show(\"Éxito\", $\"Vista '{activeView.Name}' duplicada como '{newView.Name}'.\");\n}"}
{"prompt":"Duplicate the active view with detailing.","completion":"View activeView = doc.ActiveView;\nElementId newViewId = activeView.Duplicate(ViewDuplicateOption.WithDetailing);\nif (newViewId != ElementId.InvalidElementId)\n{\n    View newView = doc.GetElement(newViewId) as View;\n    if(newView != null) TaskDialog.Show(\"Success\", $\"View '{activeView.Name}' duplicated as '{newView.Name}'.\");\n}"}
{"prompt":"Establece la escala de la vista activa a 1:50.","completion":"View activeView = doc.ActiveView;\nif(activeView.CanModifyViewScale())\n{\n    activeView.Scale = 50;\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"La escala de esta vista está controlada por una plantilla de vista.\");\n}"}
{"prompt":"Set the active view's scale to 1:50.","completion":"View activeView = doc.ActiveView;\nif(activeView.CanModifyViewScale())\n{\n    activeView.Scale = 50;\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"The scale of this view is controlled by a view template.\");\n}"}
{"prompt":"Crea un nuevo tipo de suelo 'Suelo Genérico 30cm'.","completion":"string newTypeName = \"Suelo Genérico 30cm\";\nif (new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Any(ft => ft.Name == newTypeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de suelo '{newTypeName}' ya existe.\");\n}\nelse\n{\n    FloorType floorTypeToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\n    if(floorTypeToDuplicate != null)\n    {\n        FloorType newType = floorTypeToDuplicate.Duplicate(newTypeName) as FloorType;\n        CompoundStructure cs = newType.GetCompoundStructure();\n        if(cs.GetLayerCount() > 0) cs.SetLayerWidth(cs.GetFirstCoreLayerIndex(), UnitUtils.ConvertToInternalUnits(30, UnitTypeId.Centimeters));\n        newType.SetCompoundStructure(cs);\n        TaskDialog.Show(\"Éxito\", $\"Tipo de suelo '{newTypeName}' creado.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró un tipo de suelo para duplicar.\");\n    }\n}"}
{"prompt":"Create a new floor type 'Generic Floor 30cm'.","completion":"string newTypeName = \"Generic Floor 30cm\";\nif (new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Any(ft => ft.Name == newTypeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Floor type '{newTypeName}' already exists.\");\n}\nelse\n{\n    FloorType floorTypeToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\n    if(floorTypeToDuplicate != null)\n    {\n        FloorType newType = floorTypeToDuplicate.Duplicate(newTypeName) as FloorType;\n        CompoundStructure cs = newType.GetCompoundStructure();\n        if(cs.GetLayerCount() > 0) cs.SetLayerWidth(cs.GetFirstCoreLayerIndex(), UnitUtils.ConvertToInternalUnits(30, UnitTypeId.Centimeters));\n        newType.SetCompoundStructure(cs);\n        TaskDialog.Show(\"Success\", $\"Floor type '{newTypeName}' created.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No floor type found to duplicate.\");\n    }\n}"}
{"prompt":"Haz que todos los muros seleccionados sean estructurales.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nint updatedCount = 0;\nif (selectedIds.Any())\n{\n    foreach(ElementId id in selectedIds)\n    {\n        Wall wall = doc.GetElement(id) as Wall;\n        if(wall != null)\n        {\n            wall.get_Parameter(BuiltInParameter.WALL_STRUCTURAL_SIGNIFICANT).Set(1);\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{updatedCount} muros ahora son estructurales.\");\n}"}
{"prompt":"Make all selected walls structural.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nint updatedCount = 0;\nif (selectedIds.Any())\n{\n    foreach(ElementId id in selectedIds)\n    {\n        Wall wall = doc.GetElement(id) as Wall;\n        if(wall != null)\n        {\n            wall.get_Parameter(BuiltInParameter.WALL_STRUCTURAL_SIGNIFICANT).Set(1);\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{updatedCount} walls are now structural.\");\n}"}
{"prompt":"Obtén todos los muros del Nivel 1 que son estructurales.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nif(level1 != null)\n{\n    ElementLevelFilter levelFilter = new ElementLevelFilter(level1.Id);\n    ElementCategoryFilter categoryFilter = new ElementCategoryFilter(BuiltInCategory.OST_Walls);\n    ParameterValueProvider pvp = new ParameterValueProvider(new ElementId(BuiltInParameter.WALL_STRUCTURAL_SIGNIFICANT));\n    FilterIntegerRule rule = new FilterIntegerRule(pvp, new FilterNumericEquals(), 1);\n    ElementParameterFilter structuralFilter = new ElementParameterFilter(rule);\n    LogicalAndFilter andFilter = new LogicalAndFilter(new List<ElementFilter> { levelFilter, categoryFilter, structuralFilter });\n    List<Element> structuralWalls = new FilteredElementCollector(doc).WherePasses(andFilter).ToList();\n    TaskDialog.Show(\"Resultado\", $\"Se encontraron {structuralWalls.Count} muros estructurales en el Nivel 1.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el 'Nivel 1'.\");\n}"}
{"prompt":"Get all walls on Level 1 that are structural.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nif(level1 != null)\n{\n    ElementLevelFilter levelFilter = new ElementLevelFilter(level1.Id);\n    ElementCategoryFilter categoryFilter = new ElementCategoryFilter(BuiltInCategory.OST_Walls);\n    ParameterValueProvider pvp = new ParameterValueProvider(new ElementId(BuiltInParameter.WALL_STRUCTURAL_SIGNIFICANT));\n    FilterIntegerRule rule = new FilterIntegerRule(pvp, new FilterNumericEquals(), 1);\n    ElementParameterFilter structuralFilter = new ElementParameterFilter(rule);\n    LogicalAndFilter andFilter = new LogicalAndFilter(new List<ElementFilter> { levelFilter, categoryFilter, structuralFilter });\n    List<Element> structuralWalls = new FilteredElementCollector(doc).WherePasses(andFilter).ToList();\n    TaskDialog.Show(\"Result\", $\"Found {structuralWalls.Count} structural walls on Level 1.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Level 1' not found.\");\n}"}
{"prompt":"Crea una nueva tabla de planificación para Pilares Estructurales.","completion":"string scheduleName = \"Tabla de Pilares Estructurales\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Any(v => v.Name == scheduleName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"La tabla '{scheduleName}' ya existe.\");\n}\nelse\n{\n    ElementId categoryId = new ElementId(BuiltInCategory.OST_StructuralColumns);\n    ViewSchedule.CreateSchedule(doc, categoryId).Name = scheduleName;\n}"}
{"prompt":"Create a new schedule for Structural Columns.","completion":"string scheduleName = \"Structural Column Schedule\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Any(v => v.Name == scheduleName))\n{\n    TaskDialog.Show(\"Warning\", $\"Schedule '{scheduleName}' already exists.\");\n}\nelse\n{\n    ElementId categoryId = new ElementId(BuiltInCategory.OST_StructuralColumns);\n    ViewSchedule.CreateSchedule(doc, categoryId).Name = scheduleName;\n}"}
{"prompt":"Añade los campos 'Nivel', 'Marca' y 'Volumen' a la tabla de pilares.","completion":"ViewSchedule schedule = new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Cast<ViewSchedule>().FirstOrDefault(s => s.Name.Contains(\"Pilares\") || s.Name.Contains(\"Column\"));\nif(schedule != null)\n{\n    ScheduleDefinition def = schedule.Definition;\n    SchedulableField levelField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.FAMILY_LEVEL_PARAM);\n    SchedulableField markField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.ALL_MODEL_MARK);\n    SchedulableField volumeField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.HOST_VOLUME_COMPUTED);\n    if(levelField != null && !def.GetFieldIds().Any(id => id == levelField.FieldId)) def.AddField(levelField);\n    if(markField != null && !def.GetFieldIds().Any(id => id == markField.FieldId)) def.AddField(markField);\n    if(volumeField != null && !def.GetFieldIds().Any(id => id == volumeField.FieldId)) def.AddField(volumeField);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró una tabla de planificación de pilares.\");\n}"}
{"prompt":"Add the 'Level', 'Mark', and 'Volume' fields to the column schedule.","completion":"ViewSchedule schedule = new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Cast<ViewSchedule>().FirstOrDefault(s => s.Name.Contains(\"Column\"));\nif(schedule != null)\n{\n    ScheduleDefinition def = schedule.Definition;\n    SchedulableField levelField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.FAMILY_LEVEL_PARAM);\n    SchedulableField markField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.ALL_MODEL_MARK);\n    SchedulableField volumeField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.HOST_VOLUME_COMPUTED);\n    if(levelField != null && !def.GetFieldIds().Any(id => id == levelField.FieldId)) def.AddField(levelField);\n    if(markField != null && !def.GetFieldIds().Any(id => id == markField.FieldId)) def.AddField(markField);\n    if(volumeField != null && !def.GetFieldIds().Any(id => id == volumeField.FieldId)) def.AddField(volumeField);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No column schedule was found.\");\n}"}
{"prompt":"Crea una nueva hoja A3 y colócale una leyenda.","completion":"string sheetNumber = \"G-002\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewSheet)).Any(s => s.SheetNumber == sheetNumber))\n{\n    TaskDialog.Show(\"Advertencia\", $\"Ya existe una hoja con el número '{sheetNumber}'.\");\n}\nelse\n{\n    FamilySymbol titleBlock = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_TitleBlocks).WhereElementIsElementType().FirstOrDefault(tb => tb.Name.Contains(\"A3\")) as FamilySymbol;\n    ViewLegend legendView = new FilteredElementCollector(doc).OfClass(typeof(ViewLegend)).FirstOrDefault() as ViewLegend;\n    if(titleBlock != null && legendView != null)\n    {\n        ViewSheet newSheet = ViewSheet.Create(doc, titleBlock.Id);\n        newSheet.Name = \"Leyendas\";\n        newSheet.SheetNumber = sheetNumber;\n        if(Viewport.CanAddViewToSheet(doc, newSheet.Id, legendView.Id))\n        {\n            XYZ centerPoint = (newSheet.Outline.Min + newSheet.Outline.Max) / 2;\n            Viewport.Create(doc, newSheet.Id, legendView.Id, centerPoint);\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Se necesita un cajetín A3 y una vista de leyenda en el proyecto.\");\n    }\n}"}
{"prompt":"Create a new A3 sheet and place a legend on it.","completion":"string sheetNumber = \"G-002\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewSheet)).Any(s => s.SheetNumber == sheetNumber))\n{\n    TaskDialog.Show(\"Warning\", $\"A sheet with number '{sheetNumber}' already exists.\");\n}\nelse\n{\n    FamilySymbol titleBlock = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_TitleBlocks).WhereElementIsElementType().FirstOrDefault(tb => tb.Name.Contains(\"A3\")) as FamilySymbol;\n    ViewLegend legendView = new FilteredElementCollector(doc).OfClass(typeof(ViewLegend)).FirstOrDefault() as ViewLegend;\n    if(titleBlock != null && legendView != null)\n    {\n        ViewSheet newSheet = ViewSheet.Create(doc, titleBlock.Id);\n        newSheet.Name = \"Legends\";\n        newSheet.SheetNumber = sheetNumber;\n        if(Viewport.CanAddViewToSheet(doc, newSheet.Id, legendView.Id))\n        {\n            XYZ centerPoint = (newSheet.Outline.Min + newSheet.Outline.Max) / 2;\n            Viewport.Create(doc, newSheet.Id, legendView.Id, centerPoint);\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"An A3 title block and a legend view are required in the project.\");\n    }\n}"}
{"prompt":"Obtén todas las familias de puertas cargadas en el proyecto.","completion":"List<Family> doorFamilies = new FilteredElementCollector(doc).OfClass(typeof(Family)).Cast<Family>().Where(f => f.FamilyCategory != null && f.FamilyCategory.Id.IntegerValue == (int)BuiltInCategory.OST_Doors).ToList();\nTaskDialog.Show(\"Resultado\", $\"Se encontraron {doorFamilies.Count} familias de puertas.\");"}
{"prompt":"Get all door families loaded in the project.","completion":"List<Family> doorFamilies = new FilteredElementCollector(doc).OfClass(typeof(Family)).Cast<Family>().Where(f => f.FamilyCategory != null && f.FamilyCategory.Id.IntegerValue == (int)BuiltInCategory.OST_Doors).ToList();\nTaskDialog.Show(\"Result\", $\"Found {doorFamilies.Count} door families.\");"}
{"prompt":"Aplica el estilo visual 'Rayos X' a la vista 3D activa.","completion":"View3D view3d = doc.ActiveView as View3D;\nif(view3d != null)\n{\n    TaskDialog.Show(\"Información\", \"La API de Revit no tiene un modo 'Rayos X' directo. Se aplicará el estilo 'Línea Oculta' con transparencia para un efecto similar. Pide 'Hacer muros transparentes' para continuar.\");\n    view3d.DisplayStyle = DisplayStyle.HLR;\n}"}
{"prompt":"Apply the 'X-Ray' visual style to the active 3D view.","completion":"View3D view3d = doc.ActiveView as View3D;\nif(view3d != null)\n{\n    TaskDialog.Show(\"Information\", \"The Revit API does not have a direct 'X-Ray' mode. 'Hidden Line' style with transparency will be applied for a similar effect. Ask 'Make walls transparent' to continue.\");\n    view3d.DisplayStyle = DisplayStyle.HLR;\n}"}
{"prompt":"Crea una losa de cimentación estructural de 40cm de espesor.","completion":"string newTypeName = \"Losa Cimentación 40cm\";\nLevel foundationLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.IsGroundPlane) as Level;\nFloorType newSlabType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Cast<FloorType>().FirstOrDefault(ft => ft.Name == newTypeName);\nif (newSlabType == null)\n{\n    FloorType slabTypeToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Cast<FloorType>().FirstOrDefault(ft => ft.Category.Id.IntegerValue == (int)BuiltInCategory.OST_StructuralFoundations);\n    if (slabTypeToDuplicate != null)\n    {\n        newSlabType = slabTypeToDuplicate.Duplicate(newTypeName) as FloorType;\n        CompoundStructure cs = newSlabType.GetCompoundStructure();\n        if(cs.GetLayerCount() > 0) cs.SetLayerWidth(cs.GetFirstCoreLayerIndex(), UnitUtils.ConvertToInternalUnits(40, UnitTypeId.Centimeters));\n        newSlabType.SetCompoundStructure(cs);\n    }\n}\nif(foundationLevel != null && newSlabType != null)\n{\n    CurveLoop profile = CurveLoop.CreateViaRectangle(new XYZ(0,0,0), new XYZ(10,10,0));\n    Floor.Create(doc, new List<CurveLoop>{profile}, newSlabType.Id, foundationLevel.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un nivel de cimentación y un tipo de losa estructural.\");\n}"}
{"prompt":"Create a structural foundation slab 40cm thick.","completion":"string newTypeName = \"Foundation Slab 40cm\";\nLevel foundationLevel = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.IsGroundPlane) as Level;\nFloorType newSlabType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Cast<FloorType>().FirstOrDefault(ft => ft.Name == newTypeName);\nif (newSlabType == null)\n{\n    FloorType slabTypeToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Cast<FloorType>().FirstOrDefault(ft => ft.Category.Id.IntegerValue == (int)BuiltInCategory.OST_StructuralFoundations);\n    if (slabTypeToDuplicate != null)\n    {\n        newSlabType = slabTypeToDuplicate.Duplicate(newTypeName) as FloorType;\n        CompoundStructure cs = newSlabType.GetCompoundStructure();\n        if(cs.GetLayerCount() > 0) cs.SetLayerWidth(cs.GetFirstCoreLayerIndex(), UnitUtils.ConvertToInternalUnits(40, UnitTypeId.Centimeters));\n        newSlabType.SetCompoundStructure(cs);\n    }\n}\nif(foundationLevel != null && newSlabType != null)\n{\n    CurveLoop profile = CurveLoop.CreateViaRectangle(new XYZ(0,0,0), new XYZ(10,10,0));\n    Floor.Create(doc, new List<CurveLoop>{profile}, newSlabType.Id, foundationLevel.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A foundation level and a structural slab type are required.\");\n}"}
{"prompt":"Crea un techo por extrusión con un perfil en arco.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nRoofType roofType = new FilteredElementCollector(doc).OfClass(typeof(RoofType)).FirstOrDefault() as RoofType;\nif(level != null && roofType != null)\n{\n    CurveLoop profile = new CurveLoop();\n    profile.Append(Arc.Create(new XYZ(-10,0,0), new XYZ(10,0,0), new XYZ(0,5,0)));\n    ReferencePlane refPlane = ReferencePlane.Create(doc, new XYZ(0,0,level.ProjectElevation), XYZ.BasisY, doc.ActiveView);\n    doc.Create.NewExtrusionRoof(profile, refPlane, level, roofType, 0, 20);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un nivel y un tipo de techo para esta operación.\");\n}"}
{"prompt":"Create an extrusion roof with an arc profile.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nRoofType roofType = new FilteredElementCollector(doc).OfClass(typeof(RoofType)).FirstOrDefault() as RoofType;\nif(level != null && roofType != null)\n{\n    CurveLoop profile = new CurveLoop();\n    profile.Append(Arc.Create(new XYZ(-10,0,0), new XYZ(10,0,0), new XYZ(0,5,0)));\n    ReferencePlane refPlane = ReferencePlane.Create(doc, new XYZ(0,0,level.ProjectElevation), XYZ.BasisY, doc.ActiveView);\n    doc.Create.NewExtrusionRoof(profile, refPlane, level, roofType, 0, 20);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A level and a roof type are needed for this operation.\");\n}"}
{"prompt":"Oculta todos los elementos de anotación en la vista activa.","completion":"List<BuiltInCategory> annotationCategories = new List<BuiltInCategory>\n{\n    BuiltInCategory.OST_GenericAnnotation,\n    BuiltInCategory.OST_TextNotes,\n    BuiltInCategory.OST_Tags,\n    BuiltInCategory.OST_Dimensions,\n    BuiltInCategory.OST_DetailComponents\n};\nElementMulticategoryFilter multiCategoryFilter = new ElementMulticategoryFilter(annotationCategories);\nICollection<ElementId> elementsToHide = new FilteredElementCollector(doc, doc.ActiveView.Id).WherePasses(multiCategoryFilter).ToElementIds();\nif(elementsToHide.Any())\n{\n    doc.ActiveView.HideElements(elementsToHide);\n    TaskDialog.Show(\"Resultado\", $\"{elementsToHide.Count} elementos de anotación ocultados.\");\n}"}
{"prompt":"Hide all annotation elements in the active view.","completion":"List<BuiltInCategory> annotationCategories = new List<BuiltInCategory>\n{\n    BuiltInCategory.OST_GenericAnnotation,\n    BuiltInCategory.OST_TextNotes,\n    BuiltInCategory.OST_Tags,\n    BuiltInCategory.OST_Dimensions,\n    BuiltInCategory.OST_DetailComponents\n};\nElementMulticategoryFilter multiCategoryFilter = new ElementMulticategoryFilter(annotationCategories);\nICollection<ElementId> elementsToHide = new FilteredElementCollector(doc, doc.ActiveView.Id).WherePasses(multiCategoryFilter).ToElementIds();\nif(elementsToHide.Any())\n{\n    doc.ActiveView.HideElements(elementsToHide);\n    TaskDialog.Show(\"Result\", $\"{elementsToHide.Count} annotation elements were hidden.\");\n}"}

{"prompt":"Encuentra todas las familias de anotación y cuenta cuántas hay.","completion":"List<Family> annotationFamilies = new FilteredElementCollector(doc).OfClass(typeof(Family)).Cast<Family>().Where(f => f.FamilyCategory != null && f.FamilyCategory.CategoryType == CategoryType.Annotation).ToList();\nTaskDialog.Show(\"Conteo\", $\"Hay {annotationFamilies.Count} familias de anotación en el proyecto.\");"}
{"prompt":"Find all annotation families and count how many there are.","completion":"List<Family> annotationFamilies = new FilteredElementCollector(doc).OfClass(typeof(Family)).Cast<Family>().Where(f => f.FamilyCategory != null && f.FamilyCategory.CategoryType == CategoryType.Annotation).ToList();\nTaskDialog.Show(\"Count\", $\"There are {annotationFamilies.Count} annotation families in the project.\");"}
{"prompt":"Ajusta todas las ventanas para que la altura del antepecho sea 1 metro.","completion":"double sillHeight = UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters);\nList<FamilyInstance> windows = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().Cast<FamilyInstance>().ToList();\nint updatedCount = 0;\nforeach(FamilyInstance window in windows)\n{\n    Parameter sillHeightParam = window.get_Parameter(BuiltInParameter.INSTANCE_SILL_HEIGHT_PARAM);\n    if(sillHeightParam != null && !sillHeightParam.IsReadOnly)\n    {\n        sillHeightParam.Set(sillHeight);\n        updatedCount++;\n    }\n}\nTaskDialog.Show(\"Resultado\", $\"{updatedCount} ventanas actualizadas a una altura de antepecho de 1m.\");"}
{"prompt":"Set the sill height of all windows to 1 meter.","completion":"double sillHeight = UnitUtils.ConvertToInternalUnits(1, UnitTypeId.Meters);\nList<FamilyInstance> windows = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().Cast<FamilyInstance>().ToList();\nint updatedCount = 0;\nforeach(FamilyInstance window in windows)\n{\n    Parameter sillHeightParam = window.get_Parameter(BuiltInParameter.INSTANCE_SILL_HEIGHT_PARAM);\n    if(sillHeightParam != null && !sillHeightParam.IsReadOnly)\n    {\n        sillHeightParam.Set(sillHeight);\n        updatedCount++;\n    }\n}\nTaskDialog.Show(\"Result\", $\"{updatedCount} windows were updated to a 1m sill height.\");"}
{"prompt":"Crea un nuevo tipo de puerta llamado 'Puerta RF-90' y establece su resistencia al fuego a '90 min'.","completion":"string newTypeName = \"Puerta RF-90\";\nif (new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().Any(t => t.Name == newTypeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de puerta '{newTypeName}' ya existe.\");\n}\nelse\n{\n    FamilySymbol doorTypeToDuplicate = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\n    if (doorTypeToDuplicate != null)\n    {\n        FamilySymbol newDoorType = doorTypeToDuplicate.Duplicate(newTypeName) as FamilySymbol;\n        Parameter fireRatingParam = newDoorType.get_Parameter(BuiltInParameter.FIRE_RATING);\n        if (fireRatingParam != null && !fireRatingParam.IsReadOnly) fireRatingParam.Set(\"90 min\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontraron tipos de puerta para duplicar.\");\n    }\n}"}
{"prompt":"Create a new door type named 'FR-90 Door' and set its fire rating to '90 min'.","completion":"string newTypeName = \"FR-90 Door\";\nif (new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().Any(t => t.Name == newTypeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Door type '{newTypeName}' already exists.\");\n}\nelse\n{\n    FamilySymbol doorTypeToDuplicate = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\n    if (doorTypeToDuplicate != null)\n    {\n        FamilySymbol newDoorType = doorTypeToDuplicate.Duplicate(newTypeName) as FamilySymbol;\n        Parameter fireRatingParam = newDoorType.get_Parameter(BuiltInParameter.FIRE_RATING);\n        if (fireRatingParam != null && !fireRatingParam.IsReadOnly) fireRatingParam.Set(\"90 min\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No door types found to duplicate.\");\n    }\n}"}
{"prompt":"Encuentra todos los muros que no tienen nivel base asignado.","completion":"ElementFilter unassociatedFilter = new ElementLevelFilter(ElementId.InvalidElementId);\nList<Element> unassignedWalls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WherePasses(unassociatedFilter).ToList();\nTaskDialog.Show(\"Muros sin Nivel\", $\"Se encontraron {unassignedWalls.Count} muros sin nivel base.\");\nif (unassignedWalls.Any()) new UIDocument(doc).Selection.SetElementIds(unassignedWalls.Select(e => e.Id).ToList());"}
{"prompt":"Find all walls that have no base level assigned.","completion":"ElementFilter unassociatedFilter = new ElementLevelFilter(ElementId.InvalidElementId);\nList<Element> unassignedWalls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WherePasses(unassociatedFilter).ToList();\nTaskDialog.Show(\"Unassigned Walls\", $\"Found {unassignedWalls.Count} walls with no base level.\");\nif (unassignedWalls.Any()) new UIDocument(doc).Selection.SetElementIds(unassignedWalls.Select(e => e.Id).ToList());"}
{"prompt":"Establece la visibilidad de la categoría 'Mobiliario' en falso en la vista activa.","completion":"Category furnitureCat = doc.Settings.Categories.get_Item(BuiltInCategory.OST_Furniture);\nif(furnitureCat != null && furnitureCat.get_AllowsVisibilityControl(doc.ActiveView))\n{\n    doc.ActiveView.SetCategoryHidden(furnitureCat.Id, true);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se pudo cambiar la visibilidad de la categoría 'Mobiliario'.\");\n}"}
{"prompt":"Set the visibility of the 'Furniture' category to false in the active view.","completion":"Category furnitureCat = doc.Settings.Categories.get_Item(BuiltInCategory.OST_Furniture);\nif(furnitureCat != null && furnitureCat.get_AllowsVisibilityControl(doc.ActiveView))\n{\n    doc.ActiveView.SetCategoryHidden(furnitureCat.Id, true);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Could not change the visibility of the 'Furniture' category.\");\n}"}
{"prompt":"Elimina todos los tipos de muro no utilizados en el proyecto.","completion":"ICollection<ElementId> allWallTypes = new FilteredElementCollector(doc).OfClass(typeof(WallType)).ToElementIds();\nICollection<ElementId> usedWallTypes = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WhereElementIsNotElementType().Select(w => w.GetTypeId()).Distinct().ToList();\nList<ElementId> unusedWallTypes = allWallTypes.Except(usedWallTypes).ToList();\nif(unusedWallTypes.Any())\n{\n    int count = unusedWallTypes.Count;\n    doc.Delete(unusedWallTypes);\n    TaskDialog.Show(\"Éxito\", $\"Se eliminaron {count} tipos de muro no utilizados.\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No se encontraron tipos de muro no utilizados.\");\n}"}
{"prompt":"Delete all unused wall types in the project.","completion":"ICollection<ElementId> allWallTypes = new FilteredElementCollector(doc).OfClass(typeof(WallType)).ToElementIds();\nICollection<ElementId> usedWallTypes = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WhereElementIsNotElementType().Select(w => w.GetTypeId()).Distinct().ToList();\nList<ElementId> unusedWallTypes = allWallTypes.Except(usedWallTypes).ToList();\nif(unusedWallTypes.Any())\n{\n    int count = unusedWallTypes.Count;\n    doc.Delete(unusedWallTypes);\n    TaskDialog.Show(\"Success\", $\"Deleted {count} unused wall types.\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No unused wall types were found.\");\n}"}
{"prompt":"Crea 10 worksets de arquitectura.","completion":"if(doc.IsWorkshared)\n{\n    List<string> worksetNames = new List<string> { \"TAD_ARQ_MAM\", \"TAD_ARQ_ACA\", \"TAD_ARQ_PLA\", \"TAD_ARQ_PSO\", \"TAD_ARQ_HRE\", \"TAD_ARQ_ALU\", \"TAD_ARQ_CAR\", \"TAD_ARQ_MOB\", \"TAD_ARQ_PLO\", \"TAD_ARQ_EXT\" };\n    int createdCount = 0;\n    foreach(string name in worksetNames)\n    {\n        if(WorksetTable.IsWorksetNameUnique(doc, name))\n        {\n            Workset.Create(doc, name);\n            createdCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{createdCount} worksets nuevos han sido creados.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Esta acción requiere un modelo compartido (Workshared).\");\n}"}
{"prompt":"Create 10 architectural worksets.","completion":"if(doc.IsWorkshared)\n{\n    List<string> worksetNames = new List<string> { \"TAD_ARQ_WALLS\", \"TAD_ARQ_FINISHES\", \"TAD_ARQ_CEILINGS\", \"TAD_ARQ_FLOORS\", \"TAD_ARQ_RAILINGS\", \"TAD_ARQ_WINDOWS\", \"TAD_ARQ_CARPENTRY\", \"TAD_ARQ_FURNITURE\", \"TAD_ARQ_PLUMBING\", \"TAD_ARQ_EXTERIOR\" };\n    int createdCount = 0;\n    foreach(string name in worksetNames)\n    {\n        if(WorksetTable.IsWorksetNameUnique(doc, name))\n        {\n            Workset.Create(doc, name);\n            createdCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{createdCount} new worksets were created.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"This action requires a workshared model.\");\n}"}
{"prompt":"Genera un reporte con el área de todas las habitaciones del proyecto.","completion":"StringBuilder report = new StringBuilder(\"Reporte de Áreas de Habitaciones:\\n\");\nList<Room> rooms = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).WhereElementIsNotElementType().Cast<Room>().ToList();\nforeach(Room room in rooms)\n{\n    double area = room.get_Parameter(BuiltInParameter.ROOM_AREA).AsDouble();\n    report.AppendLine($\"- {room.Name} ({room.Number}): {UnitUtils.ConvertFromInternalUnits(area, UnitTypeId.SquareMeters):F2} m²\");\n}\nTaskDialog.Show(\"Reporte de Áreas\", report.ToString());"}
{"prompt":"Generate a report with the area of all rooms in the project.","completion":"StringBuilder report = new StringBuilder(\"Room Area Report:\\n\");\nList<Room> rooms = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).WhereElementIsNotElementType().Cast<Room>().ToList();\nforeach(Room room in rooms)\n{\n    double area = room.get_Parameter(BuiltInParameter.ROOM_AREA).AsDouble();\n    report.AppendLine($\"- {room.Name} ({room.Number}): {UnitUtils.ConvertFromInternalUnits(area, UnitTypeId.SquareMeters):F2} m²\");\n}\nTaskDialog.Show(\"Area Report\", report.ToString());"}
{"prompt":"Crea un muro en Nivel 1 de (0,0,0) a (5,0,0) con 5m de alto.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nif (level1 != null)\n{\n    WallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\n    if(wallType != null)\n    {\n        Line wallCurve = Line.CreateBound(new XYZ(0, 0, 0), new XYZ(UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0, 0));\n        double height = UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters);\n        Wall.Create(doc, wallCurve, wallType.Id, level1.Id, height, 0.0, false, false);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontraron tipos de muro en el proyecto.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el 'Nivel 1'.\");\n}"}
{"prompt":"Crea un nuevo parámetro de proyecto compartido de texto llamado 'Notas Adicionales' para muros y puertas.","completion":"string paramName = \"Notas Adicionales\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ParameterElement)).Any(p => p.Name == paramName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El parámetro '{paramName}' ya existe.\");\n}\nelse\n{\n    DefinitionFile defFile = doc.Application.OpenSharedParameterFile();\n    if (defFile == null || !System.IO.File.Exists(defFile.Filename))\n    {\n        TaskDialog.Show(\"Error\", \"Se necesita un archivo de parámetros compartidos configurado en Revit.\");\n    }\n    else\n    {\n        DefinitionGroup group = defFile.Groups.get_Item(\"General\") ?? defFile.Groups.Create(\"General\");\n        Definition definition = group.Definitions.get_Item(paramName) ?? group.Definitions.Create(new ExternalDefinitionCreationOptions(paramName, SpecTypeId.String.Text));\n        CategorySet categories = doc.Application.Create.NewCategorySet();\n        categories.Insert(doc.Settings.Categories.get_Item(BuiltInCategory.OST_Walls));\n        categories.Insert(doc.Settings.Categories.get_Item(BuiltInCategory.OST_Doors));\n        doc.ParameterBindings.Insert(doc.Application.Create.NewInstanceBinding(categories), (ExternalDefinition)definition, BuiltInParameterGroup.PG_DATA);\n        TaskDialog.Show(\"Éxito\", $\"Parámetro '{paramName}' creado y asignado a Muros y Puertas.\");\n    }\n}"}
{"prompt":"Create a new shared text project parameter named 'Additional Notes' for walls and doors.","completion":"string paramName = \"Additional Notes\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ParameterElement)).Any(p => p.Name == paramName))\n{\n    TaskDialog.Show(\"Warning\", $\"Parameter '{paramName}' already exists.\");\n}\nelse\n{\n    DefinitionFile defFile = doc.Application.OpenSharedParameterFile();\n    if (defFile == null || !System.IO.File.Exists(defFile.Filename))\n    {\n        TaskDialog.Show(\"Error\", \"A shared parameter file needs to be configured in Revit.\");\n    }\n    else\n    {\n        DefinitionGroup group = defFile.Groups.get_Item(\"General\") ?? defFile.Groups.Create(\"General\");\n        Definition definition = group.Definitions.get_Item(paramName) ?? group.Definitions.Create(new ExternalDefinitionCreationOptions(paramName, SpecTypeId.String.Text));\n        CategorySet categories = doc.Application.Create.NewCategorySet();\n        categories.Insert(doc.Settings.Categories.get_Item(BuiltInCategory.OST_Walls));\n        categories.Insert(doc.Settings.Categories.get_Item(BuiltInCategory.OST_Doors));\n        doc.ParameterBindings.Insert(doc.Application.Create.NewInstanceBinding(categories), (ExternalDefinition)definition, BuiltInParameterGroup.PG_DATA);\n        TaskDialog.Show(\"Success\", $\"Parameter '{paramName}' created and assigned to Walls and Doors.\");\n    }\n}"}
{"prompt":"Crea un nuevo tipo de muro 'Muro Genérico 300mm' con un grosor de 30cm.","completion":"string newTypeName = \"Muro Genérico 300mm\";\nif (new FilteredElementCollector(doc).OfClass(typeof(WallType)).Any(wt => wt.Name == newTypeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de muro '{newTypeName}' ya existe.\");\n}\nelse\n{\n    WallType oldWallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\n    if(oldWallType != null)\n    {\n        WallType newWallType = oldWallType.Duplicate(newTypeName) as WallType;\n        CompoundStructure cs = newWallType.GetCompoundStructure();\n        if(cs != null && cs.GetLayerCount() > 0) \n        {\n            cs.SetLayerWidth(cs.GetFirstCoreLayerIndex(), UnitUtils.ConvertToInternalUnits(300, UnitTypeId.Millimeters));\n            newWallType.SetCompoundStructure(cs);\n            TaskDialog.Show(\"Éxito\", $\"Tipo de muro '{newTypeName}' creado.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró un tipo de muro para duplicar.\");\n    }\n}"}
{"prompt":"Create a new wall type 'Generic Wall 300mm' with a thickness of 30cm.","completion":"string newTypeName = \"Generic Wall 300mm\";\nif (new FilteredElementCollector(doc).OfClass(typeof(WallType)).Any(wt => wt.Name == newTypeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Wall type '{newTypeName}' already exists.\");\n}\nelse\n{\n    WallType oldWallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\n    if(oldWallType != null)\n    {\n        WallType newWallType = oldWallType.Duplicate(newTypeName) as WallType;\n        CompoundStructure cs = newWallType.GetCompoundStructure();\n        if(cs != null && cs.GetLayerCount() > 0) \n        {\n            cs.SetLayerWidth(cs.GetFirstCoreLayerIndex(), UnitUtils.ConvertToInternalUnits(300, UnitTypeId.Millimeters));\n            newWallType.SetCompoundStructure(cs);\n            TaskDialog.Show(\"Success\", $\"Wall type '{newTypeName}' created.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No wall type found to duplicate.\");\n    }\n}"}
{"prompt":"Cambia el tipo de todos los muros seleccionados a 'Muro Exterior'.","completion":"UIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(selectedIds.Any())\n{\n    WallType targetWallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).Cast<WallType>().FirstOrDefault(wt => wt.Name == \"Muro Exterior\");\n    if(targetWallType != null)\n    {\n        int updatedCount = 0;\n        foreach(ElementId id in selectedIds)\n        {\n            Wall wall = doc.GetElement(id) as Wall;\n            if(wall != null) \n            {\n                wall.ChangeTypeId(targetWallType.Id);\n                updatedCount++;\n            }\n        }\n        TaskDialog.Show(\"Resultado\", $\"{updatedCount} muros cambiados al tipo '{targetWallType.Name}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró el tipo de muro 'Muro Exterior'.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No había elementos seleccionados.\");\n}"}
{"prompt":"Crea un muro del tipo 'Genérico - 200mm' en el 'Nivel 1' desde (0,0) hasta (10,5).","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nWallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault(wt => wt.Name == \"Genérico - 200mm\") as WallType;\nif (level != null && wallType != null)\n{\n    XYZ startPoint = new XYZ(UnitUtils.ConvertToInternalUnits(0, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(0, UnitTypeId.Meters), 0);\n    XYZ endPoint = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0);\n    Line wallCurve = Line.CreateBound(startPoint, endPoint);\n    double height = UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters);\n    Wall.Create(doc, wallCurve, wallType.Id, level.Id, height, 0, false, false);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el nivel 'Nivel 1' o el tipo de muro 'Genérico - 200mm'.\");\n}"}
{"prompt":"Create a 'Generic - 200mm' wall on 'Level 1' from (0,0) to (10,5).","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nWallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault(wt => wt.Name == \"Generic - 200mm\") as WallType;\nif (level != null && wallType != null)\n{\n    XYZ startPoint = new XYZ(UnitUtils.ConvertToInternalUnits(0, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(0, UnitTypeId.Meters), 0);\n    XYZ endPoint = new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(5, UnitTypeId.Meters), 0);\n    Line wallCurve = Line.CreateBound(startPoint, endPoint);\n    double height = UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters);\n    Wall.Create(doc, wallCurve, wallType.Id, level.Id, height, 0, false, false);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Could not find Level 'Level 1' or Wall Type 'Generic - 200mm'.\");\n}"}
{"prompt":"Crea un nuevo nivel llamado 'Planta Sótano' a una elevación de -4.5 metros.","completion":"string levelName = \"Planta Sótano\";\nif (new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == levelName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El nivel '{levelName}' ya existe.\");\n}\nelse\n{\n    double elevationInternal = UnitUtils.ConvertToInternalUnits(-4.5, UnitTypeId.Meters);\n    Level newLevel = Level.Create(doc, elevationInternal);\n    newLevel.Name = levelName;\n    TaskDialog.Show(\"Éxito\", $\"Nivel '{levelName}' creado a -4.5m.\");\n}"}
{"prompt":"Create a new level named 'Basement Floor' at an elevation of -4.5 meters.","completion":"string levelName = \"Basement Floor\";\nif (new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == levelName))\n{\n    TaskDialog.Show(\"Warning\", $\"A level named '{levelName}' already exists.\");\n}\nelse\n{\n    double elevationInternal = UnitUtils.ConvertToInternalUnits(-4.5, UnitTypeId.Meters);\n    Level newLevel = Level.Create(doc, elevationInternal);\n    newLevel.Name = levelName;\n    TaskDialog.Show(\"Success\", $\"Level '{levelName}' created at -4.5m.\");\n}"}
{"prompt":"Coloca una instancia de la familia 'Mesa de Oficina' en el centro de la habitación 'Despacho 101'.","completion":"Room room = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).FirstOrDefault(r => r.Name == \"Despacho 101\") as Room;\nFamilySymbol furnitureSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Furniture).WhereElementIsElementType().FirstOrDefault(s => s.Name == \"Mesa de Oficina\") as FamilySymbol;\nif (room != null && furnitureSymbol != null)\n{\n    LocationPoint roomCenter = room.Location as LocationPoint;\n    if(roomCenter != null)\n    {\n        if(!furnitureSymbol.IsActive) furnitureSymbol.Activate();\n        doc.Create.NewFamilyInstance(roomCenter.Point, furnitureSymbol, room.Level, StructuralType.NonStructural);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"La habitación 'Despacho 101' no tiene un punto de ubicación válido.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró la habitación 'Despacho 101' o la familia 'Mesa de Oficina'.\");\n}"}
{"prompt":"Place an instance of the 'Office Desk' family in the center of the 'Office 101' room.","completion":"Room room = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).FirstOrDefault(r => r.Name == \"Office 101\") as Room;\nFamilySymbol furnitureSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Furniture).WhereElementIsElementType().FirstOrDefault(s => s.Name == \"Office Desk\") as FamilySymbol;\nif (room != null && furnitureSymbol != null)\n{\n    LocationPoint roomCenter = room.Location as LocationPoint;\n    if(roomCenter != null)\n    {\n        if(!furnitureSymbol.IsActive) furnitureSymbol.Activate();\n        doc.Create.NewFamilyInstance(roomCenter.Point, furnitureSymbol, room.Level, StructuralType.NonStructural);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Room 'Office 101' does not have a valid location point.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Could not find room 'Office 101' or family 'Office Desk'.\");\n}"}
{"prompt":"Crea una rejilla de 5 ejes horizontales y 5 verticales, espaciados 6 metros.","completion":"double spacing = UnitUtils.ConvertToInternalUnits(6, UnitTypeId.Meters);\nint count = 5;\nfor (int i = 0; i < count; i++)\n{\n    Line line = Line.CreateBound(new XYZ(0, i * spacing, 0), new XYZ((count - 1) * spacing, i * spacing, 0));\n    Grid.Create(doc, line);\n}\nfor (int i = 0; i < count; i++)\n{\n    Line line = Line.CreateBound(new XYZ(i * spacing, 0, 0), new XYZ(i * spacing, (count - 1) * spacing, 0));\n    Grid.Create(doc, line);\n}\nTaskDialog.Show(\"Éxito\", $\"Se ha creado una rejilla de {count}x{count} ejes.\");"}
{"prompt":"Create a grid of 5 horizontal and 5 vertical grids, spaced 6 meters apart.","completion":"double spacing = UnitUtils.ConvertToInternalUnits(6, UnitTypeId.Meters);\nint count = 5;\nfor (int i = 0; i < count; i++)\n{\n    Line line = Line.CreateBound(new XYZ(0, i * spacing, 0), new XYZ((count - 1) * spacing, i * spacing, 0));\n    Grid.Create(doc, line);\n}\nfor (int i = 0; i < count; i++)\n{\n    Line line = Line.CreateBound(new XYZ(i * spacing, 0, 0), new XYZ(i * spacing, (count - 1) * spacing, 0));\n    Grid.Create(doc, line);\n}\nTaskDialog.Show(\"Success\", $\"A {count}x{count} grid has been created.\");"}
{"prompt":"Crea un pilar del tipo 'Hormigón-Rectangular 30x60' en cada intersección de la rejilla.","completion":"FamilySymbol columnSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().FirstOrDefault(s => s.Name == \"Hormigón-Rectangular 30x60\") as FamilySymbol;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.IsGroundPlane) as Level;\nList<Grid> grids = new FilteredElementCollector(doc).OfClass(typeof(Grid)).Cast<Grid>().ToList();\nif (columnSymbol != null && level != null && grids.Count > 1)\n{\n    if (!columnSymbol.IsActive) columnSymbol.Activate();\n    int createdCount = 0;\n    for (int i = 0; i < grids.Count; i++)\n    {\n        for (int j = i + 1; j < grids.Count; j++)\n        {\n            var result = grids[i].Curve.Intersect(grids[j].Curve, out IntersectionResultArray results);\n            if (result == SetComparisonResult.Overlap && results != null)\n            {\n                foreach (IntersectionResult ir in results)\n                {\n                    doc.Create.NewFamilyInstance(ir.XYZPoint, columnSymbol, level, StructuralType.Column);\n                    createdCount++;\n                }\n            }\n        }\n    }\n    TaskDialog.Show(\"Éxito\", $\"Se crearon {createdCount} pilares en las intersecciones.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Faltan elementos: Tipo de pilar 'Hormigón-Rectangular 30x60', nivel base o suficientes ejes.\");\n}"}
{"prompt":"Create a 'Concrete-Rectangular 30x60' column at each grid intersection.","completion":"FamilySymbol columnSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().FirstOrDefault(s => s.Name == \"Concrete-Rectangular 30x60\") as FamilySymbol;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.IsGroundPlane) as Level;\nList<Grid> grids = new FilteredElementCollector(doc).OfClass(typeof(Grid)).Cast<Grid>().ToList();\nif (columnSymbol != null && level != null && grids.Count > 1)\n{\n    if (!columnSymbol.IsActive) columnSymbol.Activate();\n    int createdCount = 0;\n    for (int i = 0; i < grids.Count; i++)\n    {\n        for (int j = i + 1; j < grids.Count; j++)\n        {\n            var result = grids[i].Curve.Intersect(grids[j].Curve, out IntersectionResultArray results);\n            if (result == SetComparisonResult.Overlap && results != null)\n            {\n                foreach (IntersectionResult ir in results)\n                {\n                    doc.Create.NewFamilyInstance(ir.XYZPoint, columnSymbol, level, StructuralType.Column);\n                    createdCount++;\n                }\n            }\n        }\n    }\n    TaskDialog.Show(\"Success\", $\"{createdCount} columns were created at the intersections.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Missing elements: 'Concrete-Rectangular 30x60' column type, base level, or not enough grids.\");\n}"}
{"prompt":"Duplica el tipo de muro 'Genérico - 150mm' y nómbralo 'Interior - 15cm Yeso'.","completion":"string originalName = \"Genérico - 150mm\";\nstring newName = \"Interior - 15cm Yeso\";\nif (new FilteredElementCollector(doc).OfClass(typeof(WallType)).Any(wt => wt.Name == newName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de muro '{newName}' ya existe.\");\n}\nelse\n{\n    WallType originalType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault(wt => wt.Name == originalName) as WallType;\n    if(originalType != null)\n    {\n        WallType newType = originalType.Duplicate(newName) as WallType;\n        TaskDialog.Show(\"Éxito\", $\"Tipo de muro '{originalName}' duplicado como '{newName}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", $\"No se encontró el tipo de muro '{originalName}'.\");\n    }\n}"}
{"prompt":"Duplicate the 'Generic - 150mm' wall type and name it 'Interior - 15cm Plaster'.","completion":"string originalName = \"Generic - 150mm\";\nstring newName = \"Interior - 15cm Plaster\";\nif (new FilteredElementCollector(doc).OfClass(typeof(WallType)).Any(wt => wt.Name == newName))\n{\n    TaskDialog.Show(\"Warning\", $\"Wall type '{newName}' already exists.\");\n}\nelse\n{\n    WallType originalType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault(wt => wt.Name == originalName) as WallType;\n    if(originalType != null)\n    {\n        WallType newType = originalType.Duplicate(newName) as WallType;\n        TaskDialog.Show(\"Success\", $\"Wall type '{originalName}' duplicated as '{newName}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", $\"Wall type '{originalName}' not found.\");\n    }\n}"}
{"prompt":"Crea un tipo de muro 'Muro-Doble' de 30cm y luego crea un muro de ese tipo.","completion":"string newTypeName = \"Muro-Doble\";\nWallType newWallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault(wt => wt.Name == newTypeName) as WallType;\nif (newWallType == null)\n{\n    WallType wallTypeToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\n    if (wallTypeToDuplicate != null)\n    {\n        newWallType = wallTypeToDuplicate.Duplicate(newTypeName) as WallType;\n        CompoundStructure cs = newWallType.GetCompoundStructure();\n        if(cs != null && cs.GetLayerCount() > 0) \n        {\n            cs.SetLayerWidth(cs.GetFirstCoreLayerIndex(), UnitUtils.ConvertToInternalUnits(0.3, UnitTypeId.Meters));\n            newWallType.SetCompoundStructure(cs);\n        }\n    }\n}\nif(newWallType != null)\n{\n    Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\n    if(level != null)\n    {\n        Line wallCurve = Line.CreateBound(XYZ.Zero, new XYZ(10,0,0));\n        Wall.Create(doc, wallCurve, newWallType.Id, level.Id, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0, false, false);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se pudo crear o encontrar el tipo de muro '{newTypeName}'.\");\n}"}
{"prompt":"Create a 30cm 'Double-Wall' type and then create a wall of that type.","completion":"string newTypeName = \"Double-Wall\";\nWallType newWallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault(wt => wt.Name == newTypeName) as WallType;\nif (newWallType == null)\n{\n    WallType wallTypeToDuplicate = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\n    if (wallTypeToDuplicate != null)\n    {\n        newWallType = wallTypeToDuplicate.Duplicate(newTypeName) as WallType;\n        CompoundStructure cs = newWallType.GetCompoundStructure();\n        if(cs != null && cs.GetLayerCount() > 0) \n        {\n            cs.SetLayerWidth(cs.GetFirstCoreLayerIndex(), UnitUtils.ConvertToInternalUnits(0.3, UnitTypeId.Meters));\n            newWallType.SetCompoundStructure(cs);\n        }\n    }\n}\nif(newWallType != null)\n{\n    Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\n    if(level != null)\n    {\n        Line wallCurve = Line.CreateBound(XYZ.Zero, new XYZ(10,0,0));\n        Wall.Create(doc, wallCurve, newWallType.Id, level.Id, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0, false, false);\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Could not create or find wall type '{newTypeName}'.\");\n}"}
{"prompt":"Selecciona todos los muros del 'Nivel 2' y cambia su comentario a 'REVISAR AISLAMIENTO'.","completion":"Level level2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 2\") as Level;\nif(level2 != null)\n{\n    List<Wall> wallsOnLevel2 = new FilteredElementCollector(doc).OfClass(typeof(Wall)).Where(w => w.LevelId == level2.Id).Cast<Wall>().ToList();\n    foreach(Wall wall in wallsOnLevel2)\n    {\n        Parameter commentsParam = wall.get_Parameter(BuiltInParameter.ALL_MODEL_INSTANCE_COMMENTS);\n        if(commentsParam != null) commentsParam.Set(\"REVISAR AISLAMIENTO\");\n    }\n    TaskDialog.Show(\"Resultado\", $\"{wallsOnLevel2.Count} muros en '{level2.Name}' actualizados.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el 'Nivel 2'.\");\n}"}
{"prompt":"Select all walls on 'Level 2' and change their comment to 'REVIEW INSULATION'.","completion":"Level level2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 2\") as Level;\nif(level2 != null)\n{\n    List<Wall> wallsOnLevel2 = new FilteredElementCollector(doc).OfClass(typeof(Wall)).Where(w => w.LevelId == level2.Id).Cast<Wall>().ToList();\n    foreach(Wall wall in wallsOnLevel2)\n    {\n        Parameter commentsParam = wall.get_Parameter(BuiltInParameter.ALL_MODEL_INSTANCE_COMMENTS);\n        if(commentsParam != null) commentsParam.Set(\"REVIEW INSULATION\");\n    }\n    TaskDialog.Show(\"Result\", $\"{wallsOnLevel2.Count} walls on '{level2.Name}' were updated.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Level 2' not found.\");\n}"}
{"prompt":"Crea un parámetro de proyecto de tipo URL llamado 'Enlace a Especificaciones'.","completion":"string paramName = \"Enlace a Especificaciones\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ParameterElement)).Any(p => p.Name == paramName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El parámetro '{paramName}' ya existe.\");\n}\nelse\n{\n    DefinitionFile defFile = doc.Application.OpenSharedParameterFile();\n    if (defFile == null || !System.IO.File.Exists(defFile.Filename))\n    {\n        TaskDialog.Show(\"Error\", \"Se necesita un archivo de parámetros compartidos configurado en Revit.\");\n    }\n    else\n    {\n        DefinitionGroup group = defFile.Groups.get_Item(\"Documentation\") ?? defFile.Groups.Create(\"Documentation\");\n        Definition definition = group.Definitions.get_Item(paramName) ?? group.Definitions.Create(new ExternalDefinitionCreationOptions(paramName, SpecTypeId.Url));\n        CategorySet categories = doc.Application.Create.NewCategorySet();\n        categories.Insert(doc.Settings.Categories.get_Item(BuiltInCategory.OST_Walls));\n        doc.ParameterBindings.Insert(doc.Application.Create.NewInstanceBinding(categories), (ExternalDefinition)definition, BuiltInParameterGroup.PG_DATA);\n        TaskDialog.Show(\"Éxito\", $\"Parámetro '{paramName}' creado y asignado a la categoría Muros.\");\n    }\n}"}
{"prompt":"Create a URL type project parameter named 'Link to Specifications'.","completion":"string paramName = \"Link to Specifications\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ParameterElement)).Any(p => p.Name == paramName))\n{\n    TaskDialog.Show(\"Warning\", $\"Parameter '{paramName}' already exists.\");\n}\nelse\n{\n    DefinitionFile defFile = doc.Application.OpenSharedParameterFile();\n    if (defFile == null || !System.IO.File.Exists(defFile.Filename))\n    {\n        TaskDialog.Show(\"Error\", \"A shared parameter file needs to be configured in Revit.\");\n    }\n    else\n    {\n        DefinitionGroup group = defFile.Groups.get_Item(\"Documentation\") ?? defFile.Groups.Create(\"Documentation\");\n        Definition definition = group.Definitions.get_Item(paramName) ?? group.Definitions.Create(new ExternalDefinitionCreationOptions(paramName, SpecTypeId.Url));\n        CategorySet categories = doc.Application.Create.NewCategorySet();\n        categories.Insert(doc.Settings.Categories.get_Item(BuiltInCategory.OST_Walls));\n        doc.ParameterBindings.Insert(doc.Application.Create.NewInstanceBinding(categories), (ExternalDefinition)definition, BuiltInParameterGroup.PG_DATA);\n        TaskDialog.Show(\"Success\", $\"Parameter '{paramName}' created and assigned to the Walls category.\");\n    }\n}"}
{"prompt":"Crea una nueva vista de alzado mirando al sur.","completion":"string viewName = \"Alzado Sur (Nuevo)\";\nif (new FilteredElementCollector(doc).OfClass(typeof(View)).Any(v => v.Name == viewName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"La vista '{viewName}' ya existe.\");\n}\nelse\n{\n    ViewFamilyType elevationVFT = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(vft => vft.ViewFamily == ViewFamily.Elevation);\n    if(elevationVFT != null)\n    {\n        ElevationMarker marker = ElevationMarker.CreateElevationMarker(doc, elevationVFT.Id, new XYZ(0, -20, 0), 100);\n        View aev = marker.CreateElevation(doc, doc.ActiveView.Id, 0); // Índice 0 es Sur\n        aev.Name = viewName;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró el tipo de familia de vista de alzado.\");\n    }\n}"}
{"prompt":"Create a new elevation view looking south.","completion":"string viewName = \"South Elevation (New)\";\nif (new FilteredElementCollector(doc).OfClass(typeof(View)).Any(v => v.Name == viewName))\n{\n    TaskDialog.Show(\"Warning\", $\"View '{viewName}' already exists.\");\n}\nelse\n{\n    ViewFamilyType elevationVFT = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(vft => vft.ViewFamily == ViewFamily.Elevation);\n    if(elevationVFT != null)\n    {\n        ElevationMarker marker = ElevationMarker.CreateElevationMarker(doc, elevationVFT.Id, new XYZ(0, -20, 0), 100);\n        View aev = marker.CreateElevation(doc, doc.ActiveView.Id, 0); // Index 0 is South\n        aev.Name = viewName;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Elevation View Family Type not found.\");\n    }\n}"}
{"prompt":"Cambia el tipo de una losa por uno que contenga 'Concreto'.","completion":"Floor floorToChange = new FilteredElementCollector(doc).OfClass(typeof(Floor)).FirstOrDefault() as Floor;\nFloorType newType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Cast<FloorType>().FirstOrDefault(ft => ft.Name.Contains(\"Concreto\") || ft.Name.Contains(\"Concrete\"));\nif(floorToChange != null && newType != null)\n{\n    floorToChange.ChangeTypeId(newType.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró una losa para cambiar o un tipo de losa de concreto.\");\n}"}
{"prompt":"Change the type of a floor to one that contains 'Concrete'.","completion":"Floor floorToChange = new FilteredElementCollector(doc).OfClass(typeof(Floor)).FirstOrDefault() as Floor;\nFloorType newType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Cast<FloorType>().FirstOrDefault(ft => ft.Name.Contains(\"Concrete\"));\nif(floorToChange != null && newType != null)\n{\n    floorToChange.ChangeTypeId(newType.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Could not find a floor to change or a concrete floor type.\");\n}"}
{"prompt":"Añade montantes a todas las líneas de rejilla de un muro cortina seleccionado.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un muro cortina\");\nif (pickedRef != null)\n{\n    Wall curtainWall = doc.GetElement(pickedRef) as Wall;\n    if (curtainWall != null && curtainWall.CurtainGrid != null)\n    {\n        MullionType mullionType = new FilteredElementCollector(doc).OfClass(typeof(MullionType)).FirstOrDefault() as MullionType;\n        if (mullionType != null)\n        {\n            CurtainGrid grid = curtainWall.CurtainGrid;\n            foreach (ElementId gridLineId in grid.GetVGridLineIds()) \n            {\n                CurtainGridLine line = doc.GetElement(gridLineId) as CurtainGridLine;\n                if(line != null && !line.MullionOnLine) line.AddMullions(mullionType, false);\n            }\n            foreach (ElementId gridLineId in grid.GetUGridLineIds()) \n            {\n                CurtainGridLine line = doc.GetElement(gridLineId) as CurtainGridLine;\n                if(line != null && !line.MullionOnLine) line.AddMullions(mullionType, false);\n            }\n        }\n        else\n        {\n            TaskDialog.Show(\"Error\", \"No se encontraron tipos de montante en el proyecto.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no es un muro cortina.\");\n    }\n}"}
{"prompt":"Add mullions to all grid lines of a selected curtain wall.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a curtain wall\");\nif (pickedRef != null)\n{\n    Wall curtainWall = doc.GetElement(pickedRef) as Wall;\n    if (curtainWall != null && curtainWall.CurtainGrid != null)\n    {\n        MullionType mullionType = new FilteredElementCollector(doc).OfClass(typeof(MullionType)).FirstOrDefault() as MullionType;\n        if (mullionType != null)\n        {\n            CurtainGrid grid = curtainWall.CurtainGrid;\n            foreach (ElementId gridLineId in grid.GetVGridLineIds()) \n            {\n                CurtainGridLine line = doc.GetElement(gridLineId) as CurtainGridLine;\n                if(line != null && !line.MullionOnLine) line.AddMullions(mullionType, false);\n            }\n            foreach (ElementId gridLineId in grid.GetUGridLineIds()) \n            {\n                CurtainGridLine line = doc.GetElement(gridLineId) as CurtainGridLine;\n                if(line != null && !line.MullionOnLine) line.AddMullions(mullionType, false);\n            }\n        }\n        else\n        {\n            TaskDialog.Show(\"Error\", \"No mullion types were found in the project.\");\n        }\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element is not a curtain wall.\");\n    }\n}"}
{"prompt":"Rota un elemento seleccionado 90 grados sobre su eje Z.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona un elemento para rotar\");\nif (pickedRef != null)\n{\n    Element elem = doc.GetElement(pickedRef.ElementId);\n    LocationPoint lp = elem.Location as LocationPoint;\n    if (lp != null)\n    {\n        Line axis = Line.CreateBound(lp.Point, lp.Point + XYZ.BasisZ);\n        ElementTransformUtils.RotateElement(doc, elem.Id, axis, Math.PI / 2.0);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no tiene un punto de ubicación para rotar (ej. un muro).\");\n    }\n}"}
{"prompt":"Rotate a selected element 90 degrees around its Z-axis.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select an element to rotate\");\nif (pickedRef != null)\n{\n    Element elem = doc.GetElement(pickedRef.ElementId);\n    LocationPoint lp = elem.Location as LocationPoint;\n    if (lp != null)\n    {\n        Line axis = Line.CreateBound(lp.Point, lp.Point + XYZ.BasisZ);\n        ElementTransformUtils.RotateElement(doc, elem.Id, axis, Math.PI / 2.0);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element does not have a location point to rotate around (e.g. a wall).\");\n    }\n}"}
{"prompt":"Crea un sistema de vigas en un forjado seleccionado.","completion":"TaskDialog.Show(\"Acción en Múltiples Pasos\", \"La creación de un sistema de vigas requiere un contorno. Por favor, dibuja o selecciona las líneas que definen el contorno del sistema de vigas y luego pide 'Crear sistema de vigas a partir de la selección'.\");"}
{"prompt":"Create a beam system on a selected floor slab.","completion":"TaskDialog.Show(\"Multi-Step Action\", \"Creating a beam system requires a boundary. Please draw or select the lines that define the beam system boundary, and then ask 'Create beam system from selection'.\");"}
{"prompt":"Exporta una lista de todas las advertencias del proyecto a un archivo de texto en el escritorio.","completion":"string desktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);\nstring filePath = System.IO.Path.Combine(desktopPath, \"RevitWarnings.txt\");\nIList<FailureMessage> warnings = doc.GetWarnings();\nif (warnings.Any())\n{\n    List<string> warningDescriptions = warnings.Select(w => w.GetDescriptionText()).ToList();\n    System.IO.File.WriteAllLines(filePath, warningDescriptions);\n    TaskDialog.Show(\"Exportación Completa\", $\"{warnings.Count} advertencias exportadas a: {filePath}\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"El proyecto no tiene advertencias.\");\n}"}
{"prompt":"Export a list of all project warnings to a text file on the desktop.","completion":"string desktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);\nstring filePath = System.IO.Path.Combine(desktopPath, \"RevitWarnings.txt\");\nIList<FailureMessage> warnings = doc.GetWarnings();\nif (warnings.Any())\n{\n    List<string> warningDescriptions = warnings.Select(w => w.GetDescriptionText()).ToList();\n    System.IO.File.WriteAllLines(filePath, warningDescriptions);\n    TaskDialog.Show(\"Export Complete\", $\"{warnings.Count} warnings exported to: {filePath}\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"The project has no warnings.\");\n}"}
{"prompt":"Localiza todos los muros con un parámetro 'Marca' vacío y asigna 'WM-01'.","completion":"List<Wall> walls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().Cast<Wall>().ToList();\nint updatedCount = 0;\nforeach(var w in walls)\n{\n  Parameter p = w.get_Parameter(BuiltInParameter.ALL_MODEL_MARK);\n  if(p != null && !p.IsReadOnly && string.IsNullOrEmpty(p.AsString()))\n  {\n      p.Set(\"WM-01\");\n      updatedCount++;\n  }\n}\nTaskDialog.Show(\"Resultado\", $\"{updatedCount} muros con marca vacía han sido actualizados a 'WM-01'.\");"}
{"prompt":"Find all walls with an empty 'Mark' parameter and set it to 'WM-01'.","completion":"List<Wall> walls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().Cast<Wall>().ToList();\nint updatedCount = 0;\nforeach(var w in walls)\n{\n  Parameter p = w.get_Parameter(BuiltInParameter.ALL_MODEL_MARK);\n  if(p != null && !p.IsReadOnly && string.IsNullOrEmpty(p.AsString()))\n  {\n      p.Set(\"WM-01\");\n      updatedCount++;\n  }\n}\nTaskDialog.Show(\"Result\", $\"{updatedCount} walls with an empty mark were updated to 'WM-01'.\");"}
{"prompt":"Crea un nivel intermedio llamado 'Mezzanine' a mitad de camino entre el Nivel 1 y el Nivel 2.","completion":"string newLevelName = \"Mezzanine\";\nif (new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == newLevelName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El nivel '{newLevelName}' ya existe.\");\n}\nelse\n{\n    Level lvl1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().FirstOrDefault(l=>l.Name==\"Level 1\");\n    Level lvl2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().FirstOrDefault(l=>l.Name==\"Level 2\");\n    if(lvl1 != null && lvl2 != null)\n    {\n      double midElevation = (lvl1.ProjectElevation + lvl2.ProjectElevation) / 2.0;\n      Level.Create(doc, midElevation).Name = newLevelName;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontraron el 'Nivel 1' y/o el 'Nivel 2'.\");\n    }\n}"}

{"prompt":"Create an intermediate level named 'Mezzanine' halfway between Level 1 and Level 2.","completion":"string newLevelName = \"Mezzanine\";\nif (new FilteredElementCollector(doc).OfClass(typeof(Level)).Any(l => l.Name == newLevelName))\n{\n    TaskDialog.Show(\"Warning\", $\"Level '{newLevelName}' already exists.\");\n}\nelse\n{\n    Level lvl1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().FirstOrDefault(l=>l.Name==\"Level 1\");\n    Level lvl2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().FirstOrDefault(l=>l.Name==\"Level 2\");\n    if(lvl1 != null && lvl2 != null)\n    {\n      double midElevation = (lvl1.ProjectElevation + lvl2.ProjectElevation) / 2.0;\n      Level.Create(doc, midElevation).Name = newLevelName;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Could not find 'Level 1' and/or 'Level 2'.\");\n    }\n}"}
{"prompt":"Cambia el material de todos los muros a 'Acero'.","completion":"TaskDialog.Show(\"Acción Peligrosa\", \"Aplicar un material a todos los muros modifica el TIPO de muro, afectando a todos los ejemplares de ese tipo en el proyecto. Si es lo que deseas, pide 'Modifica el tipo de muro para que use Acero'. Para cambiar solo un muro, duplica primero su tipo.\");"}
{"prompt":"Change the material of all walls to 'Steel'.","completion":"TaskDialog.Show(\"Dangerous Action\", \"Applying a material to all walls modifies the wall TYPE, affecting all instances of that type in the project. If this is desired, ask 'Modify the wall type to use Steel'. To change a single wall, duplicate its type first.\");"}
{"prompt":"Añade una línea de rejilla U en un muro cortina a 3m desde el origen.","completion":"Wall curtainWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.WallType.Kind == WallKind.Curtain) as Wall;\nif(curtainWall != null)\n{\n    CurtainGrid grid = curtainWall.CurtainGrid;\n    grid.AddGridLine(true, new XYZ(UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0, 0), false);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró ningún muro cortina en el proyecto.\");\n}"}
{"prompt":"Add a U grid line to a curtain wall at 3m from the origin.","completion":"Wall curtainWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.WallType.Kind == WallKind.Curtain) as Wall;\nif(curtainWall != null)\n{\n    CurtainGrid grid = curtainWall.CurtainGrid;\n    grid.AddGridLine(true, new XYZ(UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0, 0), false);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No curtain wall was found in the project.\");\n}"}
{"prompt":"Añade una línea de rejilla V en un muro cortina a 2m de altura.","completion":"Wall curtainWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.WallType.Kind == WallKind.Curtain) as Wall;\nif(curtainWall != null)\n{\n    CurtainGrid grid = curtainWall.CurtainGrid;\n    grid.AddGridLine(false, new XYZ(0, 0, UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters)), false);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró ningún muro cortina en el proyecto.\");\n}"}
{"prompt":"Add a V grid line to a curtain wall at 2m height.","completion":"Wall curtainWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.WallType.Kind == WallKind.Curtain) as Wall;\nif(curtainWall != null)\n{\n    CurtainGrid grid = curtainWall.CurtainGrid;\n    grid.AddGridLine(false, new XYZ(0, 0, UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters)), false);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No curtain wall was found in the project.\");\n}"}
{"prompt":"Activa todos los segmentos en la primera línea de rejilla U.","completion":"Wall curtainWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.WallType.Kind == WallKind.Curtain) as Wall;\nif(curtainWall != null)\n{\n    CurtainGrid grid = curtainWall.CurtainGrid;\n    ElementId firstUGridLineId = grid.GetUGridLineIds().FirstOrDefault();\n    if(firstUGridLineId != null && firstUGridLineId != ElementId.InvalidElementId)\n    {\n        CurtainGridLine uLine = doc.GetElement(firstUGridLineId) as CurtainGridLine;\n        if(uLine != null) uLine.AddAllSegments();\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", \"El muro cortina no tiene líneas de rejilla U.\");\n    }\n}"}
{"prompt":"Activate all segments on the first U grid line.","completion":"Wall curtainWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.WallType.Kind == WallKind.Curtain) as Wall;\nif(curtainWall != null)\n{\n    CurtainGrid grid = curtainWall.CurtainGrid;\n    ElementId firstUGridLineId = grid.GetUGridLineIds().FirstOrDefault();\n    if(firstUGridLineId != null && firstUGridLineId != ElementId.InvalidElementId)\n    {\n        CurtainGridLine uLine = doc.GetElement(firstUGridLineId) as CurtainGridLine;\n        if(uLine != null) uLine.AddAllSegments();\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", \"The curtain wall does not have any U-grid lines.\");\n    }\n}"}
{"prompt":"Añade montantes en la línea de rejilla U seleccionada.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona una línea de rejilla de muro cortina\");\nif (pickedRef != null)\n{\n    CurtainGridLine gridLine = doc.GetElement(pickedRef) as CurtainGridLine;\n    MullionType mullionType = new FilteredElementCollector(doc).OfClass(typeof(MullionType)).FirstOrDefault() as MullionType;\n    if(gridLine != null && mullionType != null)\n    {\n        gridLine.AddMullions(gridLine.FullCurve, mullionType, false);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no es una línea de rejilla o no hay tipos de montante.\");\n    }\n}"}
{"prompt":"Add mullions to the selected U grid line.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a curtain grid line\");\nif (pickedRef != null)\n{\n    CurtainGridLine gridLine = doc.GetElement(pickedRef) as CurtainGridLine;\n    MullionType mullionType = new FilteredElementCollector(doc).OfClass(typeof(MullionType)).FirstOrDefault() as MullionType;\n    if(gridLine != null && mullionType != null)\n    {\n        gridLine.AddMullions(gridLine.FullCurve, mullionType, false);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element is not a grid line or no mullion types exist.\");\n    }\n}"}
{"prompt":"Aísla la rejilla V seleccionada y añade solo un segmento.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona una línea de rejilla V\");\nif (pickedRef != null)\n{\n    CurtainGridLine vLine = doc.GetElement(pickedRef) as CurtainGridLine;\n    if(vLine != null)\n    {\n        Curve segment = vLine.GetSegmentCurves().FirstOrDefault();\n        if(segment != null) vLine.AddSegment(segment);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"El elemento seleccionado no es una línea de rejilla de muro cortina.\");\n    }\n}"}
{"prompt":"Isolate the selected V gridline and add only one segment.","completion":"UIDocument uidoc = new UIDocument(doc);\nReference pickedRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select a V grid line\");\nif (pickedRef != null)\n{\n    CurtainGridLine vLine = doc.GetElement(pickedRef) as CurtainGridLine;\n    if(vLine != null)\n    {\n        Curve segment = vLine.GetSegmentCurves().FirstOrDefault();\n        if(segment != null) vLine.AddSegment(segment);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected element is not a curtain grid line.\");\n    }\n}"}
{"prompt":"¿Cuántas puertas hay en el 'Nivel 1'?","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nif (level != null)\n{\n    ElementCategoryFilter categoryFilter = new ElementCategoryFilter(BuiltInCategory.OST_Doors);\n    ElementLevelFilter levelFilter = new ElementLevelFilter(level.Id);\n    LogicalAndFilter andFilter = new LogicalAndFilter(categoryFilter, levelFilter);\n    int doorCount = new FilteredElementCollector(doc).WherePasses(andFilter).GetElementCount();\n    TaskDialog.Show(\"Conteo de Puertas\", $\"Hay {doorCount} puertas en el Nivel 1.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el 'Nivel 1'.\");\n}"}
{"prompt":"How many doors are on 'Level 1'?","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nif (level != null)\n{\n    ElementCategoryFilter categoryFilter = new ElementCategoryFilter(BuiltInCategory.OST_Doors);\n    ElementLevelFilter levelFilter = new ElementLevelFilter(level.Id);\n    LogicalAndFilter andFilter = new LogicalAndFilter(categoryFilter, levelFilter);\n    int doorCount = new FilteredElementCollector(doc).WherePasses(andFilter).GetElementCount();\n    TaskDialog.Show(\"Door Count\", $\"There are {doorCount} doors on Level 1.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Could not find 'Level 1'.\");\n}"}
{"prompt":"Selecciona todos los muros estructurales del Nivel 2 que sean más largos de 10 metros.","completion":"Level level2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 2\") as Level;\nif (level2 != null)\n{\n    ElementCategoryFilter catFilter = new ElementCategoryFilter(BuiltInCategory.OST_Walls);\n    ElementLevelFilter lvlFilter = new ElementLevelFilter(level2.Id);\n    FilterRule structRule = ParameterFilterRuleFactory.CreateEqualsRule(new ElementId(BuiltInParameter.WALL_STRUCTURAL_SIGNIFICANT), 1);\n    ElementParameterFilter structFilter = new ElementParameterFilter(structRule);\n    FilterRule lengthRule = ParameterFilterRuleFactory.CreateGreaterRule(new ElementId(BuiltInParameter.CURVE_ELEM_LENGTH), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters));\n    ElementParameterFilter lengthFilter = new ElementParameterFilter(lengthRule);\n    LogicalAndFilter andFilter = new LogicalAndFilter(new List<ElementFilter> { catFilter, lvlFilter, structFilter, lengthFilter });\n    ICollection<ElementId> wallIds = new FilteredElementCollector(doc).WherePasses(andFilter).ToElementIds();\n    if(wallIds.Any())\n    {\n        new UIDocument(doc).Selection.SetElementIds(wallIds);\n        TaskDialog.Show(\"Selección\", $\"Se seleccionaron {wallIds.Count} muros.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", \"No se encontraron muros que cumplan con todos los criterios.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el 'Nivel 2'.\");\n}"}
{"prompt":"Select all structural walls on Level 2 that are longer than 10 meters.","completion":"Level level2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 2\") as Level;\nif (level2 != null)\n{\n    ElementCategoryFilter catFilter = new ElementCategoryFilter(BuiltInCategory.OST_Walls);\n    ElementLevelFilter lvlFilter = new ElementLevelFilter(level2.Id);\n    FilterRule structRule = ParameterFilterRuleFactory.CreateEqualsRule(new ElementId(BuiltInParameter.WALL_STRUCTURAL_SIGNIFICANT), 1);\n    ElementParameterFilter structFilter = new ElementParameterFilter(structRule);\n    FilterRule lengthRule = ParameterFilterRuleFactory.CreateGreaterRule(new ElementId(BuiltInParameter.CURVE_ELEM_LENGTH), UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters));\n    ElementParameterFilter lengthFilter = new ElementParameterFilter(lengthRule);\n    LogicalAndFilter andFilter = new LogicalAndFilter(new List<ElementFilter> { catFilter, lvlFilter, structFilter, lengthFilter });\n    ICollection<ElementId> wallIds = new FilteredElementCollector(doc).WherePasses(andFilter).ToElementIds();\n    if(wallIds.Any())\n    {\n        new UIDocument(doc).Selection.SetElementIds(wallIds);\n        TaskDialog.Show(\"Selection\", $\"Selected {wallIds.Count} walls.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", \"No walls were found that meet all criteria.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Level 2' not found.\");\n}"}
{"prompt":"Permíteme seleccionar dos puntos y dibuja una viga entre ellos.","completion":"UIDocument uidoc = new UIDocument(doc);\nFamilySymbol beamType = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nLevel level = doc.ActiveView.GenLevel;\nif(beamType != null && level != null)\n{\n    try \n    {\n        XYZ p1 = uidoc.Selection.PickPoint(\"Selecciona el punto de inicio de la viga\");\n        XYZ p2 = uidoc.Selection.PickPoint(\"Selecciona el punto final de la viga\");\n        Line beamCurve = Line.CreateBound(p1, p2);\n        if(!beamType.IsActive) beamType.Activate();\n        doc.Create.NewFamilyInstance(beamCurve, beamType, level, StructuralType.Beam);\n    } \n    catch (Autodesk.Revit.Exceptions.OperationCanceledException) \n    {\n        TaskDialog.Show(\"Cancelado\", \"Operación cancelada por el usuario.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un tipo de viga y un nivel activo para esta operación.\");\n}"}
{"prompt":"Let me select two points and draw a beam between them.","completion":"UIDocument uidoc = new UIDocument(doc);\nFamilySymbol beamType = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFraming).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\nLevel level = doc.ActiveView.GenLevel;\nif(beamType != null && level != null)\n{\n    try \n    {\n        XYZ p1 = uidoc.Selection.PickPoint(\"Select the beam start point\");\n        XYZ p2 = uidoc.Selection.PickPoint(\"Select the beam end point\");\n        Line beamCurve = Line.CreateBound(p1, p2);\n        if(!beamType.IsActive) beamType.Activate();\n        doc.Create.NewFamilyInstance(beamCurve, beamType, level, StructuralType.Beam);\n    } \n    catch (Autodesk.Revit.Exceptions.OperationCanceledException) \n    {\n        TaskDialog.Show(\"Cancelled\", \"Operation cancelled by user.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A beam type and an active level are required for this operation.\");\n}"}
{"prompt":"Crea un muro del tipo 'EXT-Ladrillo', y si no existe, créalo primero.","completion":"string wallTypeName = \"EXT-Ladrillo\";\nWallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault(wt => wt.Name == wallTypeName) as WallType;\nif (wallType == null)\n{\n    TaskDialog.Show(\"Info\", $\"El tipo '{wallTypeName}' no existe. Se creará uno nuevo.\");\n    WallType template = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\n    if(template != null) \n    {\n        wallType = template.Duplicate(wallTypeName) as WallType;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontraron tipos de muro para usar como plantilla.\");\n        return;\n    }\n}\nif(wallType != null)\n{\n    Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\n    if(level != null)\n    {\n        Line wallCurve = Line.CreateBound(XYZ.Zero, new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0, 0));\n        Wall.Create(doc, wallCurve, wallType.Id, level.Id, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0, false, false);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró un nivel para colocar el muro.\");\n    }\n}"}
{"prompt":"Create a wall of type 'EXT-Brick', and if it doesn't exist, create it first.","completion":"string wallTypeName = \"EXT-Brick\";\nWallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault(wt => wt.Name == wallTypeName) as WallType;\nif (wallType == null)\n{\n    TaskDialog.Show(\"Info\", $\"Type '{wallTypeName}' does not exist. A new one will be created.\");\n    WallType template = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\n    if(template != null) \n    {\n        wallType = template.Duplicate(wallTypeName) as WallType;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No wall types found to use as a template.\");\n        return;\n    }\n}\nif(wallType != null)\n{\n    Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\n    if(level != null)\n    {\n        Line wallCurve = Line.CreateBound(XYZ.Zero, new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0, 0));\n        Wall.Create(doc, wallCurve, wallType.Id, level.Id, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0, false, false);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No level found to place the wall on.\");\n    }\n}"}
{"prompt":"¿Cuál es el volumen total de hormigón en los forjados?","completion":"List<Floor> floors = new FilteredElementCollector(doc).OfClass(typeof(Floor)).WhereElementIsNotElementType().Cast<Floor>().ToList();\ndouble totalVolume = 0.0;\nforeach(Element floor in floors)\n{\n    Parameter volumeParam = floor.get_Parameter(BuiltInParameter.HOST_VOLUME_COMPUTED);\n    if(volumeParam != null) totalVolume += volumeParam.AsDouble();\n}\nstring formattedVolume = UnitUtils.ConvertFromInternalUnits(totalVolume, UnitTypeId.CubicMeters).ToString(\"F2\");\nTaskDialog.Show(\"Volumen Total de Forjados\", $\"El volumen total en {floors.Count} forjados es: {formattedVolume} m³.\");"}
{"prompt":"What is the total volume of concrete in the floors?","completion":"List<Floor> floors = new FilteredElementCollector(doc).OfClass(typeof(Floor)).WhereElementIsNotElementType().Cast<Floor>().ToList();\ndouble totalVolume = 0.0;\nforeach(Element floor in floors)\n{\n    Parameter volumeParam = floor.get_Parameter(BuiltInParameter.HOST_VOLUME_COMPUTED);\n    if(volumeParam != null) totalVolume += volumeParam.AsDouble();\n}\nstring formattedVolume = UnitUtils.ConvertFromInternalUnits(totalVolume, UnitTypeId.CubicMeters).ToString(\"F2\");\nTaskDialog.Show(\"Total Floor Volume\", $\"The total volume in {floors.Count} floors is: {formattedVolume} m³.\");"}
{"prompt":"Aplica el material 'Pintura Roja' a todas las caras de los muros seleccionados.","completion":"Material redPaint = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name == \"Pintura Roja\") as Material;\nUIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(redPaint != null && selectedIds.Any())\n{\n    int paintedCount = 0;\n    foreach(ElementId id in selectedIds)\n    {\n        Wall wall = doc.GetElement(id) as Wall;\n        if(wall != null)\n        {\n            IList<Face> faces = HostObjectUtils.GetSideFaces(wall, ShellLayerType.Interior);\n            foreach(Face f in faces) { doc.Paint(wall.Id, f, redPaint.Id); paintedCount++; }\n            faces = HostObjectUtils.GetSideFaces(wall, ShellLayerType.Exterior);\n            foreach(Face f in faces) { doc.Paint(wall.Id, f, redPaint.Id); paintedCount++; }\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{paintedCount} caras han sido pintadas.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el material 'Pintura Roja' o no había muros seleccionados.\");\n}"}
{"prompt":"Apply the 'Red Paint' material to all faces of the selected walls.","completion":"Material redPaint = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name == \"Red Paint\") as Material;\nUIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(redPaint != null && selectedIds.Any())\n{\n    int paintedCount = 0;\n    foreach(ElementId id in selectedIds)\n    {\n        Wall wall = doc.GetElement(id) as Wall;\n        if(wall != null)\n        {\n            IList<Face> faces = HostObjectUtils.GetSideFaces(wall, ShellLayerType.Interior);\n            foreach(Face f in faces) { doc.Paint(wall.Id, f, redPaint.Id); paintedCount++; }\n            faces = HostObjectUtils.GetSideFaces(wall, ShellLayerType.Exterior);\n            foreach(Face f in faces) { doc.Paint(wall.Id, f, redPaint.Id); paintedCount++; }\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{paintedCount} faces have been painted.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"'Red Paint' material not found or no walls were selected.\");\n}"}
{"prompt":"Crea una nueva hoja A1 para cada vista de planta en el proyecto.","completion":"List<ViewPlan> planViews = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).Where(v => !v.IsTemplate).Cast<ViewPlan>().ToList();\nFamilySymbol titleBlock = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_TitleBlocks).WhereElementIsElementType().FirstOrDefault(tb => tb.Name.Contains(\"A1\")) as FamilySymbol;\nif(titleBlock != null && planViews.Any())\n{\n    int sheetCounter = 101;\n    int createdCount = 0;\n    foreach(ViewPlan view in planViews)\n    {\n        string sheetNumber = $\"A-{sheetCounter++}\";\n        if (!new FilteredElementCollector(doc).OfClass(typeof(ViewSheet)).Any(s => s.SheetNumber == sheetNumber))\n        {\n            ViewSheet newSheet = ViewSheet.Create(doc, titleBlock.Id);\n            newSheet.Name = view.Name;\n            newSheet.SheetNumber = sheetNumber;\n            if(Viewport.CanAddViewToSheet(doc, newSheet.Id, view.Id))\n            {\n                Viewport.Create(doc, newSheet.Id, view.Id, new XYZ(0.5, 0.5, 0));\n                createdCount++;\n            }\n        }\n    }\n    TaskDialog.Show(\"Éxito\", $\"Se crearon {createdCount} hojas nuevas.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró un cajetín A1 o no hay vistas de planta para colocar.\");\n}"}
{"prompt":"Create a new A1 sheet for each floor plan view in the project.","completion":"List<ViewPlan> planViews = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).Where(v => !v.IsTemplate).Cast<ViewPlan>().ToList();\nFamilySymbol titleBlock = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_TitleBlocks).WhereElementIsElementType().FirstOrDefault(tb => tb.Name.Contains(\"A1\")) as FamilySymbol;\nif(titleBlock != null && planViews.Any())\n{\n    int sheetCounter = 101;\n    int createdCount = 0;\n    foreach(ViewPlan view in planViews)\n    {\n        string sheetNumber = $\"A-{sheetCounter++}\";\n        if (!new FilteredElementCollector(doc).OfClass(typeof(ViewSheet)).Any(s => s.SheetNumber == sheetNumber))\n        {\n            ViewSheet newSheet = ViewSheet.Create(doc, titleBlock.Id);\n            newSheet.Name = view.Name;\n            newSheet.SheetNumber = sheetNumber;\n            if(Viewport.CanAddViewToSheet(doc, newSheet.Id, view.Id))\n            {\n                Viewport.Create(doc, newSheet.Id, view.Id, new XYZ(0.5, 0.5, 0));\n                createdCount++;\n            }\n        }\n    }\n    TaskDialog.Show(\"Success\", $\"{createdCount} new sheets were created.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A1 title block not found or no plan views to place.\");\n}"}
{"prompt":"Encuentra todos los muros que no están asociados a ningún nivel.","completion":"ElementFilter unassociatedFilter = new ElementLevelFilter(ElementId.InvalidElementId);\nList<Element> unassignedWalls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WherePasses(unassociatedFilter).ToList();\nTaskDialog.Show(\"Muros sin Nivel\", $\"Se encontraron {unassignedWalls.Count} muros sin nivel base.\");\nif (unassignedWalls.Any()) new UIDocument(doc).Selection.SetElementIds(unassignedWalls.Select(e => e.Id).ToList());"}
{"prompt":"Find all walls that are not associated with any level.","completion":"ElementFilter unassociatedFilter = new ElementLevelFilter(ElementId.InvalidElementId);\nList<Element> unassignedWalls = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WherePasses(unassociatedFilter).ToList();\nTaskDialog.Show(\"Unassigned Walls\", $\"Found {unassignedWalls.Count} walls with no base level.\");\nif (unassignedWalls.Any()) new UIDocument(doc).Selection.SetElementIds(unassignedWalls.Select(e => e.Id).ToList());"}
{"prompt":"Crea una nueva fase 'Fase 3 - Ejecución'.","completion":"string phaseName = \"Fase 3 - Ejecución\";\nif (doc.Phases.Cast<Phase>().Any(p => p.Name == phaseName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"La fase '{phaseName}' ya existe.\");\n}\nelse\n{\n    Phase lastPhase = doc.Phases.Cast<Phase>().LastOrDefault();\n    if (lastPhase != null)\n    {\n        Phase newPhase = doc.Phases.CreateAfter(lastPhase.Id);\n        newPhase.Name = phaseName;\n        TaskDialog.Show(\"Éxito\", $\"Fase '{phaseName}' creada.\");\n    }\n}"}
{"prompt":"Create a new phase 'Phase 3 - Execution'.","completion":"string phaseName = \"Phase 3 - Execution\";\nif (doc.Phases.Cast<Phase>().Any(p => p.Name == phaseName))\n{\n    TaskDialog.Show(\"Warning\", $\"Phase '{phaseName}' already exists.\");\n}\nelse\n{\n    Phase lastPhase = doc.Phases.Cast<Phase>().LastOrDefault();\n    if (lastPhase != null)\n    {\n        Phase newPhase = doc.Phases.CreateAfter(lastPhase.Id);\n        newPhase.Name = phaseName;\n        TaskDialog.Show(\"Success\", $\"Phase '{phaseName}' created.\");\n    }\n}"}
{"prompt":"Asigna la demolición de los muros seleccionados a la 'Fase 3 - Ejecución'.","completion":"Phase phase = new FilteredElementCollector(doc).OfClass(typeof(Phase)).Cast<Phase>().FirstOrDefault(p=>p.Name==\"Fase 3 - Ejecución\");\nUIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(phase != null && selectedIds.Any())\n{\n    int updatedCount = 0;\n    foreach(ElementId id in selectedIds)\n    {\n        Element elem = doc.GetElement(id);\n        if(elem is Wall)\n        {\n            elem.DemolishedPhaseId = phase.Id;\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"{updatedCount} muros asignados para demolición en la '{phase.Name}'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró la fase 'Fase 3 - Ejecución' o no había muros seleccionados.\");\n}"}
{"prompt":"Assign the demolition of selected walls to 'Phase 3 - Execution'.","completion":"Phase phase = new FilteredElementCollector(doc).OfClass(typeof(Phase)).Cast<Phase>().FirstOrDefault(p=>p.Name==\"Phase 3 - Execution\");\nUIDocument uidoc = new UIDocument(doc);\nICollection<ElementId> selectedIds = uidoc.Selection.GetElementIds();\nif(phase != null && selectedIds.Any())\n{\n    int updatedCount = 0;\n    foreach(ElementId id in selectedIds)\n    {\n        Element elem = doc.GetElement(id);\n        if(elem is Wall)\n        {\n            elem.DemolishedPhaseId = phase.Id;\n            updatedCount++;\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"{updatedCount} walls assigned for demolition in the '{phase.Name}'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Phase 'Phase 3 - Execution' not found or no walls were selected.\");\n}"}
{"prompt":"Cambia el primer tipo de muro curvo a un tipo estructural.","completion":"WallType curvedWallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).Cast<WallType>().FirstOrDefault(w=>w.Kind==WallKind.Curved);\nif(curvedWallType != null)\n{\n    Parameter p = curvedWallType.get_Parameter(BuiltInParameter.FUNCTION_PARAM);\n    if(p != null && !p.IsReadOnly)\n    {\n        p.Set((int)WallFunction.Structural);\n        TaskDialog.Show(\"Éxito\", $\"El tipo de muro '{curvedWallType.Name}' ahora es estructural.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron tipos de muro curvo.\");\n}"}
{"prompt":"Change the first curved wall type to a structural type.","completion":"WallType curvedWallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).Cast<WallType>().FirstOrDefault(w=>w.Kind==WallKind.Curtain);\nif(curvedWallType != null)\n{\n    Parameter p = curvedWallType.get_Parameter(BuiltInParameter.FUNCTION_PARAM);\n    if(p != null && !p.IsReadOnly)\n    {\n        p.Set((int)WallFunction.Structural);\n        TaskDialog.Show(\"Success\", $\"Wall type '{curvedWallType.Name}' is now structural.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No curved wall types were found.\");\n}"}
{"prompt":"Cambia el material de los paneles de muro cortina a 'Vidrio' si no tienen material.","completion":"TaskDialog.Show(\"Acción Peligrosa\", \"Esta acción modifica el TIPO de panel, afectando a todos los paneles de ese tipo en el proyecto. Si es lo que deseas, pide 'Modifica el tipo de panel para que use Vidrio'. Para cambiar solo un panel, duplica primero su tipo.\");"}
{"prompt":"Set curtain panel material to 'Glass' if unassigned.","completion":"TaskDialog.Show(\"Dangerous Action\", \"This action modifies the panel TYPE, affecting all panels of that type in the project. If this is desired, ask 'Modify the panel type to use Glass'. To change a single panel, duplicate its type first.\");"}
{"prompt":"Duplica el tipo de muro 'Genérico - 200mm' y nómbralo 'Muro_Dibujo'.","completion":"string originalName = \"Genérico - 200mm\";\nstring newName = \"Muro_Dibujo\";\nif (new FilteredElementCollector(doc).OfClass(typeof(WallType)).Any(wt => wt.Name == newName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de muro '{newName}' ya existe.\");\n}\nelse\n{\n    WallType originalType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault(wt => wt.Name == originalName) as WallType;\n    if(originalType != null)\n    {\n        originalType.Duplicate(newName);\n        TaskDialog.Show(\"Éxito\", $\"Tipo de muro '{originalName}' duplicado como '{newName}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", $\"No se encontró el tipo de muro '{originalName}'.\");\n    }\n}"}
{"prompt":"Duplicate wall type 'Generic - 200mm' and name it 'Drawing_Wall'.","completion":"string originalName = \"Generic - 200mm\";\nstring newName = \"Drawing_Wall\";\nif (new FilteredElementCollector(doc).OfClass(typeof(WallType)).Any(wt => wt.Name == newName))\n{\n    TaskDialog.Show(\"Warning\", $\"Wall type '{newName}' already exists.\");\n}\nelse\n{\n    WallType originalType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault(wt => wt.Name == originalName) as WallType;\n    if(originalType != null)\n    {\n        originalType.Duplicate(newName);\n        TaskDialog.Show(\"Success\", $\"Wall type '{originalName}' duplicated as '{newName}'.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", $\"Wall type '{originalName}' not found.\");\n    }\n}"}
{"prompt":"Exporta los IDs y las elevaciones de los niveles a un archivo CSV.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"levels.csv\");\nList<Level> levels = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().ToList();\nList<string> lines = new List<string>{\"Id,Name,Elevation_m\"};\nforeach(var l in levels)\n{\n    lines.Add($\"{l.Id.IntegerValue},{l.Name},{UnitUtils.ConvertFromInternalUnits(l.ProjectElevation, UnitTypeId.Meters):F2}\");\n}\nSystem.IO.File.WriteAllLines(filePath, lines);\nTaskDialog.Show(\"Exportación Completa\", $\"{levels.Count} niveles exportados a: {filePath}\");"}
{"prompt":"Export level IDs and elevations to a CSV file.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"levels.csv\");\nList<Level> levels = new FilteredElementCollector(doc).OfClass(typeof(Level)).Cast<Level>().ToList();\nList<string> lines = new List<string>{\"Id,Name,Elevation_m\"};\nforeach(var l in levels)\n{\n    lines.Add($\"{l.Id.IntegerValue},{l.Name},{UnitUtils.ConvertFromInternalUnits(l.ProjectElevation, UnitTypeId.Meters):F2}\");\n}\nSystem.IO.File.WriteAllLines(filePath, lines);\nTaskDialog.Show(\"Export Complete\", $\"{levels.Count} levels exported to: {filePath}\");"}
{"prompt":"Elimina todos los montantes (mullions) desbloqueados de un muro cortina.","completion":"Wall curtainWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.WallType.Kind == WallKind.Curtain) as Wall;\nif(curtainWall != null)\n{\n    ICollection<ElementId> unlockedMullionIds = curtainWall.CurtainGrid.GetUnlockedMullionIds();\n    if(unlockedMullionIds.Any())\n    {\n        int count = unlockedMullionIds.Count;\n        doc.Delete(unlockedMullionIds);\n        TaskDialog.Show(\"Éxito\", $\"Se eliminaron {count} montantes desbloqueados.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Información\", \"No se encontraron montantes desbloqueados en el muro cortina.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró ningún muro cortina.\");\n}"}
{"prompt":"Delete all unlocked mullions from a curtain wall.","completion":"Wall curtainWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.WallType.Kind == WallKind.Curtain) as Wall;\nif(curtainWall != null)\n{\n    ICollection<ElementId> unlockedMullionIds = curtainWall.CurtainGrid.GetUnlockedMullionIds();\n    if(unlockedMullionIds.Any())\n    {\n        int count = unlockedMullionIds.Count;\n        doc.Delete(unlockedMullionIds);\n        TaskDialog.Show(\"Success\", $\"Deleted {count} unlocked mullions.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Information\", \"No unlocked mullions were found on the curtain wall.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No curtain wall was found.\");\n}"}
{"prompt":"Coloca la vista 'Nivel 1' en la hoja 'Planos de Planta' en el centro.","completion":"ViewSheet targetSheet = new FilteredElementCollector(doc).OfClass(typeof(ViewSheet)).Cast<ViewSheet>().FirstOrDefault(vs => vs.Name == \"Planos de Planta\");\nViewPlan targetView = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).Cast<ViewPlan>().FirstOrDefault(vp => vp.Name == \"Nivel 1\");\nif(targetSheet != null && targetView != null)\n{\n    if(Viewport.CanAddViewToSheet(doc, targetSheet.Id, targetView.Id))\n    {\n        BoundingBoxUV sheetBox = targetSheet.Outline;\n        XYZ centerPoint = (sheetBox.Min + sheetBox.Max) / 2;\n        Viewport.Create(doc, targetSheet.Id, targetView.Id, centerPoint);\n    }\n    else\n    {\n        TaskDialog.Show(\"Advertencia\", \"La vista ya está colocada en una hoja.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró la hoja 'Planos de Planta' o la vista 'Nivel 1'.\");\n}"}
{"prompt":"Place the 'Level 1' view on the 'Floor Plans' sheet at its center.","completion":"ViewSheet targetSheet = new FilteredElementCollector(doc).OfClass(typeof(ViewSheet)).Cast<ViewSheet>().FirstOrDefault(vs => vs.Name == \"Floor Plans\");\nViewPlan targetView = new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).Cast<ViewPlan>().FirstOrDefault(vp => vp.Name == \"Level 1\");\nif(targetSheet != null && targetView != null)\n{\n    if(Viewport.CanAddViewToSheet(doc, targetSheet.Id, targetView.Id))\n    {\n        BoundingBoxUV sheetBox = targetSheet.Outline;\n        XYZ centerPoint = (sheetBox.Min + sheetBox.Max) / 2;\n        Viewport.Create(doc, targetSheet.Id, targetView.Id, centerPoint);\n    }\n    else\n    {\n        TaskDialog.Show(\"Warning\", \"The view is already placed on a sheet.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Sheet 'Floor Plans' or view 'Level 1' not found.\");\n}"}
{"prompt":"Crea una masa in-place.","completion":"TaskDialog.Show(\"Acción no soportada\", \"La creación de familias in-situ es un proceso de edición complejo que no puede ser ejecutado directamente. Se recomienda modelar estos elementos usando las herramientas estándar de Revit.\");"}
{"prompt":"Create an in-place mass.","completion":"TaskDialog.Show(\"Unsupported Action\", \"Creating in-place families is a complex editing process that cannot be executed directly. It is recommended to model these elements using standard Revit tools.\");"}
{"prompt":"Crea una vista de detalle (callout) que siga la forma de un polígono.","completion":"TaskDialog.Show(\"Acción en Múltiples Pasos\", \"Para crear un callout poligonal, por favor dibuja primero las líneas de detalle que forman el polígono cerrado y selecciónalas. Luego, pide 'Crear callout a partir de la selección'.\");"}
{"prompt":"Create a detail callout view that follows the shape of a polygon.","completion":"TaskDialog.Show(\"Multi-Step Action\", \"To create a polygonal callout, please first draw the detail lines that form the closed polygon and select them. Then, ask 'Create callout from selection'.\");"}
{"prompt":"Crea una masa conceptual cónica.","completion":"TaskDialog.Show(\"Acción no soportada\", \"La creación de masas conceptuales es un modo de edición especial que no se puede ejecutar directamente con este agente. Se recomienda usar las herramientas estándar de Revit para modelar masas.\");"}
{"prompt":"Create a conical conceptual mass.","completion":"TaskDialog.Show(\"Unsupported Action\", \"Creating conceptual masses is a special editing mode that cannot be executed directly with this agent. It is recommended to use standard Revit tools to model masses.\");"}

{"prompt":"Aplica un material a todas las capas de un tipo de muro.","completion":"TaskDialog.Show(\"Acción Peligrosa\", \"Aplicar un material a todas las capas de un tipo de muro modifica el TIPO, afectando a todos los muros de ese tipo. Por favor, especifica el nombre del tipo de muro y el nombre del material para continuar, por ejemplo: 'Aplica el material Hormigón al tipo de muro Muro Genérico'.\");"}
{"prompt":"Apply a material to all layers of a wall type.","completion":"TaskDialog.Show(\"Dangerous Action\", \"Applying a material to all layers of a wall type modifies the TYPE, affecting all walls of that type. Please specify the wall type name and the material name to continue, for example: 'Apply Concrete material to the Generic Wall type'.\");"}
{"prompt":"Encuentra todos los elementos dentro de un 'Scope Box' específico.","completion":"string scopeBoxName = \"Zona A\";\nScopeBox scopeBox = new FilteredElementCollector(doc).OfClass(typeof(ScopeBox)).FirstOrDefault(sb => sb.Name == scopeBoxName) as ScopeBox;\nif(scopeBox != null)\n{\n    BoundingBoxXYZ bbox = scopeBox.get_BoundingBox(null);\n    if (bbox != null)\n    {\n        Outline outline = new Outline(bbox.Min, bbox.Max);\n        BoundingBoxIntersectsFilter filter = new BoundingBoxIntersectsFilter(outline);\n        List<Element> elementsInBox = new FilteredElementCollector(doc).WherePasses(filter).WhereElementIsNotElementType().ToList();\n        TaskDialog.Show(\"Resultado\", $\"Se encontraron {elementsInBox.Count} elementos dentro del Scope Box '{scopeBoxName}'.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"No se encontró el Scope Box llamado '{scopeBoxName}'.\");\n}"}
{"prompt":"Find all elements within a specific 'Scope Box'.","completion":"string scopeBoxName = \"Zone A\";\nScopeBox scopeBox = new FilteredElementCollector(doc).OfClass(typeof(ScopeBox)).FirstOrDefault(sb => sb.Name == scopeBoxName) as ScopeBox;\nif(scopeBox != null)\n{\n    BoundingBoxXYZ bbox = scopeBox.get_BoundingBox(null);\n    if (bbox != null)\n    {\n        Outline outline = new Outline(bbox.Min, bbox.Max);\n        BoundingBoxIntersectsFilter filter = new BoundingBoxIntersectsFilter(outline);\n        List<Element> elementsInBox = new FilteredElementCollector(doc).WherePasses(filter).WhereElementIsNotElementType().ToList();\n        TaskDialog.Show(\"Result\", $\"Found {elementsInBox.Count} elements inside Scope Box '{scopeBoxName}'.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"Scope Box named '{scopeBoxName}' not found.\");\n}"}
{"prompt":"Crea una vista de plano estructural para el Nivel 2.","completion":"string viewName = \"Plano Estructural Nivel 2\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).Any(v => v.Name == viewName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"La vista '{viewName}' ya existe.\");\n}\nelse\n{\n    ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(x => x.ViewFamily == ViewFamily.StructuralPlan);\n    Level level2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 2\") as Level;\n    if(vft != null && level2 != null)\n    {\n        ViewPlan.Create(doc, vft.Id, level2.Id).Name = viewName;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontró el tipo de vista de plano estructural o el Nivel 2.\");\n    }\n}"}
{"prompt":"Create a structural plan view for Level 2.","completion":"string viewName = \"Structural Plan Level 2\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ViewPlan)).Any(v => v.Name == viewName))\n{\n    TaskDialog.Show(\"Warning\", $\"View '{viewName}' already exists.\");\n}\nelse\n{\n    ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(x => x.ViewFamily == ViewFamily.StructuralPlan);\n    Level level2 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 2\") as Level;\n    if(vft != null && level2 != null)\n    {\n        ViewPlan.Create(doc, vft.Id, level2.Id).Name = viewName;\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Structural Plan view type or Level 2 not found.\");\n    }\n}"}
{"prompt":"Cambia el color de la línea de todas las tuberías sanitarias a verde.","completion":"PipingSystemType sanitarySystemType = new FilteredElementCollector(doc).OfClass(typeof(PipingSystemType)).Cast<PipingSystemType>().FirstOrDefault(s => s.SystemClassification == MEPSystemClassification.Sanitary);\nif(sanitarySystemType != null)\n{\n    OverrideGraphicSettings ogs = new OverrideGraphicSettings();\n    ogs.SetProjectionLineColor(new Color(0, 255, 0));\n    List<Pipe> pipes = new FilteredElementCollector(doc).OfClass(typeof(Pipe)).Cast<Pipe>().Where(p => p.get_Parameter(BuiltInParameter.RBS_PIPING_SYSTEM_TYPE_PARAM).AsElementId() == sanitarySystemType.Id).ToList();\n    foreach(Pipe p in pipes)\n    {\n        doc.ActiveView.SetElementOverrides(p.Id, ogs);\n    }\n    TaskDialog.Show(\"Resultado\", $\"{pipes.Count} tuberías sanitarias cambiadas a color verde.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró un tipo de sistema sanitario en el proyecto.\");\n}"}
{"prompt":"Change the line color of all sanitary pipes to green.","completion":"PipingSystemType sanitarySystemType = new FilteredElementCollector(doc).OfClass(typeof(PipingSystemType)).Cast<PipingSystemType>().FirstOrDefault(s => s.SystemClassification == MEPSystemClassification.Sanitary);\nif(sanitarySystemType != null)\n{\n    OverrideGraphicSettings ogs = new OverrideGraphicSettings();\n    ogs.SetProjectionLineColor(new Color(0, 255, 0));\n    List<Pipe> pipes = new FilteredElementCollector(doc).OfClass(typeof(Pipe)).Cast<Pipe>().Where(p => p.get_Parameter(BuiltInParameter.RBS_PIPING_SYSTEM_TYPE_PARAM).AsElementId() == sanitarySystemType.Id).ToList();\n    foreach(Pipe p in pipes)\n    {\n        doc.ActiveView.SetElementOverrides(p.Id, ogs);\n    }\n    TaskDialog.Show(\"Result\", $\"{pipes.Count} sanitary pipes changed to green.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No sanitary system type found in the project.\");\n}"}
{"prompt":"Oculta todos los elementos excepto los muros en la vista actual.","completion":"List<ElementId> categoryIdsToHide = new List<ElementId>();\nICollection<Category> categories = doc.Settings.Categories;\nforeach(Category cat in categories)\n{\n    if(cat.CategoryType == CategoryType.Model && cat.Id.IntegerValue != (int)BuiltInCategory.OST_Walls && cat.get_AllowsVisibilityControl(doc.ActiveView))\n    {\n        categoryIdsToHide.Add(cat.Id);\n    }\n}\nforeach(ElementId catId in categoryIdsToHide)\n{\n    doc.ActiveView.SetCategoryHidden(catId, true);\n}\nTaskDialog.Show(\"Resultado\", $\"{categoryIdsToHide.Count} categorías de modelo han sido ocultadas.\");"}
{"prompt":"Hide all elements except walls in the current view.","completion":"List<ElementId> categoryIdsToHide = new List<ElementId>();\nICollection<Category> categories = doc.Settings.Categories;\nforeach(Category cat in categories)\n{\n    if(cat.CategoryType == CategoryType.Model && cat.Id.IntegerValue != (int)BuiltInCategory.OST_Walls && cat.get_AllowsVisibilityControl(doc.ActiveView))\n    {\n        categoryIdsToHide.Add(cat.Id);\n    }\n}\nforeach(ElementId catId in categoryIdsToHide)\n{\n    doc.ActiveView.SetCategoryHidden(catId, true);\n}\nTaskDialog.Show(\"Result\", $\"{categoryIdsToHide.Count} model categories have been hidden.\");"}
{"prompt":"Encuentra y selecciona todas las familias no utilizadas en el proyecto.","completion":"ICollection<ElementId> allFamilies = new FilteredElementCollector(doc).OfClass(typeof(Family)).ToElementIds();\nList<ElementId> usedFamilyIds = new List<ElementId>();\nvar allInstances = new FilteredElementCollector(doc).WhereElementIsNotElementType().Where(e => e.GetTypeId() != null && e.Category != null);\nforeach(Element e in allInstances)\n{\n    ElementType type = doc.GetElement(e.GetTypeId()) as ElementType;\n    if (type != null && type.FamilyName != null)\n    {\n        usedFamilyIds.Add(type.Family.Id);\n    }\n}\nList<ElementId> unusedFamilyIds = allFamilies.Except(usedFamilyIds.Distinct()).ToList();\nif(unusedFamilyIds.Any())\n{\n    new UIDocument(doc).Selection.SetElementIds(unusedFamilyIds);\n    TaskDialog.Show(\"Resultado\", $\"{unusedFamilyIds.Count} familias no utilizadas han sido seleccionadas.\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No se encontraron familias no utilizadas.\");\n}"}
{"prompt":"Find and select all unused families in the project.","completion":"ICollection<ElementId> allFamilies = new FilteredElementCollector(doc).OfClass(typeof(Family)).ToElementIds();\nList<ElementId> usedFamilyIds = new List<ElementId>();\nvar allInstances = new FilteredElementCollector(doc).WhereElementIsNotElementType().Where(e => e.GetTypeId() != null && e.Category != null);\nforeach(Element e in allInstances)\n{\n    ElementType type = doc.GetElement(e.GetTypeId()) as ElementType;\n    if (type != null && type.FamilyName != null)\n    {\n        usedFamilyIds.Add(type.Family.Id);\n    }\n}\nList<ElementId> unusedFamilyIds = allFamilies.Except(usedFamilyIds.Distinct()).ToList();\nif(unusedFamilyIds.Any())\n{\n    new UIDocument(doc).Selection.SetElementIds(unusedFamilyIds);\n    TaskDialog.Show(\"Result\", $\"{unusedFamilyIds.Count} unused families have been selected.\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No unused families were found.\");\n}"}
{"prompt":"Exporta una lista de todas las vistas y sus plantillas aplicadas a CSV.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"ViewTemplates.csv\");\nList<View> views = new FilteredElementCollector(doc).OfClass(typeof(View)).Cast<View>().Where(v => v.CanBePrinted() && !v.IsTemplate).ToList();\nList<string> lines = new List<string>{\"ViewName,TemplateName\"};\nforeach(View v in views)\n{\n    string templateName = (v.ViewTemplateId != null && v.ViewTemplateId != ElementId.InvalidElementId) ? doc.GetElement(v.ViewTemplateId).Name : \"<None>\";\n    lines.Add($\"{v.Name},{templateName}\");\n}\nSystem.IO.File.WriteAllLines(filePath, lines);\nTaskDialog.Show(\"Exportación Completa\", $\"{views.Count} vistas exportadas a: {filePath}\");"}
{"prompt":"Export a list of all views and their applied templates to CSV.","completion":"string folderPath = \"C:/RevitExports/\";\nif(!System.IO.Directory.Exists(folderPath)) System.IO.Directory.CreateDirectory(folderPath);\nstring filePath = System.IO.Path.Combine(folderPath, \"ViewTemplates.csv\");\nList<View> views = new FilteredElementCollector(doc).OfClass(typeof(View)).Cast<View>().Where(v => v.CanBePrinted() && !v.IsTemplate).ToList();\nList<string> lines = new List<string>{\"ViewName,TemplateName\"};\nforeach(View v in views)\n{\n    string templateName = (v.ViewTemplateId != null && v.ViewTemplateId != ElementId.InvalidElementId) ? doc.GetElement(v.ViewTemplateId).Name : \"<None>\";\n    lines.Add($\"{v.Name},{templateName}\");\n}\nSystem.IO.File.WriteAllLines(filePath, lines);\nTaskDialog.Show(\"Export Complete\", $\"{views.Count} views exported to: {filePath}\");"}
{"prompt":"Añade rejillas U y V cada 2 m a un muro cortina.","completion":"Wall curtainWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.WallType.Kind == WallKind.Curtain) as Wall;\nif(curtainWall != null)\n{\n    CurtainGrid grid = curtainWall.CurtainGrid;\n    double spacing = UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters);\n    \n    // Add U-Grids (Vertical)\n    double uLength = grid.GridU.Length;\n    int uCount = (int)(uLength / spacing);\n    for (int i = 1; i < uCount; i++)\n    {\n        grid.AddGridLine(true, grid.GridU.Origin + i * spacing * grid.GridU.Direction, false);\n    }\n\n    // Add V-Grids (Horizontal)\n    double vLength = grid.GridV.Length;\n    int vCount = (int)(vLength / spacing);\n    for (int i = 1; i < vCount; i++)\n    {\n        grid.AddGridLine(false, grid.GridV.Origin + i * spacing * grid.GridV.Direction, false);\n    }\n    TaskDialog.Show(\"Éxito\", \"Rejillas añadidas al muro cortina.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró ningún muro cortina en el proyecto.\");\n}"}
{"prompt":"Add U and V gridlines every 2m to a curtain wall.","completion":"Wall curtainWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault(w => w.WallType.Kind == WallKind.Curtain) as Wall;\nif(curtainWall != null)\n{\n    CurtainGrid grid = curtainWall.CurtainGrid;\n    double spacing = UnitUtils.ConvertToInternalUnits(2, UnitTypeId.Meters);\n    \n    // Add U-Grids (Vertical)\n    double uLength = grid.GridU.Length;\n    int uCount = (int)(uLength / spacing);\n    for (int i = 1; i < uCount; i++)\n    {\n        grid.AddGridLine(true, grid.GridU.Origin + i * spacing * grid.GridU.Direction, false);\n    }\n\n    // Add V-Grids (Horizontal)\n    double vLength = grid.GridV.Length;\n    int vCount = (int)(vLength / spacing);\n    for (int i = 1; i < vCount; i++)\n    {\n        grid.AddGridLine(false, grid.GridV.Origin + i * spacing * grid.GridV.Direction, false);\n    }\n    TaskDialog.Show(\"Success\", \"Grid lines added to the curtain wall.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No curtain wall was found in the project.\");\n}"}
{"prompt":"Crea un muro de hormigón en el Nivel 1.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nif (level == null)\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el Nivel 1.\");\n    return;\n}\n\nList<WallType> concreteWallTypes = new FilteredElementCollector(doc).OfClass(typeof(WallType)).Cast<WallType>().Where(wt => wt.Name.ToLower().Contains(\"hormigón\") || wt.Name.ToLower().Contains(\"concrete\")).ToList();\nWallType selectedWallType = null;\n\nif (concreteWallTypes.Count == 1)\n{\n    selectedWallType = concreteWallTypes.First();\n}\nelse if (concreteWallTypes.Count > 1)\n{\n    TaskDialog.Show(\"Ambigüedad\", \"Se encontraron varios tipos de muro de hormigón. Por favor, sé más específico (ej: 'Crea un muro de Hormigón - 20cm').\");\n    return;\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró ningún tipo de muro de 'hormigón' en el proyecto.\");\n    return;\n}\n\nLine wallCurve = Line.CreateBound(XYZ.Zero, new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0, 0));\nWall.Create(doc, wallCurve, selectedWallType.Id, level.Id, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0, false, false);"}
{"prompt":"Create a concrete wall on Level 1.","completion":"Level level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nif (level == null)\n{\n    TaskDialog.Show(\"Error\", \"Level 1 not found.\");\n    return;\n}\n\nList<WallType> concreteWallTypes = new FilteredElementCollector(doc).OfClass(typeof(WallType)).Cast<WallType>().Where(wt => wt.Name.ToLower().Contains(\"concrete\")).ToList();\nWallType selectedWallType = null;\n\nif (concreteWallTypes.Count == 1)\n{\n    selectedWallType = concreteWallTypes.First();\n}\nelse if (concreteWallTypes.Count > 1)\n{\n    TaskDialog.Show(\"Ambiguity\", \"Multiple concrete wall types found. Please be more specific (e.g., 'Create a Concrete - 20cm wall').\");\n    return;\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No 'concrete' wall types found.\");\n    return;\n}\n\nLine wallCurve = Line.CreateBound(XYZ.Zero, new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), 0, 0));\nWall.Create(doc, wallCurve, selectedWallType.Id, level.Id, UnitUtils.ConvertToInternalUnits(3, UnitTypeId.Meters), 0, false, false);"}
{"prompt":"Inserta una puerta abatible en un muro.","completion":"List<FamilySymbol> doorSymbols = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().Cast<FamilySymbol>().Where(s => s.Name.ToLower().Contains(\"abatible\") || s.Name.ToLower().Contains(\"swing\")).ToList();\nFamilySymbol selectedSymbol = null;\n\nif (doorSymbols.Count == 1)\n{\n    selectedSymbol = doorSymbols.First();\n}\nelse if (doorSymbols.Count > 1)\n{\n    TaskDialog.Show(\"Ambigüedad\", \"Se encontraron varios tipos de puertas abatibles. Por favor, especifica el nombre completo.\");\n    return;\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró ningún tipo de puerta 'abatible'.\");\n    return;\n}\n\nWall hostWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault() as Wall;\nif (hostWall != null)\n{\n    if (!selectedSymbol.IsActive) selectedSymbol.Activate();\n    Level level = doc.GetElement(hostWall.LevelId) as Level;\n    XYZ insertionPoint = (hostWall.Location as LocationCurve).Curve.Evaluate(0.5, true);\n    doc.Create.NewFamilyInstance(insertionPoint, selectedSymbol, hostWall, level, StructuralType.NonStructural);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró ningún muro para colocar la puerta.\");\n}"}
{"prompt":"Insert a swing door into a wall.","completion":"List<FamilySymbol> doorSymbols = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsElementType().Cast<FamilySymbol>().Where(s => s.Name.ToLower().Contains(\"swing\")).ToList();\nFamilySymbol selectedSymbol = null;\n\nif (doorSymbols.Count == 1)\n{\n    selectedSymbol = doorSymbols.First();\n}\nelse if (doorSymbols.Count > 1)\n{\n    TaskDialog.Show(\"Ambiguity\", \"Multiple swing door types found. Please specify the full name.\");\n    return;\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No 'swing' door types found.\");\n    return;\n}\n\nWall hostWall = new FilteredElementCollector(doc).OfClass(typeof(Wall)).FirstOrDefault() as Wall;\nif (hostWall != null)\n{\n    if (!selectedSymbol.IsActive) selectedSymbol.Activate();\n    Level level = doc.GetElement(hostWall.LevelId) as Level;\n    XYZ insertionPoint = (hostWall.Location as LocationCurve).Curve.Evaluate(0.5, true);\n    doc.Create.NewFamilyInstance(insertionPoint, selectedSymbol, hostWall, level, StructuralType.NonStructural);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No host wall found to place the door.\");\n}"}
{"prompt":"Copia las propiedades de un muro a otro.","completion":"UIDocument uidoc = new UIDocument(doc);\ntry\n{\n    Reference sourceRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona el muro de origen\");\n    Wall sourceWall = doc.GetElement(sourceRef) as Wall;\n\n    Reference targetRef = uidoc.Selection.PickObject(ObjectType.Element, \"Selecciona el muro de destino\");\n    Wall targetWall = doc.GetElement(targetRef) as Wall;\n\n    if (sourceWall != null && targetWall != null)\n    {\n        targetWall.ChangeTypeId(sourceWall.WallType.Id);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Se deben seleccionar dos muros.\");\n    }\n}\ncatch (Autodesk.Revit.Exceptions.OperationCanceledException) { /* Operación cancelada por el usuario */ }"}
{"prompt":"Match the properties of one wall to another.","completion":"UIDocument uidoc = new UIDocument(doc);\ntry\n{\n    Reference sourceRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select the source wall\");\n    Wall sourceWall = doc.GetElement(sourceRef) as Wall;\n\n    Reference targetRef = uidoc.Selection.PickObject(ObjectType.Element, \"Select the target wall\");\n    Wall targetWall = doc.GetElement(targetRef) as Wall;\n\n    if (sourceWall != null && targetWall != null)\n    {\n        targetWall.ChangeTypeId(sourceWall.WallType.Id);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Two walls must be selected.\");\n    }\n}\ncatch (Autodesk.Revit.Exceptions.OperationCanceledException) { /* User cancelled the operation */ }"}
{"prompt":"Elimina todos los muros que no sean estructurales.","completion":"ParameterValueProvider pvp = new ParameterValueProvider(new ElementId(BuiltInParameter.WALL_STRUCTURAL_SIGNIFICANT));\nFilterRule rule = new FilterIntegerRule(pvp, new FilterNumericEquals(), 0);\nElementParameterFilter nonStructuralFilter = new ElementParameterFilter(rule);\nICollection<ElementId> nonStructuralWallIds = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WherePasses(nonStructuralFilter).ToElementIds();\nif (nonStructuralWallIds.Any())\n{\n    doc.Delete(nonStructuralWallIds);\n    TaskDialog.Show(\"Resultado\", $\"Se eliminaron {nonStructuralWallIds.Count} muros no estructurales.\");\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"No se encontraron muros no estructurales para eliminar.\");\n}"}
{"prompt":"Delete all non-structural walls.","completion":"ParameterValueProvider pvp = new ParameterValueProvider(new ElementId(BuiltInParameter.WALL_STRUCTURAL_SIGNIFICANT));\nFilterRule rule = new FilterIntegerRule(pvp, new FilterNumericEquals(), 0);\nElementParameterFilter nonStructuralFilter = new ElementParameterFilter(rule);\nICollection<ElementId> nonStructuralWallIds = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WherePasses(nonStructuralFilter).ToElementIds();\nif (nonStructuralWallIds.Any())\n{\n    doc.Delete(nonStructuralWallIds);\n    TaskDialog.Show(\"Result\", $\"Deleted {nonStructuralWallIds.Count} non-structural walls.\");\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"No non-structural walls were found to delete.\");\n}"}
{"prompt":"¿Cuál es el área total de los muros con la función 'Exterior'?","completion":"double totalArea = 0.0;\nFunc<Element, bool> filter = e => (e as Wall).WallType.Function == WallFunction.Exterior;\nList<Wall> exteriorWalls = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WhereElementIsNotElementType().Cast<Wall>().Where(filter).ToList();\nforeach(Wall wall in exteriorWalls)\n{\n    totalArea += wall.get_Parameter(BuiltInParameter.HOST_AREA_COMPUTED).AsDouble();\n}\nTaskDialog.Show(\"Área Total\", $\"Área total de muros exteriores: {UnitUtils.ConvertFromInternalUnits(totalArea, UnitTypeId.SquareMeters):F2} m² ({exteriorWalls.Count} muros).\");"}
{"prompt":"What is the total area of walls with the 'Exterior' function?","completion":"double totalArea = 0.0;\nFunc<Element, bool> filter = e => (e as Wall).WallType.Function == WallFunction.Exterior;\nList<Wall> exteriorWalls = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WhereElementIsNotElementType().Cast<Wall>().Where(filter).ToList();\nforeach(Wall wall in exteriorWalls)\n{\n    totalArea += wall.get_Parameter(BuiltInParameter.HOST_AREA_COMPUTED).AsDouble();\n}\nTaskDialog.Show(\"Total Area\", $\"Total area of exterior walls: {UnitUtils.ConvertFromInternalUnits(totalArea, UnitTypeId.SquareMeters):F2} m² ({exteriorWalls.Count} walls).\");"}
{"prompt":"Permíteme seleccionar varias ventanas y cambiar su tipo a 'Fijo 100x100'.","completion":"UIDocument uidoc = new UIDocument(doc);\nFamilySymbol targetSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsElementType().FirstOrDefault(s => s.Name == \"Fijo 100x100\") as FamilySymbol;\nif (targetSymbol == null)\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el tipo de ventana 'Fijo 100x100'.\");\n    return;\n}\ntry\n{\n    ICollection<ElementId> pickedIds = uidoc.Selection.PickObjects(ObjectType.Element, new Autodesk.Revit.UI.Selection.SelectionFilter.CategorySelectionFilter(\"Windows\"), \"Selecciona las ventanas a cambiar\").Select(r => r.ElementId).ToList();\n    if (pickedIds.Any())\n    {\n        if(!targetSymbol.IsActive) targetSymbol.Activate();\n        foreach(ElementId id in pickedIds)\n        {\n            FamilyInstance window = doc.GetElement(id) as FamilyInstance;\n            if(window != null) window.Symbol = targetSymbol;\n        }\n    }\n}\ncatch (Autodesk.Revit.Exceptions.OperationCanceledException) { /* Operación cancelada */ }"}
{"prompt":"Let me select multiple windows and change their type to 'Fixed 100x100'.","completion":"UIDocument uidoc = new UIDocument(doc);\nFamilySymbol targetSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsElementType().FirstOrDefault(s => s.Name == \"Fixed 100x100\") as FamilySymbol;\nif (targetSymbol == null)\n{\n    TaskDialog.Show(\"Error\", \"Window type 'Fixed 100x100' not found.\");\n    return;\n}\ntry\n{\n    ICollection<ElementId> pickedIds = uidoc.Selection.PickObjects(ObjectType.Element, new Autodesk.Revit.UI.Selection.SelectionFilter.CategorySelectionFilter(\"Windows\"), \"Select windows to change\").Select(r => r.ElementId).ToList();\n    if (pickedIds.Any())\n    {\n        if(!targetSymbol.IsActive) targetSymbol.Activate();\n        foreach(ElementId id in pickedIds)\n        {\n            FamilyInstance window = doc.GetElement(id) as FamilyInstance;\n            if(window != null) window.Symbol = targetSymbol;\n        }\n    }\n}\ncatch (Autodesk.Revit.Exceptions.OperationCanceledException) { /* Operation cancelled */ }"}
{"prompt":"Crea un suelo del tipo 'Suelo de madera', si no existe, créalo y luego haz el suelo.","completion":"string floorTypeName = \"Suelo de madera\";\nFloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault(ft => ft.Name == floorTypeName) as FloorType;\nif(floorType == null)\n{\n    TaskDialog.Show(\"Info\", $\"El tipo '{floorTypeName}' no existe. Creando uno nuevo.\");\n    FloorType template = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\n    if(template != null) \n    {\n        floorType = template.Duplicate(floorTypeName) as FloorType;\n    }\n    else \n    {\n        TaskDialog.Show(\"Error\", \"No se encontraron tipos de suelo para usar como plantilla.\");\n        return;\n    }\n}\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nif(level != null)\n{\n    CurveLoop profile = CurveLoop.CreateViaRectangle(new XYZ(0,0,0), new XYZ(5,5,0));\n    Floor.Create(doc, new List<CurveLoop>{profile}, floorType.Id, level.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró un nivel para crear el suelo.\");\n}"}
{"prompt":"Create a 'Wood Floor' type floor, if it doesn't exist, create it, then make the floor.","completion":"string floorTypeName = \"Wood Floor\";\nFloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault(ft => ft.Name == floorTypeName) as FloorType;\nif(floorType == null)\n{\n    TaskDialog.Show(\"Info\", $\"Type '{floorTypeName}' does not exist. Creating a new one.\");\n    FloorType template = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\n    if(template != null) \n    {\n        floorType = template.Duplicate(floorTypeName) as FloorType;\n    }\n    else \n    {\n        TaskDialog.Show(\"Error\", \"No floor types found to use as a template.\");\n        return;\n    }\n}\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nif(level != null)\n{\n    CurveLoop profile = CurveLoop.CreateViaRectangle(new XYZ(0,0,0), new XYZ(5,5,0));\n    Floor.Create(doc, new List<CurveLoop>{profile}, floorType.Id, level.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No level found to create the floor on.\");\n}"}
{"prompt":"Reporta el número de cada tipo de muro en el proyecto.","completion":"var wallTypeGroups = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WhereElementIsNotElementType().GroupBy(w => w.WallType.Name);\nStringBuilder report = new StringBuilder(\"Conteo de Muros por Tipo:\\n\");\nforeach(var group in wallTypeGroups)\n{\n    report.AppendLine($\"- {group.Key}: {group.Count()} unidades\");\n}\nTaskDialog.Show(\"Reporte de Muros\", report.ToString());"}
{"prompt":"Report the number of each wall type in the project.","completion":"var wallTypeGroups = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WhereElementIsNotElementType().GroupBy(w => w.WallType.Name);\nStringBuilder report = new StringBuilder(\"Wall Count by Type:\\n\");\nforeach(var group in wallTypeGroups)\n{\n    report.AppendLine($\"- {group.Key}: {group.Count()} units\");\n}\nTaskDialog.Show(\"Wall Report\", report.ToString());"}
{"prompt":"Crea una masa de loft entre dos perfiles circulares.","completion":"TaskDialog.Show(\"Acción no soportada\", \"La creación de masas conceptuales es un modo de edición especial que no se puede ejecutar directamente con este agente. Se recomienda usar las herramientas estándar de Revit para modelar masas.\");"}
{"prompt":"Create a loft mass between two circular profiles.","completion":"TaskDialog.Show(\"Unsupported Action\", \"Creating conceptual masses is a special editing mode that cannot be executed directly with this agent. It is recommended to use standard Revit tools to model masses.\");"}
{"prompt":"Permíteme seleccionar varios elementos y asignarlos al workset 'Núcleo y Fachada'.","completion":"if(doc.IsWorkshared)\n{\n    UIDocument uidoc = new UIDocument(doc);\n    string wsName = \"Núcleo y Fachada\";\n    Workset workset = new FilteredWorksetCollector(doc).OfKind(WorksetKind.UserWorkset).FirstOrDefault(ws => ws.Name == wsName);\n    if(workset == null) workset = Workset.Create(doc, wsName);\n\n    try\n    {\n        ICollection<ElementId> pickedIds = uidoc.Selection.PickObjects(ObjectType.Element, \"Selecciona elementos para asignar al workset\").Select(r => r.ElementId).ToList();\n        if(pickedIds.Any())\n        {\n            WorksharingUtils.ChangeWorkset(doc, pickedIds, workset.Id);\n            TaskDialog.Show(\"Éxito\", $\"{pickedIds.Count} elementos asignados al workset '{wsName}'.\");\n        }\n    }\n    catch (Autodesk.Revit.Exceptions.OperationCanceledException) { /* Operación cancelada */ }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Esta acción requiere un modelo compartido (Workshared).\");\n}"}
{"prompt":"Let me select multiple elements and assign them to the 'Core and Shell' workset.","completion":"if(doc.IsWorkshared)\n{\n    UIDocument uidoc = new UIDocument(doc);\n    string wsName = \"Core and Shell\";\n    Workset workset = new FilteredWorksetCollector(doc).OfKind(WorksetKind.UserWorkset).FirstOrDefault(ws => ws.Name == wsName);\n    if(workset == null) workset = Workset.Create(doc, wsName);\n\n    try\n    {\n        ICollection<ElementId> pickedIds = uidoc.Selection.PickObjects(ObjectType.Element, \"Select elements to assign to the workset\").Select(r => r.ElementId).ToList();\n        if(pickedIds.Any())\n        {\n            WorksharingUtils.ChangeWorkset(doc, pickedIds, workset.Id);\n            TaskDialog.Show(\"Success\", $\"{pickedIds.Count} elements assigned to workset '{wsName}'.\");\n        }\n    }\n    catch (Autodesk.Revit.Exceptions.OperationCanceledException) { /* Operation cancelled */ }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"This action requires a workshared model.\");\n}"}
{"prompt":"Recarga todos los vínculos CAD del proyecto.","completion":"List<CADLinkType> cadLinkTypes = new FilteredElementCollector(doc).OfClass(typeof(CADLinkType)).Cast<CADLinkType>().ToList();\nint count = 0;\nforeach(CADLinkType linkType in cadLinkTypes)\n{\n    try\n    {\n        linkType.Reload();\n        count++;\n    }\n    catch {}\n}\nTaskDialog.Show(\"Resultado\", $\"Se recargaron {count} vínculos CAD.\");"}
{"prompt":"Reload all CAD links in the project.","completion":"List<CADLinkType> cadLinkTypes = new FilteredElementCollector(doc).OfClass(typeof(CADLinkType)).Cast<CADLinkType>().ToList();\nint count = 0;\nforeach(CADLinkType linkType in cadLinkTypes)\n{\n    try\n    {\n        linkType.Reload();\n        count++;\n    }\n    catch {}\n}\nTaskDialog.Show(\"Result\", $\"Reloaded {count} CAD links.\");"}
{"prompt":"Encuentra todas las habitaciones con un área menor a 10 m².","completion":"double areaThreshold = UnitUtils.ConvertToInternalUnits(10, UnitTypeId.SquareMeters);\nList<Room> smallRooms = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).WhereElementIsNotElementType().Cast<Room>().Where(r => r.Area < areaThreshold).ToList();\nTaskDialog.Show(\"Habitaciones Pequeñas\", $\"Se encontraron {smallRooms.Count} habitaciones con menos de 10 m².\");\nif(smallRooms.Any()) new UIDocument(doc).Selection.SetElementIds(smallRooms.Select(r=>r.Id).ToList());"}
{"prompt":"Find all rooms with an area smaller than 10 m².","completion":"double areaThreshold = UnitUtils.ConvertToInternalUnits(10, UnitTypeId.SquareMeters);\nList<Room> smallRooms = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).WhereElementIsNotElementType().Cast<Room>().Where(r => r.Area < areaThreshold).ToList();\nTaskDialog.Show(\"Small Rooms\", $\"Found {smallRooms.Count} rooms smaller than 10 m².\");\nif(smallRooms.Any()) new UIDocument(doc).Selection.SetElementIds(smallRooms.Select(r=>r.Id).ToList());"}
{"prompt":"Crea un nuevo tipo de losa 'Losa 20cm' y asígnale el material 'Hormigón'.","completion":"string typeName = \"Losa 20cm\";\nif (new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Any(f => f.Name == typeName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El tipo de losa '{typeName}' ya existe.\");\n}\nelse\n{\n    FloorType template = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\n    if(template != null)\n    {\n        FloorType floorType = template.Duplicate(typeName) as FloorType;\n        CompoundStructure cs = floorType.GetCompoundStructure();\n        int coreIndex = cs.GetFirstCoreLayerIndex();\n        if (coreIndex != -1)\n        {\n            cs.SetLayerWidth(coreIndex, UnitUtils.ConvertToInternalUnits(20, UnitTypeId.Centimeters));\n            Material concrete = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name.Contains(\"Hormigón\") || m.Name.Contains(\"Concrete\")) as Material;\n            if(concrete != null) cs.SetMaterialId(coreIndex, concrete.Id);\n        }\n        floorType.SetCompoundStructure(cs);\n        TaskDialog.Show(\"Éxito\", $\"Tipo de losa '{typeName}' creado.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No se encontraron tipos de losa para usar como plantilla.\");\n    }\n}"}
{"prompt":"Create a new 'Slab 20cm' floor type and assign 'Concrete' material to it.","completion":"string typeName = \"Slab 20cm\";\nif (new FilteredElementCollector(doc).OfClass(typeof(FloorType)).Any(f => f.Name == typeName))\n{\n    TaskDialog.Show(\"Warning\", $\"Floor type '{typeName}' already exists.\");\n}\nelse\n{\n    FloorType template = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\n    if(template != null)\n    {\n        FloorType floorType = template.Duplicate(typeName) as FloorType;\n        CompoundStructure cs = floorType.GetCompoundStructure();\n        int coreIndex = cs.GetFirstCoreLayerIndex();\n        if (coreIndex != -1)\n        {\n            cs.SetLayerWidth(coreIndex, UnitUtils.ConvertToInternalUnits(20, UnitTypeId.Centimeters));\n            Material concrete = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name.Contains(\"Concrete\")) as Material;\n            if(concrete != null) cs.SetMaterialId(coreIndex, concrete.Id);\n        }\n        floorType.SetCompoundStructure(cs);\n        TaskDialog.Show(\"Success\", $\"Floor type '{typeName}' created.\");\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"No floor types found to use as a template.\");\n    }\n}"}
{"prompt":"Dibuja una línea de detalle roja y discontinua.","completion":"Line line = Line.CreateBound(XYZ.Zero, new XYZ(10,10,0));\nSketchPlane sp = doc.ActiveView.SketchPlane;\nif (sp != null)\n{\n    DetailLine detailLine = doc.Create.NewDetailCurve(doc.ActiveView, line) as DetailLine;\n    OverrideGraphicSettings ogs = new OverrideGraphicSettings();\n    ogs.SetProjectionLineColor(new Color(255, 0, 0));\n    LinePatternElement dashPattern = new FilteredElementCollector(doc).OfClass(typeof(LinePatternElement)).Cast<LinePatternElement>().FirstOrDefault(p => p.Name.Contains(\"Dash\") || p.Name.Contains(\"Discontinua\"));\n    if(dashPattern != null) \n    {\n        ogs.SetProjectionLinePatternId(dashPattern.Id);\n        doc.ActiveView.SetElementOverrides(detailLine.Id, ogs);\n    }\n}"}
{"prompt":"Draw a red, dashed detail line.","completion":"Line line = Line.CreateBound(XYZ.Zero, new XYZ(10,10,0));\nSketchPlane sp = doc.ActiveView.SketchPlane;\nif (sp != null)\n{\n    DetailLine detailLine = doc.Create.NewDetailCurve(doc.ActiveView, line) as DetailLine;\n    OverrideGraphicSettings ogs = new OverrideGraphicSettings();\n    ogs.SetProjectionLineColor(new Color(255, 0, 0));\n    LinePatternElement dashPattern = new FilteredElementCollector(doc).OfClass(typeof(LinePatternElement)).Cast<LinePatternElement>().FirstOrDefault(p => p.Name.Contains(\"Dash\"));\n    if(dashPattern != null) \n    {\n        ogs.SetProjectionLinePatternId(dashPattern.Id);\n        doc.ActiveView.SetElementOverrides(detailLine.Id, ogs);\n    }\n}"}
{"prompt":"Crea un suelo rectangular con el tipo 'Suelo de madera'.","completion":"string floorTypeName = \"Suelo de madera\";\nFloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault(f => f.Name == floorTypeName) as FloorType;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nif(floorType != null && level != null)\n{\n    CurveLoop profile = CurveLoop.CreateViaRectangle(new XYZ(0,0,0), new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(8, UnitTypeId.Meters), 0));\n    Floor.Create(doc, new List<CurveLoop>{profile}, floorType.Id, level.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"No se encontró el tipo '{floorTypeName}' o un nivel válido.\");\n}"}
{"prompt":"Create a rectangular floor with the 'Wood Floor' type.","completion":"string floorTypeName = \"Wood Floor\";\nFloorType floorType = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault(f => f.Name == floorTypeName) as FloorType;\nLevel level = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault() as Level;\nif(floorType != null && level != null)\n{\n    CurveLoop profile = CurveLoop.CreateViaRectangle(new XYZ(0,0,0), new XYZ(UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters), UnitUtils.ConvertToInternalUnits(8, UnitTypeId.Meters), 0));\n    Floor.Create(doc, new List<CurveLoop>{profile}, floorType.Id, level.Id);\n}\nelse\n{\n    TaskDialog.Show(\"Error\", $\"Could not find type '{floorTypeName}' or a valid level.\");\n}"}
{"prompt":"Alinea todos los muros con el eje '1'.","completion":"Grid targetGrid = new FilteredElementCollector(doc).OfClass(typeof(Grid)).Cast<Grid>().FirstOrDefault(g => g.Name == \"1\");\nif(targetGrid != null)\n{\n    List<Wall> walls = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WhereElementIsNotElementType().Cast<Wall>().ToList();\n    int alignedCount = 0;\n    foreach(Wall wall in walls)\n    {\n        try\n        {\n            doc.Create.NewAlignment(doc.ActiveView, new Reference(wall), new Reference(targetGrid));\n            alignedCount++;\n        }\n        catch {}\n    }\n    TaskDialog.Show(\"Resultado\", $\"{alignedCount} muros han sido alineados con el eje '1'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontró el eje '1'.\");\n}"}
{"prompt":"Align all walls to grid '1'.","completion":"Grid targetGrid = new FilteredElementCollector(doc).OfClass(typeof(Grid)).Cast<Grid>().FirstOrDefault(g => g.Name == \"1\");\nif(targetGrid != null)\n{\n    List<Wall> walls = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WhereElementIsNotElementType().Cast<Wall>().ToList();\n    int alignedCount = 0;\n    foreach(Wall wall in walls)\n    {\n        try\n        {\n            doc.Create.NewAlignment(doc.ActiveView, new Reference(wall), new Reference(targetGrid));\n            alignedCount++;\n        }\n        catch {}\n    }\n    TaskDialog.Show(\"Result\", $\"{alignedCount} walls have been aligned with grid '1'.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Grid '1' not found.\");\n}"}
{"prompt":"Crea una forma de masa 'in-situ' mediante una extrusión por revolución.","completion":"TaskDialog.Show(\"Acción no soportada\", \"La creación de familias in-situ y masas conceptuales es un proceso de edición complejo que no puede ser ejecutado directamente. Se recomienda modelar estos elementos usando las herramientas estándar de Revit.\");"}
{"prompt":"Create an in-place mass form using a revolution extrusion.","completion":"TaskDialog.Show(\"Unsupported Action\", \"Creating in-place families and conceptual masses is a complex editing process that cannot be executed directly. It is recommended to model these elements using standard Revit tools.\");"}
{"prompt":"Crea un suelo siguiendo el contorno de un conjunto de muros perimetrales seleccionados.","completion":"UIDocument uidoc = new UIDocument(doc);\nIList<Reference> pickedRefs = uidoc.Selection.PickObjects(ObjectType.Element, \"Selecciona los muros del contorno\");\nList<Wall> walls = pickedRefs.Select(r => doc.GetElement(r)).OfType<Wall>().ToList();\nif (walls.Count > 2)\n{\n    CurveLoop loop = new CurveLoop();\n    foreach (Wall w in walls)\n    {\n        LocationCurve lc = w.Location as LocationCurve;\n        if (lc != null) loop.Append(lc.Curve);\n    }\n    if(!loop.IsOpen())\n    {\n        FloorType ft = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\n        Level lvl = doc.GetElement(walls[0].LevelId) as Level;\n        if (ft != null && lvl != null) Floor.Create(doc, new List<CurveLoop>{loop}, ft.Id, lvl.Id);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"Las líneas de los muros seleccionados no forman un contorno cerrado.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Información\", \"Se necesitan al menos 3 muros para formar un contorno.\");\n}"}
{"prompt":"Create a floor following the contour of a set of selected perimeter walls.","completion":"UIDocument uidoc = new UIDocument(doc);\nIList<Reference> pickedRefs = uidoc.Selection.PickObjects(ObjectType.Element, \"Select the boundary walls\");\nList<Wall> walls = pickedRefs.Select(r => doc.GetElement(r)).OfType<Wall>().ToList();\nif (walls.Count > 2)\n{\n    CurveLoop loop = new CurveLoop();\n    foreach (Wall w in walls)\n    {\n        LocationCurve lc = w.Location as LocationCurve;\n        if (lc != null) loop.Append(lc.Curve);\n    }\n    if(!loop.IsOpen())\n    {\n        FloorType ft = new FilteredElementCollector(doc).OfClass(typeof(FloorType)).FirstOrDefault() as FloorType;\n        Level lvl = doc.GetElement(walls[0].LevelId) as Level;\n        if (ft != null && lvl != null) Floor.Create(doc, new List<CurveLoop>{loop}, ft.Id, lvl.Id);\n    }\n    else\n    {\n        TaskDialog.Show(\"Error\", \"The selected wall lines do not form a closed loop.\");\n    }\n}\nelse\n{\n    TaskDialog.Show(\"Information\", \"At least 3 walls are needed to form a boundary.\");\n}"}
{"prompt":"Crea un filtro de vista que resalte en rojo todos los muros con resistencia al fuego de 2 horas.","completion":"string filterName = \"Muros Cortafuego 2hr\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ParameterFilterElement)).Any(f => f.Name == filterName))\n{\n    TaskDialog.Show(\"Advertencia\", $\"El filtro '{filterName}' ya existe.\");\n}\nelse\n{\n    ElementId fireRatingParamId = new ElementId(BuiltInParameter.FIRE_RATING);\n    FilterRule rule = ParameterFilterRuleFactory.CreateContainsRule(fireRatingParamId, \"2-hr\", false);\n    ElementFilter filter = new ElementParameterFilter(rule);\n    ParameterFilterElement pfe = ParameterFilterElement.Create(doc, filterName, new List<ElementId>{new ElementId(BuiltInCategory.OST_Walls)}, filter);\n    OverrideGraphicSettings ogs = new OverrideGraphicSettings();\n    ogs.SetCutBackgroundPatternColor(new Color(255,0,0));\n    ogs.SetSurfaceForegroundPatternColor(new Color(255,0,0));\n    doc.ActiveView.AddFilter(pfe.Id);\n    doc.ActiveView.SetFilterOverrides(pfe.Id, ogs);\n    TaskDialog.Show(\"Éxito\", $\"Filtro '{filterName}' creado y aplicado.\");\n}"}
{"prompt":"Create a view filter that highlights in red all walls with a 2-hour fire rating.","completion":"string filterName = \"2hr Fire-Rated Walls\";\nif (new FilteredElementCollector(doc).OfClass(typeof(ParameterFilterElement)).Any(f => f.Name == filterName))\n{\n    TaskDialog.Show(\"Warning\", $\"Filter '{filterName}' already exists.\");\n}\nelse\n{\n    ElementId fireRatingParamId = new ElementId(BuiltInParameter.FIRE_RATING);\n    FilterRule rule = ParameterFilterRuleFactory.CreateContainsRule(fireRatingParamId, \"2-hr\", false);\n    ElementFilter filter = new ElementParameterFilter(rule);\n    ParameterFilterElement pfe = ParameterFilterElement.Create(doc, filterName, new List<ElementId>{new ElementId(BuiltInCategory.OST_Walls)}, filter);\n    OverrideGraphicSettings ogs = new OverrideGraphicSettings();\n    ogs.SetCutBackgroundPatternColor(new Color(255,0,0));\n    ogs.SetSurfaceForegroundPatternColor(new Color(255,0,0));\n    doc.ActiveView.AddFilter(pfe.Id);\n    doc.ActiveView.SetFilterOverrides(pfe.Id, ogs);\n    TaskDialog.Show(\"Success\", $\"Filter '{filterName}' created and applied.\");\n}"}
{"prompt":"Agrupa barras en un contenedor de refuerzo (Rebar Container) alrededor de una zapata.","completion":"FamilyInstance footing = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFoundation).WhereElementIsNotElementType().FirstOrDefault() as FamilyInstance;\nif(footing != null)\n{\n    RebarContainer rebarContainer = RebarContainer.Create(doc, footing);\n    TaskDialog.Show(\"Éxito\", \"Se creó un contenedor de refuerzo para la zapata. A continuación, añade las barras de refuerzo.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se encontraron zapatas en el proyecto.\");\n}"}
{"prompt":"Group rebars in a Rebar Container around a footing.","completion":"FamilyInstance footing = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralFoundation).WhereElementIsNotElementType().FirstOrDefault() as FamilyInstance;\nif(footing != null)\n{\n    RebarContainer rebarContainer = RebarContainer.Create(doc, footing);\n    TaskDialog.Show(\"Success\", \"A rebar container was created for the footing. Next, add rebar items.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No footings found in the project.\");\n}"}
{"prompt":"Crea un elemento de Área a partir de una selección de líneas de contorno de área.","completion":"UIDocument uidoc = new UIDocument(doc);\nAreaScheme scheme = new FilteredElementCollector(doc).OfClass(typeof(AreaScheme)).FirstOrDefault() as AreaScheme;\nLevel level = doc.ActiveView.GenLevel;\nif(scheme != null && level != null)\n{\n    try\n    {\n        IList<Reference> pickedRefs = uidoc.Selection.PickObjects(ObjectType.Element, \"Selecciona líneas de contorno de área\");\n        CurveArray curves = new CurveArray();\n        foreach(Reference r in pickedRefs)\n        {\n            ModelCurve mc = doc.GetElement(r) as ModelCurve;\n            if (mc != null && mc.Category.Id.IntegerValue == (int)BuiltInCategory.OST_AreaSchemeLines)\n            {\n                curves.Append(mc.GeometryCurve);\n            }\n        }\n        doc.Create.NewAreaBoundaryLine(doc.ActiveView.SketchPlane, curves, doc.ActiveView);\n    }\n    catch (Autodesk.Revit.Exceptions.OperationCanceledException) { /* Operación cancelada */ }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un Esquema de Área y un Nivel activo.\");\n}"}
{"prompt":"Create an Area element from a selection of area boundary lines.","completion":"UIDocument uidoc = new UIDocument(doc);\nAreaScheme scheme = new FilteredElementCollector(doc).OfClass(typeof(AreaScheme)).FirstOrDefault() as AreaScheme;\nLevel level = doc.ActiveView.GenLevel;\nif(scheme != null && level != null)\n{\n    try\n    {\n        IList<Reference> pickedRefs = uidoc.Selection.PickObjects(ObjectType.Element, \"Select area boundary lines\");\n        CurveArray curves = new CurveArray();\n        foreach(Reference r in pickedRefs)\n        {\n            ModelCurve mc = doc.GetElement(r) as ModelCurve;\n            if (mc != null && mc.Category.Id.IntegerValue == (int)BuiltInCategory.OST_AreaSchemeLines)\n            {\n                curves.Append(mc.GeometryCurve);\n            }\n        }\n        doc.Create.NewAreaBoundaryLine(doc.ActiveView.SketchPlane, curves, doc.ActiveView);\n    }\n    catch (Autodesk.Revit.Exceptions.OperationCanceledException) { /* Operation cancelled */ }\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"An Area Scheme and an active Level are required.\");\n}"}
{"prompt":"Suscríbete al evento 'DocumentSavingAs' para ejecutar una función antes de que el documento se guarde con un nuevo nombre.","completion":"TaskDialog.Show(\"Acción no soportada\", \"La suscripción a eventos de la aplicación (como DocumentSavingAs) no se puede realizar en tiempo real. Requiere la programación de un complemento de Revit (IExternalApplication) y reiniciar Revit para que los cambios surtan efecto.\");"}
{"prompt":"Subscribe to the 'DocumentSavingAs' event to run a function before the document is saved with a new name.","completion":"TaskDialog.Show(\"Unsupported Action\", \"Subscribing to application events (like DocumentSavingAs) cannot be done in real-time. It requires programming a Revit Add-in (IExternalApplication) and restarting Revit for the changes to take effect.\");"}
{"prompt":"Inserta un componente adaptativo de familia \"AdaptivePoint\" en tres puntos dados.","completion":"TaskDialog.Show(\"Acción no soportada\", \"La creación de componentes adaptativos requiere la selección interactiva de puntos de referencia en el modelo, lo cual está fuera del alcance de un comando simple. Se recomienda usar las herramientas estándar de Revit.\");"}
{"prompt":"Insert an adaptive component of family \"AdaptivePoint\" at three given points.","completion":"TaskDialog.Show(\"Unsupported Action\", \"Creating adaptive components requires interactive selection of reference points in the model, which is beyond the scope of a simple command. It is recommended to use standard Revit tools.\");"}
{"prompt":"Realiza una auditoría básica del proyecto: cuenta familias, vistas sin plantilla y modelos genéricos.","completion":"StringBuilder report = new StringBuilder(\"--- Auditoría Básica del Proyecto ---\\n\n\");\n\n// 1. Conteo de Familias\nint totalFamilies = new FilteredElementCollector(doc).OfClass(typeof(Family)).GetElementCount();\nreport.AppendLine($\"Total de Familias Cargadas: {totalFamilies}\");\n\n// 2. Vistas sin Plantilla\nList<View> viewsWithoutTemplate = new FilteredElementCollector(doc).OfClass(typeof(View)).Cast<View>().Where(v => v.CanBePrinted() && !v.IsTemplate && v.ViewTemplateId == ElementId.InvalidElementId).ToList();\nreport.AppendLine($\"Vistas sin Plantilla Asignada: {viewsWithoutTemplate.Count}\");\n\n// 3. Modelos Genéricos\nint genericModelCount = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_GenericModel).WhereElementIsNotElementType().GetElementCount();\nreport.AppendLine($\"Instancias de Modelo Genérico: {genericModelCount}\");\n\n// 4. Vínculos CAD Importados\nint cadImportCount = new FilteredElementCollector(doc).OfClass(typeof(ImportInstance)).GetElementCount();\nreport.AppendLine($\"Vínculos CAD Importados: {cadImportCount}\");\n\nTaskDialog.Show(\"Reporte de Auditoría\", report.ToString());"}
{"prompt":"Audit the project: count families, views without templates, and generic models.","completion":"StringBuilder report = new StringBuilder(\"--- Basic Project Audit ---\\n\n\");\n\n// 1. Family Count\nint totalFamilies = new FilteredElementCollector(doc).OfClass(typeof(Family)).GetElementCount();\nreport.AppendLine($\"Total Loaded Families: {totalFamilies}\");\n\n// 2. Views without Template\nList<View> viewsWithoutTemplate = new FilteredElementCollector(doc).OfClass(typeof(View)).Cast<View>().Where(v => v.CanBePrinted() && !v.IsTemplate && v.ViewTemplateId == ElementId.InvalidElementId).ToList();\nreport.AppendLine($\"Views without Assigned Template: {viewsWithoutTemplate.Count}\");\n\n// 3. Generic Models\nint genericModelCount = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_GenericModel).WhereElementIsNotElementType().GetElementCount();\nreport.AppendLine($\"Generic Model Instances: {genericModelCount}\");\n\n// 4. Imported CAD Links\nint cadImportCount = new FilteredElementCollector(doc).OfClass(typeof(ImportInstance)).GetElementCount();\nreport.AppendLine($\"Imported CAD Links: {cadImportCount}\");\n\nTaskDialog.Show(\"Audit Report\", report.ToString());"}
{"prompt":"Desde un archivo CSV con 'Tipo', 'Tamaño' y 'Marca', actualiza el parámetro 'Mark' de los accesorios de tubería.","completion":"UIDocument uidoc = new UIDocument(doc);\nOpenFileDialog ofd = new OpenFileDialog { Title = \"Selecciona el archivo CSV\", Filter = \"CSV Files|*.csv\" };\nif (ofd.ShowDialog() == DialogResult.OK)\n{\n    var markData = new Dictionary<string, string>();\n    var lines = System.IO.File.ReadAllLines(ofd.FileName).Skip(1);\n    foreach (var line in lines)\n    {\n        var cols = line.Split(',');\n        if (cols.Length < 3) continue;\n        string key = $\"{cols[0].Trim()}|{cols[1].Trim()}\"; // Clave: Tipo|Tamaño\n        if (!markData.ContainsKey(key)) markData.Add(key, cols[2].Trim());\n    }\n\n    var fittings = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_PipeFitting).WhereElementIsNotElementType().Cast<FamilyInstance>().ToList();\n    int updatedCount = 0;\n\n    foreach (var fi in fittings)\n    {\n        string typeName = fi.Symbol.Name;\n        string size = fi.LookupParameter(\"Size\")?.AsString() ?? \"\";\n        string keyToFind = $\"{typeName}|{size}\";\n        if (markData.TryGetValue(keyToFind, out string newMark))\n        {\n            Parameter pMark = fi.get_Parameter(BuiltInParameter.ALL_MODEL_MARK);\n            if (pMark != null && !pMark.IsReadOnly) { pMark.Set(newMark); updatedCount++; }\n        }\n    }\n    TaskDialog.Show(\"Resultado\", $\"Proceso completado. Se actualizaron {updatedCount} accesorios de tubería.\");\n}"}
{"prompt":"From a CSV file with 'Type', 'Size', and 'Mark', update the 'Mark' parameter for pipe fittings.","completion":"UIDocument uidoc = new UIDocument(doc);\nOpenFileDialog ofd = new OpenFileDialog { Title = \"Select CSV file\", Filter = \"CSV Files|*.csv\" };\nif (ofd.ShowDialog() == DialogResult.OK)\n{\n    var markData = new Dictionary<string, string>();\n    var lines = System.IO.File.ReadAllLines(ofd.FileName).Skip(1);\n    foreach (var line in lines)\n    {\n        var cols = line.Split(',');\n        if (cols.Length < 3) continue;\n        string key = $\"{cols[0].Trim()}|{cols[1].Trim()}\"; // Key: Type|Size\n        if (!markData.ContainsKey(key)) markData.Add(key, cols[2].Trim());\n    }\n\n    var fittings = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_PipeFitting).WhereElementIsNotElementType().Cast<FamilyInstance>().ToList();\n    int updatedCount = 0;\n\n    foreach (var fi in fittings)\n    {\n        string typeName = fi.Symbol.Name;\n        string size = fi.LookupParameter(\"Size\")?.AsString() ?? \"\";\n        string keyToFind = $\"{typeName}|{size}\";\n        if (markData.TryGetValue(keyToFind, out string newMark))\n        {\n            Parameter pMark = fi.get_Parameter(BuiltInParameter.ALL_MODEL_MARK);\n            if (pMark != null && !pMark.IsReadOnly) { pMark.Set(newMark); updatedCount++; }\n        }\n    }\n    TaskDialog.Show(\"Result\", $\"Process completed. {updatedCount} pipe fittings were updated.\");\n}"}
{"prompt":"Crea una nave industrial de 50x30 metros. Primero crea los muros perimetrales de 6m de alto en el Nivel 1.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nWallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\nif (level1 != null && wallType != null)\n{\n    double length = UnitUtils.ConvertToInternalUnits(50, UnitTypeId.Meters);\n    double width = UnitUtils.ConvertToInternalUnits(30, UnitTypeId.Meters);\n    double height = UnitUtils.ConvertToInternalUnits(6, UnitTypeId.Meters);\n\n    XYZ p1 = new XYZ(0, 0, 0);\n    XYZ p2 = new XYZ(length, 0, 0);\n    XYZ p3 = new XYZ(length, width, 0);\n    XYZ p4 = new XYZ(0, width, 0);\n\n    Line frontWall = Line.CreateBound(p1, p2);\n    Line rightWall = Line.CreateBound(p2, p3);\n    Line backWall = Line.CreateBound(p3, p4);\n    Line leftWall = Line.CreateBound(p4, p1);\n\n    Wall.Create(doc, frontWall, wallType.Id, level1.Id, height, 0, false, false);\n    Wall.Create(doc, rightWall, wallType.Id, level1.Id, height, 0, false, false);\n    Wall.Create(doc, backWall, wallType.Id, level1.Id, height, 0, false, false);\n    Wall.Create(doc, leftWall, wallType.Id, level1.Id, height, 0, false, false);\n\n    TaskDialog.Show(\"Paso 1 Completado\", \"Muros perimetrales creados.\");\n}"}
{"prompt":"Create an industrial building 50x30 meters. First, create the 6m high perimeter walls on Level 1.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nWallType wallType = new FilteredElementCollector(doc).OfClass(typeof(WallType)).FirstOrDefault() as WallType;\nif (level1 != null && wallType != null)\n{\n    double length = UnitUtils.ConvertToInternalUnits(50, UnitTypeId.Meters);\n    double width = UnitUtils.ConvertToInternalUnits(30, UnitTypeId.Meters);\n    double height = UnitUtils.ConvertToInternalUnits(6, UnitTypeId.Meters);\n\n    XYZ p1 = new XYZ(0, 0, 0);\n    XYZ p2 = new XYZ(length, 0, 0);\n    XYZ p3 = new XYZ(length, width, 0);\n    XYZ p4 = new XYZ(0, width, 0);\n\n    Line frontWall = Line.CreateBound(p1, p2);\n    Line rightWall = Line.CreateBound(p2, p3);\n    Line backWall = Line.CreateBound(p3, p4);\n    Line leftWall = Line.CreateBound(p4, p1);\n\n    Wall.Create(doc, frontWall, wallType.Id, level1.Id, height, 0, false, false);\n    Wall.Create(doc, rightWall, wallType.Id, level1.Id, height, 0, false, false);\n    Wall.Create(doc, backWall, wallType.Id, level1.Id, height, 0, false, false);\n    Wall.Create(doc, leftWall, wallType.Id, level1.Id, height, 0, false, false);\n\n    TaskDialog.Show(\"Step 1 Complete\", \"Perimeter walls created.\");\n}"}
{"prompt":"Ahora, coloca una rejilla de pilares de acero de 5x3 en la nave, con una separación de 10 metros en el eje largo y 15 en el ancho.","completion":"FamilySymbol columnSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().FirstOrDefault(s => s.Name.ToLower().Contains(\"acero\") || s.Name.ToLower().Contains(\"steel\")) as FamilySymbol;\nLevel level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nif(columnSymbol != null && level1 != null)\n{\n    if(!columnSymbol.IsActive) columnSymbol.Activate();\n    double spacingX = UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters);\n    double spacingY = UnitUtils.ConvertToInternalUnits(15, UnitTypeId.Meters);\n    int countX = 5;\n    int countY = 3;\n    for(int i = 0; i < countX; i++)\n    {\n        for(int j = 0; j < countY; j++)\n        {\n            doc.Create.NewFamilyInstance(new XYZ(i * spacingX, j * spacingY, 0), columnSymbol, level1, StructuralType.Column);\n        }\n    }\n    TaskDialog.Show(\"Paso 2 Completado\", \"Rejilla de pilares creada.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Se necesita un tipo de pilar de acero y el Nivel 1.\");\n}"}
{"prompt":"Now, place a 5x3 grid of steel columns in the building, spaced 10 meters on the long axis and 15 on the short axis.","completion":"FamilySymbol columnSymbol = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_StructuralColumns).WhereElementIsElementType().FirstOrDefault(s => s.Name.ToLower().Contains(\"steel\")) as FamilySymbol;\nLevel level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nif(columnSymbol != null && level1 != null)\n{\n    if(!columnSymbol.IsActive) columnSymbol.Activate();\n    double spacingX = UnitUtils.ConvertToInternalUnits(10, UnitTypeId.Meters);\n    double spacingY = UnitUtils.ConvertToInternalUnits(15, UnitTypeId.Meters);\n    int countX = 5;\n    int countY = 3;\n    for(int i = 0; i < countX; i++)\n    {\n        for(int j = 0; j < countY; j++)\n        {\n            doc.Create.NewFamilyInstance(new XYZ(i * spacingX, j * spacingY, 0), columnSymbol, level1, StructuralType.Column);\n        }\n    }\n    TaskDialog.Show(\"Step 2 Complete\", \"Column grid created.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"A steel column type and Level 1 are required.\");\n}"}
{"prompt":"Finalmente, crea un techo a dos aguas sobre la nave con una pendiente del 5%.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Nivel 1\") as Level;\nRoofType roofType = new FilteredElementCollector(doc).OfClass(typeof(RoofType)).FirstOrDefault() as RoofType;\nif(level1 != null && roofType != null)\n{\n    double length = UnitUtils.ConvertToInternalUnits(50, UnitTypeId.Meters);\n    double width = UnitUtils.ConvertToInternalUnits(30, UnitTypeId.Meters);\n    double baseHeight = UnitUtils.ConvertToInternalUnits(6, UnitTypeId.Meters);\n    \n    CurveArray footprint = new CurveArray();\n    footprint.Append(Line.CreateBound(new XYZ(0, 0, 0), new XYZ(length, 0, 0)));\n    footprint.Append(Line.CreateBound(new XYZ(length, 0, 0), new XYZ(length, width, 0)));\n    footprint.Append(Line.CreateBound(new XYZ(length, width, 0), new XYZ(0, width, 0)));\n    footprint.Append(Line.CreateBound(new XYZ(0, width, 0), new XYZ(0, 0, 0)));\n\n    ModelCurveArray mapping;\n    FootPrintRoof roof = doc.Create.NewFootPrintRoof(footprint, level1, roofType, out mapping);\n    roof.get_Parameter(BuiltInParameter.ROOF_BASE_LEVEL_PARAM).Set(level1.Id);\n    roof.get_Parameter(BuiltInParameter.ROOF_LEVEL_OFFSET_PARAM).Set(baseHeight);\n\n    roof.set_DefinesSlope(mapping.get_Item(0), true);\n    roof.set_SlopeAngle(mapping.get_Item(0), 0.05);\n    roof.set_DefinesSlope(mapping.get_Item(2), true);\n    roof.set_SlopeAngle(mapping.get_Item(2), 0.05);\n\n    TaskDialog.Show(\"Paso 3 Completado\", \"Techo a dos aguas creado. ¡Nave industrial finalizada!\");\n}"}
{"prompt":"Finally, create a gable roof over the building with a 5% slope.","completion":"Level level1 = new FilteredElementCollector(doc).OfClass(typeof(Level)).FirstOrDefault(l => l.Name == \"Level 1\") as Level;\nRoofType roofType = new FilteredElementCollector(doc).OfClass(typeof(RoofType)).FirstOrDefault() as RoofType;\nif(level1 != null && roofType != null)\n{\n    double length = UnitUtils.ConvertToInternalUnits(50, UnitTypeId.Meters);\n    double width = UnitUtils.ConvertToInternalUnits(30, UnitTypeId.Meters);\n    double baseHeight = UnitUtils.ConvertToInternalUnits(6, UnitTypeId.Meters);\n    \n    CurveArray footprint = new CurveArray();\n    footprint.Append(Line.CreateBound(new XYZ(0, 0, 0), new XYZ(length, 0, 0)));\n    footprint.Append(Line.CreateBound(new XYZ(length, 0, 0), new XYZ(length, width, 0)));\n    footprint.Append(Line.CreateBound(new XYZ(length, width, 0), new XYZ(0, width, 0)));\n    footprint.Append(Line.CreateBound(new XYZ(0, width, 0), new XYZ(0, 0, 0)));\n\n    ModelCurveArray mapping;\n    FootPrintRoof roof = doc.Create.NewFootPrintRoof(footprint, level1, roofType, out mapping);\n    roof.get_Parameter(BuiltInParameter.ROOF_BASE_LEVEL_PARAM).Set(level1.Id);\n    roof.get_Parameter(BuiltInParameter.ROOF_LEVEL_OFFSET_PARAM).Set(baseHeight);\n\n    roof.set_DefinesSlope(mapping.get_Item(0), true);\n    roof.set_SlopeAngle(mapping.get_Item(0), 0.05);\n    roof.set_DefinesSlope(mapping.get_Item(2), true);\n    roof.set_SlopeAngle(mapping.get_Item(2), 0.05);\n\n    TaskDialog.Show(\"Step 3 Complete\", \"Gable roof created. Industrial building finished!\");\n}"}
{"prompt":"Prepara una hoja de presentación para el cliente con una vista 3D y una tabla de áreas.","completion":"// Descomposición de Tarea: 1. Crear Vista 3D si no existe. 2. Crear Tabla de Áreas si no existe. 3. Crear Hoja. 4. Colocar elementos.\nstring view3dName = \"Vista 3D Cliente\";\nstring scheduleName = \"Tabla de Áreas Brutas\";\nstring sheetNumber = \"G-001\";\nstring sheetName = \"Presentación Cliente\";\n\n// Paso 1: Asegurar que la vista 3D existe.\nView3D view3d = new FilteredElementCollector(doc).OfClass(typeof(View3D)).Cast<View3D>().FirstOrDefault(v => v.Name == view3dName);\nif (view3d == null)\n{\n    ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.ThreeDimensional);\n    if (vft != null) \n    {\n        view3d = View3D.CreatePerspective(doc, vft.Id);\n        view3d.Name = view3dName;\n    }\n}\n\n// Paso 2: Asegurar que la tabla de áreas existe.\nViewSchedule schedule = new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Cast<ViewSchedule>().FirstOrDefault(s => s.Name == scheduleName);\nif (schedule == null)\n{\n    schedule = ViewSchedule.CreateSchedule(doc, new ElementId(BuiltInCategory.OST_Areas));\n    schedule.Name = scheduleName;\n    // Añadir campos básicos a la tabla\n    ScheduleDefinition def = schedule.Definition;\n    SchedulableField nameField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.ROOM_NAME);\n    SchedulableField areaField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.ROOM_AREA);\n    if (nameField != null) def.AddField(nameField);\n    if (areaField != null) def.AddField(areaField);\n}\n\n// Paso 3: Crear la hoja si no existe.\nViewSheet sheet = new FilteredElementCollector(doc).OfClass(typeof(ViewSheet)).Cast<ViewSheet>().FirstOrDefault(s => s.SheetNumber == sheetNumber);\nif (sheet == null)\n{\n    FamilySymbol titleBlock = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_TitleBlocks).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\n    if (titleBlock != null)\n    {\n        sheet = ViewSheet.Create(doc, titleBlock.Id);\n        sheet.Name = sheetName;\n        sheet.SheetNumber = sheetNumber;\n    }\n}\n\n// Paso 4: Colocar las vistas en la hoja.\nif (sheet != null && view3d != null && schedule != null)\n{\n    if (Viewport.CanAddViewToSheet(doc, sheet.Id, view3d.Id)) Viewport.Create(doc, sheet.Id, view3d.Id, new XYZ(0.25, 0.5, 0));\n    if (Viewport.CanAddViewToSheet(doc, sheet.Id, schedule.Id)) Viewport.Create(doc, sheet.Id, schedule.Id, new XYZ(0.75, 0.5, 0));\n    TaskDialog.Show(\"Éxito\", $\"Hoja '{sheetName}' preparada con la vista 3D y la tabla de áreas.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"No se pudieron crear o encontrar todos los elementos necesarios (cajetín, vistas).\");\n}"}
{"prompt":"Prepare a client presentation sheet with a 3D view and an area schedule.","completion":"// Task Decomposition: 1. Create 3D View if not exists. 2. Create Area Schedule if not exists. 3. Create Sheet. 4. Place elements.\nstring view3dName = \"Client 3D View\";\nstring scheduleName = \"Gross Area Schedule\";\nstring sheetNumber = \"G-001\";\nstring sheetName = \"Client Presentation\";\n\n// Step 1: Ensure the 3D view exists.\nView3D view3d = new FilteredElementCollector(doc).OfClass(typeof(View3D)).Cast<View3D>().FirstOrDefault(v => v.Name == view3dName);\nif (view3d == null)\n{\n    ViewFamilyType vft = new FilteredElementCollector(doc).OfClass(typeof(ViewFamilyType)).Cast<ViewFamilyType>().FirstOrDefault(v => v.ViewFamily == ViewFamily.ThreeDimensional);\n    if (vft != null) \n    {\n        view3d = View3D.CreatePerspective(doc, vft.Id);\n        view3d.Name = view3dName;\n    }\n}\n\n// Step 2: Ensure the area schedule exists.\nViewSchedule schedule = new FilteredElementCollector(doc).OfClass(typeof(ViewSchedule)).Cast<ViewSchedule>().FirstOrDefault(s => s.Name == scheduleName);\nif (schedule == null)\n{\n    schedule = ViewSchedule.CreateSchedule(doc, new ElementId(BuiltInCategory.OST_Areas));\n    schedule.Name = scheduleName;\n    // Add basic fields to the schedule\n    ScheduleDefinition def = schedule.Definition;\n    SchedulableField nameField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.ROOM_NAME);\n    SchedulableField areaField = def.GetSchedulableFields().FirstOrDefault(f => f.ParameterId.IntegerValue == (int)BuiltInParameter.ROOM_AREA);\n    if (nameField != null) def.AddField(nameField);\n    if (areaField != null) def.AddField(areaField);\n}\n\n// Step 3: Create the sheet if it doesn't exist.\nViewSheet sheet = new FilteredElementCollector(doc).OfClass(typeof(ViewSheet)).Cast<ViewSheet>().FirstOrDefault(s => s.SheetNumber == sheetNumber);\nif (sheet == null)\n{\n    FamilySymbol titleBlock = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_TitleBlocks).WhereElementIsElementType().FirstOrDefault() as FamilySymbol;\n    if (titleBlock != null)\n    {\n        sheet = ViewSheet.Create(doc, titleBlock.Id);\n        sheet.Name = sheetName;\n        sheet.SheetNumber = sheetNumber;\n    }\n}\n\n// Step 4: Place the views on the sheet.\nif (sheet != null && view3d != null && schedule != null)\n{\n    if (Viewport.CanAddViewToSheet(doc, sheet.Id, view3d.Id)) Viewport.Create(doc, sheet.Id, view3d.Id, new XYZ(0.25, 0.5, 0));\n    if (Viewport.CanAddViewToSheet(doc, sheet.Id, schedule.Id)) Viewport.Create(doc, sheet.Id, schedule.Id, new XYZ(0.75, 0.5, 0));\n    TaskDialog.Show(\"Success\", $\"Sheet '{sheetName}' prepared with the 3D view and area schedule.\");\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Could not create or find all necessary elements (title block, views).\");\n}"}
{"prompt":"Voy a necesitar trabajar con los elementos estructurales. Por favor, asegúrate de que existen worksets para 'Columnas', 'Vigas' y 'Cimentación', y si no, créalos.","completion":"// Razonamiento: Comprobar y crear múltiples elementos requeridos antes de una tarea mayor.\nif(doc.IsWorkshared)\n{\n    List<string> requiredWorksets = new List<string> { \"STRUCT_Columnas\", \"STRUCT_Vigas\", \"STRUCT_Cimentación\" };\n    int createdCount = 0;\n    StringBuilder report = new StringBuilder(\"Estado de Worksets Estructurales:\\n\");\n\n    foreach(string name in requiredWorksets)\n    {\n        if(WorksetTable.IsWorksetNameUnique(doc, name))\n        {\n            Workset.Create(doc, name);\n            report.AppendLine($\"- Workset '{name}' CREADO.\");\n            createdCount++;\n        }\n        else\n        {\n            report.AppendLine($\"- Workset '{name}' ya existe.\");\n        }\n    }\n    report.AppendLine($\"\\n{createdCount} worksets nuevos fueron creados. Ya estás listo para trabajar.\");\n    TaskDialog.Show(\"Preparación de Worksets\", report.ToString());\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"Esta acción requiere un modelo compartido (Workshared).\");\n}"}
{"prompt":"I'm going to work with structural elements. Please ensure worksets for 'Columns', 'Beams', and 'Foundations' exist, and create them if they don't.","completion":"// Reasoning: Check for and create multiple required elements before a major task.\nif(doc.IsWorkshared)\n{\n    List<string> requiredWorksets = new List<string> { \"STRUCT_Columns\", \"STRUCT_Beams\", \"STRUCT_Foundations\" };\n    int createdCount = 0;\n    StringBuilder report = new StringBuilder(\"Structural Worksets Status:\\n\");\n\n    foreach(string name in requiredWorksets)\n    {\n        if(WorksetTable.IsWorksetNameUnique(doc, name))\n        {\n            Workset.Create(doc, name);\n            report.AppendLine($\"- Workset '{name}' CREATED.\");\n            createdCount++;\n        }\n        else\n        {\n            report.AppendLine($\"- Workset '{name}' already exists.\");\n        }\n    }\n    report.AppendLine($\"\\n{createdCount} new worksets were created. You are now ready to work.\");\n    TaskDialog.Show(\"Workset Preparation\", report.ToString());\n}\nelse\n{\n    TaskDialog.Show(\"Error\", \"This action requires a workshared model.\");\n}"}
{"prompt":"Quiero pintar los muros según su función. Pinta los muros exteriores de azul y los interiores de verde.","completion":"// Razonamiento: Aplicar diferentes acciones basadas en las propiedades de un elemento.\nMaterial exteriorPaint = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name == \"Pintura Azul\") as Material;\nMaterial interiorPaint = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name == \"Pintura Verde\") as Material;\n\nif (exteriorPaint == null || interiorPaint == null)\n{\n    TaskDialog.Show(\"Error\", \"Se necesitan los materiales 'Pintura Azul' y 'Pintura Verde' en el proyecto.\");\n    return;\n}\n\nList<Wall> allWalls = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WhereElementIsNotElementType().Cast<Wall>().ToList();\nint exteriorCount = 0;\nint interiorCount = 0;\n\nforeach (Wall wall in allWalls)\n{\n    Face face = HostObjectUtils.GetSideFaces(wall, ShellLayerType.Exterior).FirstOrDefault();\n    if (face == null) continue;\n\n    if (wall.WallType.Function == WallFunction.Exterior)\n    {\n        doc.Paint(wall.Id, face, exteriorPaint.Id);\n        exteriorCount++;\n    }\n    else if (wall.WallType.Function == WallFunction.Interior)\n    {\n        doc.Paint(wall.Id, face, interiorPaint.Id);\n        interiorCount++;\n    }\n}\nTaskDialog.Show(\"Resultado\", $\"Se pintaron {exteriorCount} muros exteriores de azul y {interiorCount} muros interiores de verde.\");"}
{"prompt":"I want to paint walls based on their function. Paint exterior walls blue and interior walls green.","completion":"// Reasoning: Apply different actions based on an element's properties.\nMaterial exteriorPaint = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name == \"Blue Paint\") as Material;\nMaterial interiorPaint = new FilteredElementCollector(doc).OfClass(typeof(Material)).FirstOrDefault(m => m.Name == \"Green Paint\") as Material;\n\nif (exteriorPaint == null || interiorPaint == null)\n{\n    TaskDialog.Show(\"Error\", \"Materials 'Blue Paint' and 'Green Paint' are required in the project.\");\n    return;\n}\n\nList<Wall> allWalls = new FilteredElementCollector(doc).OfClass(typeof(Wall)).WhereElementIsNotElementType().Cast<Wall>().ToList();\nint exteriorCount = 0;\nint interiorCount = 0;\n\nforeach (Wall wall in allWalls)\n{\n    Face face = HostObjectUtils.GetSideFaces(wall, ShellLayerType.Exterior).FirstOrDefault();\n    if (face == null) continue;\n\n    if (wall.WallType.Function == WallFunction.Exterior)\n    {\n        doc.Paint(wall.Id, face, exteriorPaint.Id);\n        exteriorCount++;\n    }\n    else if (wall.WallType.Function == WallFunction.Interior)\n    {\n        doc.Paint(wall.Id, face, interiorPaint.Id);\n        interiorCount++;\n    }\n}\nTaskDialog.Show(\"Result\", $\"Painted {exteriorCount} exterior walls blue and {interiorCount} interior walls green.\");"}